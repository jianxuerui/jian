#!/bin/bash
# -*- coding: UTF-8 -*-
# Nockchainæ™ºèƒ½å®‰è£…è„šæœ¬ v6.0 - å½»åº•è§£å†³Minicondaå†²çª

# é¢œè‰²å®šä¹‰
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RESET='\033[0m'

# è·¯å¾„é…ç½®
INSTALL_PREFIX="$HOME/.local"
NOCKCHAIN_DIR="$HOME/nockchain"
LOG_FILE="$HOME/nockchain_install.log"
BACKUP_DIR="$HOME/nockchain_backup"
MINICONDA_DIR="$HOME/.miniconda3"

# ä¼˜åŒ–ç¯å¢ƒå˜é‡
export PATH="$INSTALL_PREFIX/bin:$HOME/.cargo/bin:$PATH"
export RUST_MIN_STACK=16777216
export RUST_LOG=error
export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1"
export CARGO_BUILD_JOBS=1
export MALLOC_ARENA_MAX=2

# æ¶ˆæ¯è¾“å‡ºå‡½æ•°
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${RESET}"
}

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

check_command() {
    command -v "$1" >/dev/null 2>&1
}

# æ˜¾ç¤ºä¸»èœå•
show_menu() {
    clear
    echo -e "${BLUE}
=======================================
 Nockchain æ™ºèƒ½å®‰è£…è„šæœ¬ v6.0
=======================================
${RESET}"
    echo -e "${YELLOW}1. æ™ºèƒ½å®Œæ•´å®‰è£…ï¼ˆè‡ªåŠ¨è§£å†³æ‰€æœ‰å†²çªï¼‰"
    echo "2. é…ç½®æŒ–çŸ¿å…¬é’¥"
    echo "3. å¯åŠ¨ä¼˜åŒ–æŒ–çŸ¿"
    echo "4. æŸ¥çœ‹å®æ—¶æ—¥å¿—"
    echo "5. æ£€æŸ¥é’±åŒ…ä½™é¢"
    echo "6. ç³»ç»ŸçŠ¶æ€ç›‘æ§"
    echo "7. å¤‡ä»½é’±åŒ…å¯†é’¥"
    echo "8. ä¿®å¤ç¯å¢ƒé—®é¢˜"
    echo "9. é€€å‡ºè„šæœ¬"
    echo -e "${BLUE}=======================================${RESET}"
}

# æ™ºèƒ½æ£€æµ‹å¹¶å¤„ç†Minicondaå†²çª
handle_miniconda_conflict() {
    print_message "$CYAN" "æ­£åœ¨æ£€æµ‹Minicondaå®‰è£…çŠ¶æ€..."
    
    if [ -d "$MINICONDA_DIR" ]; then
        print_message "$YELLOW" "æ£€æµ‹åˆ°ç°æœ‰Minicondaå®‰è£…ç›®å½•: $MINICONDA_DIR"
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆå®‰è£…
        if [ -f "$MINICONDA_DIR/bin/conda" ] && "$MINICONDA_DIR/bin/conda" --version >/dev/null 2>&1; then
            print_message "$GREEN" "ç°æœ‰Minicondaå®‰è£…æœ‰æ•ˆ"
            
            # æ£€æŸ¥ç‰ˆæœ¬
            local conda_version=$("$MINICONDA_DIR/bin/conda" --version 2>/dev/null)
            print_message "$YELLOW" "å½“å‰ç‰ˆæœ¬: $conda_version"
            
            read -p "æ˜¯å¦ä½¿ç”¨ç°æœ‰å®‰è£…ï¼Ÿ(Y/n): " use_existing
            if [[ ! "$use_existing" =~ ^[Nn]$ ]]; then
                export PATH="$MINICONDA_DIR/bin:$PATH"
                source "$MINICONDA_DIR/etc/profile.d/conda.sh" 2>/dev/null || true
                print_message "$GREEN" "ä½¿ç”¨ç°æœ‰Minicondaå®‰è£…"
                return 0
            fi
        else
            print_message "$YELLOW" "ç°æœ‰å®‰è£…æ— æ•ˆæˆ–æŸå"
        fi
        
        # å¤„ç†æ— æ•ˆæˆ–ç”¨æˆ·é€‰æ‹©é‡æ–°å®‰è£…çš„æƒ…å†µ
        print_message "$CYAN" "é€‰æ‹©å¤„ç†æ–¹å¼ï¼š"
        echo "1. å®Œå…¨æ¸…ç†å¹¶é‡æ–°å®‰è£…ï¼ˆæ¨èï¼‰"
        echo "2. å°è¯•æ›´æ–°ç°æœ‰å®‰è£…"
        echo "3. å¤‡ä»½ç°æœ‰å®‰è£…å¹¶é‡æ–°å®‰è£…"
        
        read -p "è¯·é€‰æ‹©ï¼ˆ1-3ï¼‰: " choice
        case $choice in
            1)
                print_message "$CYAN" "å®Œå…¨æ¸…ç†ç°æœ‰å®‰è£…..."
                clean_miniconda_completely
                ;;
            2)
                print_message "$CYAN" "å°è¯•æ›´æ–°ç°æœ‰å®‰è£…..."
                update_existing_miniconda
                return $?
                ;;
            3)
                print_message "$CYAN" "å¤‡ä»½ç°æœ‰å®‰è£…..."
                backup_existing_miniconda
                clean_miniconda_completely
                ;;
            *)
                print_message "$RED" "æ— æ•ˆé€‰æ‹©ï¼Œé»˜è®¤å®Œå…¨æ¸…ç†"
                clean_miniconda_completely
                ;;
        esac
    fi
    
    # æ‰§è¡Œå…¨æ–°å®‰è£…
    install_miniconda_fresh
}

# å®Œå…¨æ¸…ç†Miniconda
clean_miniconda_completely() {
    print_message "$CYAN" "æ­£åœ¨å®Œå…¨æ¸…ç†Miniconda..."
    
    # åœæ­¢æ‰€æœ‰condaç›¸å…³è¿›ç¨‹
    pkill -f conda 2>/dev/null || true
    pkill -f python 2>/dev/null || true
    
    # åˆ é™¤å®‰è£…ç›®å½•
    if [ -d "$MINICONDA_DIR" ]; then
        rm -rf "$MINICONDA_DIR"
        print_message "$GREEN" "å·²åˆ é™¤Minicondaç›®å½•"
    fi
    
    # æ¸…ç†ç¯å¢ƒå˜é‡é…ç½®
    local shell_configs=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    for config in "${shell_configs[@]}"; do
        if [ -f "$config" ]; then
            # å¤‡ä»½åŸé…ç½®
            cp "$config" "$config.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
            
            # åˆ é™¤condaç›¸å…³è¡Œ
            sed -i '/miniconda3/d' "$config" 2>/dev/null || true
            sed -i '/conda initialize/,/conda initialize/d' "$config" 2>/dev/null || true
        fi
    done
    
    # æ¸…ç†å…¶ä»–ç›¸å…³æ–‡ä»¶
    rm -rf ~/.conda 2>/dev/null || true
    rm -rf ~/.condarc 2>/dev/null || true
    rm -rf ~/.anaconda_backup 2>/dev/null || true
    
    print_message "$GREEN" "Minicondaå®Œå…¨æ¸…ç†å®Œæˆ"
    log_message "Minicondaå®Œå…¨æ¸…ç†å®Œæˆ"
}

# å¤‡ä»½ç°æœ‰å®‰è£…
backup_existing_miniconda() {
    print_message "$CYAN" "æ­£åœ¨å¤‡ä»½ç°æœ‰Minicondaå®‰è£…..."
    
    local backup_path="$BACKUP_DIR/miniconda_backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_path"
    
    # å¤‡ä»½é‡è¦é…ç½®å’Œç¯å¢ƒ
    if [ -d "$MINICONDA_DIR/envs" ]; then
        cp -r "$MINICONDA_DIR/envs" "$backup_path/" 2>/dev/null || true
    fi
    
    if [ -f "$HOME/.condarc" ]; then
        cp "$HOME/.condarc" "$backup_path/" 2>/dev/null || true
    fi
    
    # å¯¼å‡ºç¯å¢ƒåˆ—è¡¨
    if [ -f "$MINICONDA_DIR/bin/conda" ]; then
        "$MINICONDA_DIR/bin/conda" env list > "$backup_path/env_list.txt" 2>/dev/null || true
    fi
    
    print_message "$GREEN" "å¤‡ä»½å®Œæˆ: $backup_path"
    log_message "Minicondaå¤‡ä»½å®Œæˆ: $backup_path"
}

# å°è¯•æ›´æ–°ç°æœ‰å®‰è£…
update_existing_miniconda() {
    print_message "$CYAN" "æ­£åœ¨å°è¯•æ›´æ–°ç°æœ‰Minicondaå®‰è£…..."
    
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "ä¸æ”¯æŒçš„æ¶æ„: $arch"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_updater.sh"
    
    # ä¸‹è½½å®‰è£…ç¨‹åº
    if ! wget -q --show-progress "$MINICONDA_URL" -O "$installer"; then
        print_message "$RED" "ä¸‹è½½Minicondaå®‰è£…ç¨‹åºå¤±è´¥"
        return 1
    fi
    
    chmod +x "$installer"
    
    # å°è¯•ä½¿ç”¨-ué€‰é¡¹æ›´æ–°
    if bash "$installer" -b -u -p "$MINICONDA_DIR"; then
        print_message "$GREEN" "Minicondaæ›´æ–°æˆåŠŸ"
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        export PATH="$MINICONDA_DIR/bin:$PATH"
        rm -f "$installer"
        return 0
    else
        print_message "$YELLOW" "æ›´æ–°å¤±è´¥ï¼Œå°†æ‰§è¡Œå®Œå…¨é‡æ–°å®‰è£…"
        rm -f "$installer"
        return 1
    fi
}

# å…¨æ–°å®‰è£…Miniconda
install_miniconda_fresh() {
    print_message "$CYAN" "æ­£åœ¨æ‰§è¡ŒMinicondaå…¨æ–°å®‰è£…..."
    
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "ä¸æ”¯æŒçš„æ¶æ„: $arch"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_installer.sh"
    
    # ä¸‹è½½å®‰è£…ç¨‹åº
    print_message "$CYAN" "ä¸‹è½½Minicondaå®‰è£…ç¨‹åº..."
    if ! wget -q --show-progress "$MINICONDA_URL" -O "$installer"; then
        print_message "$RED" "ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥"
        return 1
    fi
    
    chmod +x "$installer"
    
    # é™é»˜å®‰è£…
    print_message "$CYAN" "æ­£åœ¨å®‰è£…Miniconda..."
    if bash "$installer" -b -p "$MINICONDA_DIR"; then
        print_message "$GREEN" "Minicondaå®‰è£…æˆåŠŸ"
        
        # åˆå§‹åŒ–conda
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        export PATH="$MINICONDA_DIR/bin:$PATH"
        
        # é…ç½®conda
        conda config --set auto_activate_base false
        conda config --set channel_priority strict
        
        # æ¸…ç†å®‰è£…æ–‡ä»¶
        rm -f "$installer"
        
        print_message "$GREEN" "Minicondaé…ç½®å®Œæˆ"
        log_message "Minicondaå…¨æ–°å®‰è£…å®Œæˆ"
        return 0
    else
        print_message "$RED" "Minicondaå®‰è£…å¤±è´¥"
        rm -f "$installer"
        return 1
    fi
}

# å®‰è£…ç¼–è¯‘ç¯å¢ƒ
setup_build_environment() {
    print_message "$CYAN" "æ­£åœ¨è®¾ç½®ç¼–è¯‘ç¯å¢ƒ..."
    
    # ç¡®ä¿condaå¯ç”¨
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    export PATH="$MINICONDA_DIR/bin:$PATH"
    
    # åˆ›å»ºä¸“ç”¨ç¼–è¯‘ç¯å¢ƒ
    print_message "$CYAN" "åˆ›å»ºNockchainç¼–è¯‘ç¯å¢ƒ..."
    conda create -n nockchain-build -y python=3.9 --no-default-packages || {
        print_message "$YELLOW" "ç¯å¢ƒå·²å­˜åœ¨ï¼Œæ­£åœ¨æ›´æ–°..."
    }
    
    # æ¿€æ´»ç¯å¢ƒ
    conda activate nockchain-build
    
    # é€æ­¥å®‰è£…ç¼–è¯‘å·¥å…·ï¼ˆé¿å…å†…å­˜å³°å€¼ï¼‰
    local tools=("gcc_linux-64" "make" "cmake" "clang" "pkg-config" "openssl" "git")
    
    for tool in "${tools[@]}"; do
        print_message "$YELLOW" "å®‰è£… $tool..."
        conda install -y "$tool" -c conda-forge --quiet || {
            print_message "$YELLOW" "è·³è¿‡ $toolï¼ˆå¯èƒ½ä¸å¯ç”¨ï¼‰"
        }
        sleep 1  # ç»™ç³»ç»Ÿä¸€äº›å–˜æ¯æ—¶é—´
    done
    
    print_message "$GREEN" "ç¼–è¯‘ç¯å¢ƒè®¾ç½®å®Œæˆ"
}

# å®‰è£…Rustå·¥å…·é“¾
install_rust_optimized() {
    print_message "$CYAN" "æ­£åœ¨å®‰è£…Rustå·¥å…·é“¾..."
    
    if check_command "rustc" && check_command "cargo"; then
        print_message "$YELLOW" "Rustå·²å®‰è£…: $(rustc --version)"
        return 0
    fi
    
    # ä¸‹è½½å¹¶å®‰è£…rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
        --default-toolchain stable \
        --profile minimal \
        --no-modify-path
    
    source "$HOME/.cargo/env"
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # é…ç½®Cargoè¿›è¡Œå†…å­˜ä¼˜åŒ–ç¼–è¯‘
    mkdir -p "$HOME/.cargo"
    cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[profile.dev]
debug = false
opt-level = 1

[profile.release]
debug = false
lto = false
codegen-units = 1

[target.x86_64-unknown-linux-gnu]
linker = "clang"
EOF
    
    print_message "$GREEN" "Rustå·¥å…·é“¾å®‰è£…å®Œæˆ"
}

# ç¼–è¯‘Nockchainé¡¹ç›®
compile_nockchain_optimized() {
    print_message "$CYAN" "å¼€å§‹ç¼–è¯‘Nockchainé¡¹ç›®..."
    
    cd "$NOCKCHAIN_DIR" || return 1
    
    # è®¾ç½®æœ€ä¼˜ç¼–è¯‘ç¯å¢ƒ
    export RUST_MIN_STACK=16777216
    export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1"
    export CARGO_BUILD_JOBS=1
    export CARGO_INCREMENTAL=0
    export RUST_LOG=error
    export RUST_BACKTRACE=0
    
    # æ¿€æ´»condaç¯å¢ƒ
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    # æ¸…ç†ä¹‹å‰çš„ç¼–è¯‘ç»“æœ
    print_message "$CYAN" "æ¸…ç†ç¼–è¯‘ç¼“å­˜..."
    rm -rf target/ || true
    cargo clean || true
    
    # åˆ†æ­¥éª¤ç¼–è¯‘ä»¥å‡å°‘å†…å­˜å‹åŠ›
    print_message "$CYAN" "ç¼–è¯‘hooncç¼–è¯‘å™¨..."
    if ! timeout 3600 make install-hoonc; then
        print_message "$YELLOW" "æ ‡å‡†ç¼–è¯‘å¤±è´¥ï¼Œå°è¯•æ‰‹åŠ¨ç¼–è¯‘..."
        
        cd crates/hoonc
        cargo build --release --bin hoonc --jobs 1 || {
            print_message "$RED" "hooncç¼–è¯‘å¤±è´¥"
            return 1
        }
        
        # æ‰‹åŠ¨å®‰è£…
        cp target/release/hoonc "$HOME/.cargo/bin/"
        cd ../..
    fi
    
    # ç­‰å¾…å†…å­˜é‡Šæ”¾
    sleep 5
    
    print_message "$CYAN" "ç¼–è¯‘ä¸»é¡¹ç›®..."
    if ! timeout 3600 make build; then
        print_message "$RED" "ä¸»é¡¹ç›®ç¼–è¯‘å¤±è´¥"
        return 1
    fi
    
    print_message "$CYAN" "å®‰è£…ç»„ä»¶..."
    make install-nockchain-wallet || print_message "$YELLOW" "é’±åŒ…å®‰è£…å¤±è´¥"
    make install-nockchain || print_message "$YELLOW" "ä¸»ç¨‹åºå®‰è£…å¤±è´¥"
    
    print_message "$GREEN" "Nockchainç¼–è¯‘å®Œæˆï¼"
}

# ä¸»å®‰è£…å‡½æ•°
install_nockchain_intelligent() {
    print_message "$GREEN" ">>> å¼€å§‹Nockchainæ™ºèƒ½å®‰è£…..."
    log_message "å¼€å§‹æ™ºèƒ½å®‰è£…æµç¨‹"
    
    # æ£€æŸ¥ç³»ç»Ÿèµ„æº
    local total_ram=$(free -m 2>/dev/null | awk '/^Mem:/{print $2}' || echo "0")
    local available_space=$(df -m ~ 2>/dev/null | awk 'NR==2{print $4}' || echo "0")
    
    print_message "$YELLOW" "ç³»ç»Ÿæ£€æŸ¥ï¼š"
    print_message "$YELLOW" "- å†…å­˜: ${total_ram}MB"
    print_message "$YELLOW" "- å¯ç”¨ç©ºé—´: ${available_space}MB"
    
    if [ "$total_ram" -lt 2048 ] && [ "$total_ram" -gt 0 ]; then
        print_message "$YELLOW" "è­¦å‘Šï¼šå†…å­˜è¾ƒä½ï¼Œå°†ä½¿ç”¨è¶…çº§ä¼˜åŒ–æ¨¡å¼"
    fi
    
    # åˆ›å»ºå¿…è¦ç›®å½•
    mkdir -p "$BACKUP_DIR" "$INSTALL_PREFIX"/{bin,lib,include}
    
    # æ­¥éª¤1ï¼šæ™ºèƒ½å¤„ç†Miniconda
    print_message "$MAGENTA" "æ­¥éª¤ 1/5: æ™ºèƒ½å¤„ç†Miniconda..."
    if ! handle_miniconda_conflict; then
        print_message "$RED" "Minicondaå¤„ç†å¤±è´¥"
        return 1
    fi
    
    # æ­¥éª¤2ï¼šè®¾ç½®ç¼–è¯‘ç¯å¢ƒ
    print_message "$MAGENTA" "æ­¥éª¤ 2/5: è®¾ç½®ç¼–è¯‘ç¯å¢ƒ..."
    if ! setup_build_environment; then
        print_message "$RED" "ç¼–è¯‘ç¯å¢ƒè®¾ç½®å¤±è´¥"
        return 1
    fi
    
    # æ­¥éª¤3ï¼šå®‰è£…Rust
    print_message "$MAGENTA" "æ­¥éª¤ 3/5: å®‰è£…Rustå·¥å…·é“¾..."
    if ! install_rust_optimized; then
        print_message "$RED" "Rustå®‰è£…å¤±è´¥"
        return 1
    fi
    
    # æ­¥éª¤4ï¼šå…‹éš†é¡¹ç›®
    print_message "$MAGENTA" "æ­¥éª¤ 4/5: è·å–Nockchainæºç ..."
    if [ -d "$NOCKCHAIN_DIR" ]; then
        print_message "$YELLOW" "æ›´æ–°ç°æœ‰é¡¹ç›®..."
        cd "$NOCKCHAIN_DIR"
        git pull origin main || {
            cd "$HOME"
            rm -rf "$NOCKCHAIN_DIR"
            git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR"
        }
    else
        git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR" || {
            print_message "$RED" "é¡¹ç›®å…‹éš†å¤±è´¥"
            return 1
        }
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # é…ç½®ç¯å¢ƒæ–‡ä»¶
    if [ -f ".env_example" ]; then
        cp .env_example .env
    else
        cat > .env << 'EOF'
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000
NETWORK=mainnet
MAX_PEERS=2000
LOG_LEVEL=error
RUST_LOG=error
RUST_MIN_STACK=16777216
EOF
    fi
    
    # æ­¥éª¤5ï¼šç¼–è¯‘é¡¹ç›®
    print_message "$MAGENTA" "æ­¥éª¤ 5/5: ç¼–è¯‘Nockchain..."
    if ! compile_nockchain_optimized; then
        print_message "$RED" "é¡¹ç›®ç¼–è¯‘å¤±è´¥"
        return 1
    fi
    
    # ç”Ÿæˆé’±åŒ…
    if check_command "nockchain-wallet"; then
        print_message "$CYAN" "ç”Ÿæˆé’±åŒ…..."
        local wallet_output
        wallet_output=$(nockchain-wallet keygen 2>&1)
        
        if [ $? -eq 0 ]; then
            print_message "$GREEN" "é’±åŒ…ç”ŸæˆæˆåŠŸï¼"
            echo "$wallet_output"
            
            local pubkey=$(echo "$wallet_output" | grep -E "Public key:|å…¬é’¥:" | awk '{print $NF}')
            if [ -n "$pubkey" ]; then
                sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$pubkey/" .env
                print_message "$GREEN" "å…¬é’¥è‡ªåŠ¨é…ç½®å®Œæˆ"
            fi
            
            echo "$wallet_output" > "$BACKUP_DIR/wallet_$(date +%Y%m%d_%H%M%S).txt"
        fi
    fi
    
    # åˆ›å»ºä¾¿æ·å¯åŠ¨è„šæœ¬
    cat > "$HOME/nockchain_env.sh" << 'EOF'
#!/bin/bash
# Nockchainç¯å¢ƒæ¿€æ´»è„šæœ¬
source "$HOME/.miniconda3/etc/profile.d/conda.sh"
conda activate nockchain-build
export RUST_MIN_STACK=16777216
export RUST_LOG=error
export PATH="$HOME/.cargo/bin:$PATH"
cd "$HOME/nockchain"
echo "Nockchainç¯å¢ƒå·²æ¿€æ´»"
echo "ä½¿ç”¨ 'make run-nockchain' å¯åŠ¨æŒ–çŸ¿"
EOF
    chmod +x "$HOME/nockchain_env.sh"
    
    print_message "$GREEN" "ğŸ‰ Nockchainæ™ºèƒ½å®‰è£…å®Œæˆï¼"
    print_message "$YELLOW" "å®‰è£…è·¯å¾„: $NOCKCHAIN_DIR"
    print_message "$YELLOW" "ç¯å¢ƒæ¿€æ´»: source ~/nockchain_env.sh"
    print_message "$CYAN" "æ‰€æœ‰å†²çªé—®é¢˜å·²å½»åº•è§£å†³ï¼"
    
    log_message "æ™ºèƒ½å®‰è£…æµç¨‹å®Œæˆ"
}

# éªŒè¯å…¬é’¥æ ¼å¼
validate_pubkey() {
    local pubkey=$1
    if [[ $pubkey =~ ^[0-9a-fA-F]{128}$ ]] || [[ $pubkey =~ ^[1-9A-HJ-NP-Za-km-z]{40,50}$ ]]; then
        return 0
    else
        print_message "$RED" "é”™è¯¯ï¼šå…¬é’¥æ ¼å¼æ— æ•ˆ"
        return 1
    fi
}

# é…ç½®æŒ–çŸ¿å…¬é’¥
configure_mining_key() {
    print_message "$CYAN" ">>> é…ç½®æŒ–çŸ¿å…¬é’¥"
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "é”™è¯¯ï¼šæœªæ‰¾åˆ°é…ç½®æ–‡ä»¶"
        return 1
    fi
    
    local current_key=$(grep "MINING_PUBKEY" "$NOCKCHAIN_DIR/.env" | cut -d'=' -f2)
    print_message "$YELLOW" "å½“å‰å…¬é’¥: $current_key"
    
    read -p "è¯·è¾“å…¥æ–°çš„æŒ–çŸ¿å…¬é’¥: " new_pubkey
    
    if [ -n "$new_pubkey" ] && validate_pubkey "$new_pubkey"; then
        cd "$NOCKCHAIN_DIR"
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" .env
        print_message "$GREEN" "å…¬é’¥æ›´æ–°æˆåŠŸï¼"
    fi
}

# å¯åŠ¨æŒ–çŸ¿
start_mining() {
    print_message "$GREEN" ">>> å¯åŠ¨ä¼˜åŒ–æŒ–çŸ¿èŠ‚ç‚¹..."
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "é”™è¯¯ï¼šæœªæ‰¾åˆ°å®‰è£…"
        return 1
    fi
    
    # æ£€æŸ¥ç°æœ‰è¿›ç¨‹
    if screen -list | grep -q "nockchain"; then
        read -p "æ£€æµ‹åˆ°æŒ–çŸ¿è¿›ç¨‹æ­£åœ¨è¿è¡Œï¼Œæ˜¯å¦é‡å¯ï¼Ÿ(y/N): " restart
        if [[ "$restart" =~ ^[Yy]$ ]]; then
            screen -S nockchain -X quit
            sleep 3
        else
            return 0
        fi
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # æ¿€æ´»ç¯å¢ƒ
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    # è®¾ç½®ç¯å¢ƒå˜é‡
    export RUST_MIN_STACK=16777216
    export RUST_LOG=error
    export MALLOC_ARENA_MAX=2
    
    print_message "$CYAN" "æ­£åœ¨å¯åŠ¨æŒ–çŸ¿èŠ‚ç‚¹..."
    
    # åœ¨screenä¸­å¯åŠ¨
    screen -dmS nockchain bash -c "
        source '$MINICONDA_DIR/etc/profile.d/conda.sh'
        conda activate nockchain-build
        cd '$NOCKCHAIN_DIR'
        export RUST_MIN_STACK=16777216
        export RUST_LOG=error
        export MALLOC_ARENA_MAX=2
        source .env
        mkdir -p logs
        echo '=== Nockchain æ™ºèƒ½ä¼˜åŒ–æŒ–çŸ¿ ===' > logs/mining.log
        echo 'å¯åŠ¨æ—¶é—´: \$(date)' >> logs/mining.log
        echo 'ç‰ˆæœ¬: æ™ºèƒ½å†²çªè§£å†³ç‰ˆ' >> logs/mining.log
        echo '=============================' >> logs/mining.log
        make run-nockchain 2>&1 | tee -a logs/mining.log
    "
    
    sleep 5
    
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "ğŸš€ æŒ–çŸ¿èŠ‚ç‚¹å¯åŠ¨æˆåŠŸï¼"
        print_message "$CYAN" "- æŸ¥çœ‹çŠ¶æ€: screen -r nockchain"
        print_message "$CYAN" "- åœæ­¢æŒ–çŸ¿: screen -S nockchain -X quit"
    else
        print_message "$RED" "å¯åŠ¨å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—"
    fi
}

# æŸ¥çœ‹æ—¥å¿—
view_logs() {
    print_message "$GREEN" ">>> æ˜¾ç¤ºæŒ–çŸ¿æ—¥å¿—"
    
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        tail -f "$NOCKCHAIN_DIR/logs/mining.log"
    else
        if screen -list | grep -q "nockchain"; then
            screen -r nockchain
        else
            print_message "$RED" "æœªæ‰¾åˆ°æ—¥å¿—æˆ–è¿›ç¨‹"
        fi
    fi
}

# æ£€æŸ¥ä½™é¢
check_balance() {
    print_message "$GREEN" ">>> æ£€æŸ¥é’±åŒ…ä½™é¢"
    
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    cd "$NOCKCHAIN_DIR"
    local pubkey=$(grep "MINING_PUBKEY" .env | cut -d'=' -f2)
    
    if [ -z "$pubkey" ] || [ "$pubkey" = "0000000000000000000000000000000000000000000000000000000000000000" ]; then
        print_message "$RED" "æœªé…ç½®æœ‰æ•ˆå…¬é’¥"
        return 1
    fi
    
    print_message "$CYAN" "æŸ¥è¯¢ä½™é¢: $pubkey"
    
    if check_command "nockchain-wallet"; then
        for socket in ./nockchain*.sock; do
            if [ -S "$socket" ]; then
                nockchain-wallet --nockchain-socket "$socket" list-notes-by-pubkey -p "$pubkey" 2>/dev/null && break
            fi
        done
    fi
}

# ç³»ç»Ÿç›‘æ§
system_monitor() {
    print_message "$BLUE" "====== ç³»ç»ŸçŠ¶æ€ç›‘æ§ ======"
    
    # åŸºæœ¬ç³»ç»Ÿä¿¡æ¯
    local mem_info=$(free -h | awk '/^Mem:/{print "ä½¿ç”¨: "$3" / æ€»è®¡: "$2}')
    print_message "$YELLOW" "å†…å­˜çŠ¶æ€: $mem_info"
    
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    print_message "$YELLOW" "ç³»ç»Ÿè´Ÿè½½: $load_avg"
    
    # æŒ–çŸ¿çŠ¶æ€
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "æŒ–çŸ¿çŠ¶æ€: âœ… æ­£åœ¨è¿è¡Œ"
        
        if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
            print_message "$CYAN" "æœ€è¿‘æ—¥å¿—ï¼š"
            tail -n 3 "$NOCKCHAIN_DIR/logs/mining.log" 2>/dev/null
        fi
    else
        print_message "$RED" "æŒ–çŸ¿çŠ¶æ€: âŒ æœªè¿è¡Œ"
    fi
    
    # ç¯å¢ƒçŠ¶æ€
    print_message "$CYAN" "ç¯å¢ƒçŠ¶æ€ï¼š"
    print_message "$YELLOW" "- Conda: $(which conda 2>/dev/null || echo 'æœªå®‰è£…')"
    print_message "$YELLOW" "- Rust: $(which rustc 2>/dev/null || echo 'æœªå®‰è£…')"
}

# å¤‡ä»½é’±åŒ…
backup_wallet() {
    print_message "$GREEN" ">>> å¤‡ä»½é’±åŒ…å¯†é’¥"
    
    local backup_file="$BACKUP_DIR/complete_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    mkdir -p "$BACKUP_DIR"
    
    cd "$NOCKCHAIN_DIR" 2>/dev/null || return 1
    
    # åˆ›å»ºå¤‡ä»½
    tar -czf "$backup_file" .env logs/ *.txt 2>/dev/null || true
    
    if [ -f ".env" ]; then
        cp .env "$BACKUP_DIR/env_$(date +%Y%m%d_%H%M%S).backup"
    fi
    
    print_message "$GREEN" "å¤‡ä»½å®Œæˆ: $backup_file"
}

# ä¿®å¤ç¯å¢ƒé—®é¢˜
fix_environment() {
    print_message "$GREEN" ">>> ä¿®å¤ç¯å¢ƒé—®é¢˜"
    
    print_message "$CYAN" "æ­£åœ¨è¯Šæ–­ç¯å¢ƒ..."
    
    local issues=()
    
    # æ£€æŸ¥Miniconda
    if [ ! -d "$MINICONDA_DIR" ] || ! check_command "conda"; then
        issues+=("Minicondaæœªæ­£ç¡®å®‰è£…")
    fi
    
    # æ£€æŸ¥Rust
    if ! check_command "rustc"; then
        issues+=("Rustæœªå®‰è£…")
    fi
    
    # æ£€æŸ¥Nockchain
    if [ ! -d "$NOCKCHAIN_DIR" ]; then
        issues+=("Nockchainé¡¹ç›®æœªæ‰¾åˆ°")
    fi
    
    if [ ${#issues[@]} -eq 0 ]; then
        print_message "$GREEN" "ç¯å¢ƒæ£€æŸ¥é€šè¿‡"
        return 0
    fi
    
    print_message "$YELLOW" "å‘ç°é—®é¢˜ï¼š"
    for issue in "${issues[@]}"; do
        print_message "$RED" "- $issue"
    done
    
    read -p "æ˜¯å¦è‡ªåŠ¨ä¿®å¤ï¼Ÿ(Y/n): " fix_choice
    if [[ ! "$fix_choice" =~ ^[Nn]$ ]]; then
        print_message "$CYAN" "æ­£åœ¨ä¿®å¤ç¯å¢ƒ..."
        
        # é‡æ–°é…ç½®PATH
        cat >> "$HOME/.bashrc" << 'EOF'

# Nockchainç¯å¢ƒé…ç½®
export PATH="$HOME/.miniconda3/bin:$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
export RUST_MIN_STACK=16777216
export RUST_LOG=error

# æ¿€æ´»Nockchainç¯å¢ƒå‡½æ•°
activate_nockchain() {
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    cd "$HOME/nockchain" 2>/dev/null || true
}
EOF
        
        source "$HOME/.bashrc"
        print_message "$GREEN" "ç¯å¢ƒä¿®å¤å®Œæˆ"
    fi
}

# ä¸»å¾ªç¯
main() {
    if [ "$EUID" -eq 0 ]; then
        print_message "$RED" "è¯·ä¸è¦ä»¥rootç”¨æˆ·è¿è¡Œ"
        exit 1
    fi
    
    mkdir -p "$BACKUP_DIR"
    touch "$LOG_FILE"
    log_message "æ™ºèƒ½è„šæœ¬å¯åŠ¨ v6.0"
    
    while true; do
        show_menu
        read -p "è¯·è¾“å…¥é€‰é¡¹ç¼–å·ï¼ˆ1-9ï¼‰: " choice
        
        case $choice in
            1) install_nockchain_intelligent ;;
            2) configure_mining_key ;;
            3) start_mining ;;
            4) view_logs ;;
            5) check_balance ;;
            6) system_monitor ;;
            7) backup_wallet ;;
            8) fix_environment ;;
            9)
                print_message "$GREEN" "æ„Ÿè°¢ä½¿ç”¨Nockchainæ™ºèƒ½è§£å†³æ–¹æ¡ˆï¼"
                log_message "è„šæœ¬æ­£å¸¸é€€å‡º"
                exit 0
                ;;
            *)
                print_message "$RED" "æ— æ•ˆé€‰é¡¹"
                ;;
        esac
        
        echo
        read -p "æŒ‰å›è½¦é”®ç»§ç»­..." -r
    done
}

# å¯åŠ¨ç¨‹åº
main
