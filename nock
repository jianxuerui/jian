#!/bin/bash
# -*- coding: UTF-8 -*-
# Nockchain完全无sudo权限中文优化脚本 v4.0

# 颜色定义
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RESET='\033[0m'

# 路径配置
INSTALL_PREFIX="$HOME/.local"
NOCKCHAIN_DIR="$HOME/nockchain"
LOG_FILE="$HOME/nockchain_install.log"
BACKUP_DIR="$HOME/nockchain_backup"
TOOLS_DIR="$HOME/.local/tools"

# 环境变量设置
export PATH="$INSTALL_PREFIX/bin:$HOME/.cargo/bin:$PATH"
export LD_LIBRARY_PATH="$INSTALL_PREFIX/lib:$INSTALL_PREFIX/lib64:$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$INSTALL_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH"
export C_INCLUDE_PATH="$INSTALL_PREFIX/include:$C_INCLUDE_PATH"
export CPLUS_INCLUDE_PATH="$INSTALL_PREFIX/include:$CPLUS_INCLUDE_PATH"

# 消息输出函数
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${RESET}"
}

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

check_command() {
    if command -v "$1" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# 显示主菜单
show_menu() {
    clear
    echo -e "${BLUE}
=======================================
 Nockchain 无sudo权限完整解决方案 v4.0
=======================================
${RESET}"
    echo -e "${YELLOW}1. 完整安装Nockchain（无需sudo权限）"
    echo "2. 配置挖矿公钥"
    echo "3. 启动优化挖矿"
    echo "4. 查看实时日志"
    echo "5. 检查钱包余额"
    echo "6. 系统状态监控"
    echo "7. 备份钱包密钥"
    echo "8. 环境修复工具"
    echo "9. 退出脚本"
    echo -e "${BLUE}=======================================${RESET}"
}

# 验证公钥格式
validate_pubkey() {
    local pubkey=$1
    if [[ $pubkey =~ ^[0-9a-fA-F]{128}$ ]]; then
        return 0
    elif [[ $pubkey =~ ^[1-9A-HJ-NP-Za-km-z]{40,50}$ ]]; then
        return 0
    else
        print_message "$RED" "错误：公钥格式无效"
        print_message "$YELLOW" "支持格式：128位十六进制或Base58编码"
        return 1
    fi
}

# 检查并安装Miniconda
install_miniconda() {
    print_message "$CYAN" "正在检查Miniconda环境..."
    
    if check_command "conda"; then
        print_message "$GREEN" "Miniconda已安装"
        return 0
    fi
    
    print_message "$CYAN" "正在安装Miniconda（无需sudo权限）..."
    
    # 检测系统架构
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "不支持的架构: $arch"; return 1 ;;
    esac
    
    # 下载Miniconda安装脚本
    local miniconda_installer="/tmp/miniconda_installer.sh"
    if ! wget -q --show-progress "$MINICONDA_URL" -O "$miniconda_installer"; then
        print_message "$RED" "Miniconda下载失败"
        return 1
    fi
    
    # 静默安装Miniconda到用户目录
    chmod +x "$miniconda_installer"
    if ! bash "$miniconda_installer" -b -p "$HOME/.miniconda3"; then
        print_message "$RED" "Miniconda安装失败"
        return 1
    fi
    
    # 初始化conda环境
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda config --set auto_activate_base false
    
    # 添加到PATH
    export PATH="$HOME/.miniconda3/bin:$PATH"
    
    # 清理安装文件
    rm -f "$miniconda_installer"
    
    print_message "$GREEN" "Miniconda安装完成"
    return 0
}

# 使用conda安装编译工具
install_build_tools_with_conda() {
    print_message "$CYAN" "正在创建编译环境..."
    
    # 确保conda可用
    if ! check_command "conda"; then
        print_message "$RED" "Conda环境不可用"
        return 1
    fi
    
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    
    # 创建专用的编译环境
    print_message "$CYAN" "创建nockchain编译环境..."
    conda create -n nockchain-build -y python=3.9 || {
        print_message "$YELLOW" "环境已存在，正在更新..."
    }
    
    # 激活环境
    conda activate nockchain-build
    
    # 安装编译工具
    print_message "$CYAN" "安装编译工具（这可能需要几分钟）..."
    local packages=(
        "gcc_linux-64"
        "gxx_linux-64" 
        "make"
        "cmake"
        "clang"
        "clangxx"
        "llvm-tools"
        "pkg-config"
        "openssl"
        "curl"
        "git"
        "wget"
    )
    
    for package in "${packages[@]}"; do
        print_message "$YELLOW" "安装 $package..."
        conda install -y "$package" -c conda-forge 2>/dev/null || {
            print_message "$YELLOW" "跳过 $package（可能不可用）"
        }
    done
    
    # 验证关键工具
    local tools=("gcc" "g++" "make" "clang" "git")
    local missing_tools=()
    
    for tool in "${tools[@]}"; do
        if check_command "$tool"; then
            print_message "$GREEN" "✅ $tool: $(which $tool)"
        else
            missing_tools+=("$tool")
        fi
    done
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        print_message "$YELLOW" "部分工具未安装: ${missing_tools[*]}"
        print_message "$YELLOW" "将尝试从源码编译..."
        return 1
    fi
    
    print_message "$GREEN" "编译工具安装完成"
    return 0
}

# 从源码编译必要工具
compile_tools_from_source() {
    print_message "$CYAN" "开始从源码编译编译工具..."
    
    mkdir -p "$TOOLS_DIR" "$INSTALL_PREFIX"/{bin,lib,include}
    cd "$TOOLS_DIR"
    
    # 设置编译环境变量
    export CC="gcc"
    export CXX="g++"
    export CFLAGS="-O2 -fPIC"
    export CXXFLAGS="-O2 -fPIC"
    export LDFLAGS="-L$INSTALL_PREFIX/lib"
    export CPPFLAGS="-I$INSTALL_PREFIX/include"
    
    # 如果系统完全没有编译工具，尝试下载预编译版本
    if ! check_command "gcc" && ! check_command "clang"; then
        print_message "$CYAN" "系统缺少基础编译器，尝试下载预编译版本..."
        
        # 下载最小化GCC工具链
        local gcc_url="https://github.com/steveicarus/mingw-w64-gcc/releases/download/gcc-11.2.0/gcc-11.2.0-linux-x86_64.tar.xz"
        if wget -q --timeout=30 "$gcc_url" -O gcc-minimal.tar.xz 2>/dev/null; then
            tar -xf gcc-minimal.tar.xz -C "$INSTALL_PREFIX" --strip-components=1
            export PATH="$INSTALL_PREFIX/bin:$PATH"
            rm -f gcc-minimal.tar.xz
        fi
    fi
    
    # 编译make工具（如果缺失）
    if ! check_command "make"; then
        print_message "$CYAN" "编译GNU Make..."
        wget -q https://ftp.gnu.org/gnu/make/make-4.3.tar.gz
        tar -xzf make-4.3.tar.gz
        cd make-4.3
        ./configure --prefix="$INSTALL_PREFIX" --disable-nls
        ./build.sh && ./make install
        cd ..
        rm -rf make-4.3*
    fi
    
    print_message "$GREEN" "工具编译完成"
}

# 安装Rust工具链
install_rust_toolchain() {
    print_message "$CYAN" "正在安装Rust工具链..."
    
    if check_command "rustc" && check_command "cargo"; then
        local rust_version=$(rustc --version 2>/dev/null)
        print_message "$YELLOW" "Rust已安装: $rust_version"
        export PATH="$HOME/.cargo/bin:$PATH"
        return 0
    fi
    
    # 下载并安装rustup
    print_message "$CYAN" "下载并安装Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path
    
    if [ $? -ne 0 ]; then
        print_message "$RED" "Rust安装失败"
        return 1
    fi
    
    # 设置环境变量
    source "$HOME/.cargo/env"
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 验证安装
    if check_command "rustc" && check_command "cargo"; then
        print_message "$GREEN" "Rust安装成功: $(rustc --version)"
        return 0
    else
        print_message "$RED" "Rust验证失败"
        return 1
    fi
}

# 主安装函数
install_nockchain_complete() {
    print_message "$GREEN" ">>> 开始Nockchain完整安装（无sudo权限）..."
    log_message "开始无sudo权限完整安装"
    
    # 创建必要目录
    mkdir -p "$INSTALL_PREFIX"/{bin,lib,include,share} "$NOCKCHAIN_DIR" "$BACKUP_DIR" "$TOOLS_DIR"
    
    # 步骤1：检查系统资源
    print_message "$MAGENTA" "步骤 1/6: 检查系统资源..."
    local total_ram=$(free -m 2>/dev/null | awk '/^Mem:/{print $2}' || echo "0")
    local cpu_cores=$(nproc 2>/dev/null || echo "1")
    local available_space=$(df -m ~ 2>/dev/null | awk 'NR==2{print $4}' || echo "0")
    
    print_message "$YELLOW" "系统配置："
    print_message "$YELLOW" "- 内存: ${total_ram}MB"
    print_message "$YELLOW" "- CPU核心: ${cpu_cores}"
    print_message "$YELLOW" "- 可用空间: ${available_space}MB"
    
    if [ "$total_ram" -lt 4096 ] && [ "$total_ram" -gt 0 ]; then
        print_message "$YELLOW" "警告：推荐内存至少4GB，当前${total_ram}MB"
        read -p "是否继续安装？(y/N): " continue_install
        if [[ ! "$continue_install" =~ ^[Yy]$ ]]; then
            return 1
        fi
    fi
    
    # 步骤2：安装Miniconda环境管理器
    print_message "$MAGENTA" "步骤 2/6: 安装环境管理器..."
    if ! install_miniconda; then
        print_message "$RED" "环境管理器安装失败"
        return 1
    fi
    
    # 步骤3：安装编译工具
    print_message "$MAGENTA" "步骤 3/6: 安装编译工具..."
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    
    if ! install_build_tools_with_conda; then
        print_message "$YELLOW" "Conda方式安装失败，尝试源码编译..."
        if ! compile_tools_from_source; then
            print_message "$RED" "编译工具安装失败"
            return 1
        fi
    fi
    
    # 激活编译环境
    conda activate nockchain-build 2>/dev/null || true
    
    # 步骤4：安装Rust工具链
    print_message "$MAGENTA" "步骤 4/6: 安装Rust工具链..."
    if ! install_rust_toolchain; then
        print_message "$RED" "Rust安装失败"
        return 1
    fi
    
    # 步骤5：克隆和构建Nockchain
    print_message "$MAGENTA" "步骤 5/6: 克隆Nockchain项目..."
    if [ -d "$NOCKCHAIN_DIR" ]; then
        print_message "$YELLOW" "发现现有安装，正在更新..."
        cd "$NOCKCHAIN_DIR"
        git pull origin main || {
            print_message "$YELLOW" "更新失败，重新克隆..."
            cd "$HOME"
            rm -rf "$NOCKCHAIN_DIR"
            git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR"
        }
    else
        git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR" || {
            print_message "$RED" "仓库克隆失败"
            return 1
        }
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 配置环境文件
    if [ -f ".env_example" ]; then
        cp .env_example .env
    else
        cat > .env << 'EOF'
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000
NETWORK=mainnet
MAX_PEERS=4000
LOG_LEVEL=info
RUST_LOG=info
RUST_MIN_STACK=8388608
EOF
    fi
    
    # 步骤6：编译项目
    print_message "$MAGENTA" "步骤 6/6: 编译Nockchain项目..."
    
    # 设置优化编译环境
    export RUST_MIN_STACK=8388608
    export RUST_LOG=info
    export RUST_BACKTRACE=1
    export PATH="$HOME/.cargo/bin:$INSTALL_PREFIX/bin:$PATH"
    
    # 确保在conda环境中
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda activate nockchain-build 2>/dev/null || true
    
    print_message "$CYAN" "正在安装hoonc编译器..."
    if ! make install-hoonc; then
        print_message "$RED" "hoonc编译器安装失败"
        return 1
    fi
    
    print_message "$CYAN" "正在构建Nockchain主项目..."
    if ! make build; then
        print_message "$RED" "项目构建失败"
        return 1
    fi
    
    print_message "$CYAN" "正在安装Nockchain钱包..."
    if ! make install-nockchain-wallet; then
        print_message "$RED" "钱包安装失败"
        return 1
    fi
    
    print_message "$CYAN" "正在安装Nockchain主程序..."
    if ! make install-nockchain; then
        print_message "$RED" "主程序安装失败"
        return 1
    fi
    
    # 生成钱包
    print_message "$CYAN" "正在生成钱包密钥..."
    if check_command "nockchain-wallet"; then
        local wallet_output
        wallet_output=$(nockchain-wallet keygen 2>&1)
        
        if [ $? -eq 0 ]; then
            print_message "$GREEN" "钱包生成成功！"
            print_message "$YELLOW" "钱包信息："
            echo "$wallet_output"
            
            # 提取公钥并更新.env文件
            local pubkey=$(echo "$wallet_output" | grep -E "Public key:|公钥:" | awk '{print $NF}' | head -1)
            if [ -n "$pubkey" ] && [ "$pubkey" != "0000000000000000000000000000000000000000000000000000000000000000" ]; then
                sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$pubkey/" .env
                print_message "$GREEN" "公钥已自动配置: $pubkey"
            fi
            
            # 备份钱包信息
            echo "$wallet_output" > "$BACKUP_DIR/wallet_$(date +%Y%m%d_%H%M%S).txt"
            print_message "$GREEN" "钱包信息已备份"
        else
            print_message "$YELLOW" "钱包生成可能失败，请手动生成"
        fi
    fi
    
    # 创建环境激活脚本
    cat > "$HOME/activate_nockchain.sh" << 'EOF'
#!/bin/bash
# Nockchain环境激活脚本
source "$HOME/.miniconda3/etc/profile.d/conda.sh"
conda activate nockchain-build
export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
export RUST_MIN_STACK=8388608
export RUST_LOG=info
cd "$HOME/nockchain"
echo "Nockchain环境已激活"
echo "使用 'make run-nockchain' 启动挖矿"
EOF
    chmod +x "$HOME/activate_nockchain.sh"
    
    print_message "$GREEN" "🎉 Nockchain完整安装成功！"
    print_message "$YELLOW" "安装路径: $NOCKCHAIN_DIR"
    print_message "$YELLOW" "环境激活: source ~/activate_nockchain.sh"
    print_message "$YELLOW" "备份目录: $BACKUP_DIR"
    print_message "$CYAN" "请妥善保存钱包信息！"
    
    log_message "Nockchain无sudo权限安装完成"
}

# 配置挖矿公钥
configure_mining_key() {
    print_message "$CYAN" ">>> 配置挖矿公钥"
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到.env配置文件，请先安装Nockchain"
        return 1
    fi
    
    print_message "$YELLOW" "当前公钥："
    local current_key=$(grep "MINING_PUBKEY" "$NOCKCHAIN_DIR/.env" | cut -d'=' -f2)
    print_message "$CYAN" "$current_key"
    
    echo
    read -p "请输入新的挖矿公钥（128位十六进制或Base58格式）: " new_pubkey
    
    if [ -z "$new_pubkey" ]; then
        print_message "$YELLOW" "输入为空，取消操作"
        return 0
    fi
    
    if validate_pubkey "$new_pubkey"; then
        cd "$NOCKCHAIN_DIR"
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" .env
        print_message "$GREEN" "挖矿公钥更新成功！"
        log_message "挖矿公钥已更新"
    fi
}

# 启动挖矿节点
start_mining() {
    print_message "$GREEN" ">>> 启动优化挖矿节点..."
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到Nockchain安装"
        return 1
    fi
    
    # 激活环境
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    
    cd "$NOCKCHAIN_DIR"
    
    # 检查是否已在运行
    if screen -list | grep -q "nockchain"; then
        print_message "$YELLOW" "检测到已有挖矿进程在运行"
        read -p "是否重启挖矿节点？(y/N): " restart_choice
        if [[ "$restart_choice" =~ ^[Yy]$ ]]; then
            screen -S nockchain -X quit 2>/dev/null
            sleep 2
        else
            return 0
        fi
    fi
    
    # 检查公钥配置
    local pubkey=$(grep "MINING_PUBKEY" .env | cut -d'=' -f2)
    if [ -z "$pubkey" ] || [ "$pubkey" = "0000000000000000000000000000000000000000000000000000000000000000" ]; then
        print_message "$RED" "警告：未配置有效的挖矿公钥"
        read -p "是否现在配置公钥？(Y/n): " config_key
        if [[ ! "$config_key" =~ ^[Nn]$ ]]; then
            configure_mining_key
        fi
    fi
    
    # 设置环境变量
    export RUST_MIN_STACK=8388608
    export RUST_LOG=info
    export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
    
    # 创建日志目录
    mkdir -p logs
    
    print_message "$CYAN" "正在启动挖矿节点..."
    
    # 在screen会话中启动
    screen -dmS nockchain bash -c "
        source '$HOME/.miniconda3/etc/profile.d/conda.sh' 2>/dev/null
        conda activate nockchain-build 2>/dev/null || true
        cd '$NOCKCHAIN_DIR'
        export RUST_MIN_STACK=8388608
        export RUST_LOG=info
        export PATH='$HOME/.cargo/bin:$HOME/.local/bin:$PATH'
        source .env
        echo '=== Nockchain 挖矿启动 ===' > logs/mining.log
        echo '启动时间: $(date)' >> logs/mining.log
        echo '公钥: $MINING_PUBKEY' >> logs/mining.log
        echo '环境: 无sudo权限完整版' >> logs/mining.log
        echo '==========================' >> logs/mining.log
        make run-nockchain 2>&1 | tee -a logs/mining.log
    "
    
    sleep 5
    
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "🚀 挖矿节点启动成功！"
        print_message "$YELLOW" "管理命令："
        print_message "$CYAN" "- 查看状态: screen -r nockchain"
        print_message "$CYAN" "- 退出查看: Ctrl+A, 然后按D"
        print_message "$CYAN" "- 停止挖矿: screen -S nockchain -X quit"
        print_message "$CYAN" "- 激活环境: source ~/activate_nockchain.sh"
        log_message "挖矿节点启动成功"
    else
        print_message "$RED" "挖矿节点启动失败"
        return 1
    fi
}

# 查看实时日志
view_logs() {
    print_message "$GREEN" ">>> 显示挖矿日志（按Ctrl+C退出）"
    
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        print_message "$CYAN" "正在显示实时日志..."
        tail -f "$NOCKCHAIN_DIR/logs/mining.log"
    else
        print_message "$YELLOW" "未找到日志文件，尝试连接到screen会话..."
        if screen -list | grep -q "nockchain"; then
            screen -r nockchain
        else
            print_message "$RED" "未找到运行中的挖矿进程"
        fi
    fi
}

# 检查钱包余额
check_balance() {
    print_message "$GREEN" ">>> 检查钱包余额"
    
    # 激活环境
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    
    cd "$NOCKCHAIN_DIR"
    export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
    
    local pubkey=$(grep "MINING_PUBKEY" .env | cut -d'=' -f2)
    
    if [ -z "$pubkey" ] || [ "$pubkey" = "0000000000000000000000000000000000000000000000000000000000000000" ]; then
        print_message "$RED" "错误：未配置有效的挖矿公钥"
        return 1
    fi
    
    print_message "$CYAN" "正在查询余额..."
    print_message "$YELLOW" "公钥: $pubkey"
    
    if check_command "nockchain-wallet"; then
        local socket_files=("./nockchain.sock" "./nockchain-leader.sock" "./nockchain-follower.sock")
        local balance_found=false
        
        for socket_file in "${socket_files[@]}"; do
            if [ -S "$socket_file" ]; then
                if nockchain-wallet --nockchain-socket "$socket_file" list-notes-by-pubkey -p "$pubkey" 2>/dev/null; then
                    balance_found=true
                    break
                fi
            fi
        done
        
        if [ "$balance_found" = false ]; then
            print_message "$YELLOW" "无法连接到节点，请确保挖矿节点正在运行"
        fi
    else
        print_message "$RED" "nockchain-wallet命令不可用"
    fi
}

# 系统状态监控
system_monitor() {
    print_message "$BLUE" "====== 系统状态监控 ======"
    
    # CPU和内存信息
    if check_command "top"; then
        local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 2>/dev/null || echo "N/A")
        print_message "$YELLOW" "CPU使用率: ${cpu_usage}%"
    fi
    
    if check_command "free"; then
        local mem_used=$(free -m | awk '/^Mem:/{print $3}' 2>/dev/null || echo "0")
        local mem_total=$(free -m | awk '/^Mem:/{print $2}' 2>/dev/null || echo "0")
        if [ "$mem_total" -gt 0 ]; then
            local mem_percent=$((mem_used * 100 / mem_total))
            print_message "$YELLOW" "内存使用: ${mem_used}MB / ${mem_total}MB (${mem_percent}%)"
        fi
    fi
    
    # 磁盘空间
    local disk_info=$(df -h ~ 2>/dev/null | awk 'NR==2{print $4" 可用"}' || echo "N/A")
    print_message "$YELLOW" "磁盘空间: $disk_info"
    
    # 挖矿状态
    if screen -list 2>/dev/null | grep -q "nockchain"; then
        print_message "$GREEN" "挖矿状态: ✅ 正在运行"
        if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
            print_message "$CYAN" "最近日志："
            tail -n 3 "$NOCKCHAIN_DIR/logs/mining.log" 2>/dev/null | while read -r line; do
                print_message "$YELLOW" "  $line"
            done
        fi
    else
        print_message "$RED" "挖矿状态: ❌ 未运行"
    fi
    
    # 环境状态
    print_message "$CYAN" "环境状态："
    print_message "$YELLOW" "- Conda: $(which conda 2>/dev/null || echo '未安装')"
    print_message "$YELLOW" "- Rust: $(which rustc 2>/dev/null || echo '未安装')"
    print_message "$YELLOW" "- 编译器: $(which gcc 2>/dev/null || which clang 2>/dev/null || echo '未安装')"
}

# 备份钱包密钥
backup_wallet() {
    print_message "$GREEN" ">>> 备份钱包密钥"
    
    # 激活环境
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    
    cd "$NOCKCHAIN_DIR"
    export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
    
    local backup_file="$BACKUP_DIR/complete_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    print_message "$CYAN" "正在创建完整备份..."
    
    # 创建备份目录
    local temp_backup="/tmp/nockchain_backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$temp_backup"
    
    # 备份配置文件
    if [ -f ".env" ]; then
        cp .env "$temp_backup/"
    fi
    
    # 备份钱包文件
    if check_command "nockchain-wallet"; then
        nockchain-wallet export-keys --output "$temp_backup/keys.export" 2>/dev/null || {
            print_message "$YELLOW" "钱包密钥导出失败，跳过"
        }
    fi
    
    # 备份已有的钱包信息
    cp -r "$BACKUP_DIR"/*.txt "$temp_backup/" 2>/dev/null || true
    
    # 备份环境信息
    cat > "$temp_backup/environment_info.txt" << EOF
# Nockchain环境信息备份
备份时间: $(date)
系统信息: $(uname -a)
Conda环境: $(conda info --base 2>/dev/null || echo "未安装")
Rust版本: $(rustc --version 2>/dev/null || echo "未安装")
PATH: $PATH
安装目录: $NOCKCHAIN_DIR
EOF
    
    # 创建压缩包
    tar -czf "$backup_file" -C "/tmp" "$(basename "$temp_backup")"
    
    # 清理临时文件
    rm -rf "$temp_backup"
    
    print_message "$GREEN" "完整备份创建成功！"
    print_message "$YELLOW" "备份文件: $backup_file"
    print_message "$CYAN" "请妥善保存此备份文件"
    
    log_message "完整备份已创建: $backup_file"
}

# 环境修复工具
fix_environment() {
    print_message "$GREEN" ">>> 环境修复工具"
    
    print_message "$CYAN" "正在检查环境状态..."
    
    # 检查关键组件
    local issues=()
    
    if ! check_command "conda"; then
        issues+=("Miniconda未安装或未配置")
    fi
    
    if ! check_command "rustc"; then
        issues+=("Rust未安装或未配置")
    fi
    
    if ! check_command "gcc" && ! check_command "clang"; then
        issues+=("编译器未安装")
    fi
    
    if [ ! -d "$NOCKCHAIN_DIR" ]; then
        issues+=("Nockchain目录不存在")
    fi
    
    if [ ${#issues[@]} -eq 0 ]; then
        print_message "$GREEN" "环境检查通过，无需修复"
        return 0
    fi
    
    print_message "$YELLOW" "发现以下问题："
    for issue in "${issues[@]}"; do
        print_message "$RED" "- $issue"
    done
    
    read -p "是否自动修复这些问题？(Y/n): " fix_choice
    if [[ "$fix_choice" =~ ^[Nn]$ ]]; then
        return 0
    fi
    
    # 修复环境配置
    print_message "$CYAN" "正在修复环境..."
    
    # 重新配置PATH
    cat >> "$HOME/.bashrc" << 'EOF'

# Nockchain环境配置
export PATH="$HOME/.miniconda3/bin:$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
export LD_LIBRARY_PATH="$HOME/.local/lib:$HOME/.local/lib64:$LD_LIBRARY_PATH"

# 自动激活Nockchain环境函数
activate_nockchain() {
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    cd "$HOME/nockchain" 2>/dev/null || true
    export RUST_MIN_STACK=8388608
    export RUST_LOG=info
}
EOF
    
    # 重新加载环境
    source "$HOME/.bashrc"
    
    print_message "$GREEN" "环境修复完成"
    print_message "$YELLOW" "请运行: source ~/.bashrc"
    print_message "$YELLOW" "或重新登录以应用更改"
}

# 主循环
main() {
    # 检查root权限
    if [ "$EUID" -eq 0 ]; then
        print_message "$RED" "请不要以root用户运行此脚本"
        exit 1
    fi
    
    # 创建必要目录
    mkdir -p "$BACKUP_DIR" "$TOOLS_DIR"
    touch "$LOG_FILE"
    log_message "无sudo权限脚本启动 v4.0"
    
    while true; do
        show_menu
        read -p "请输入选项编号（1-9）: " choice
        
        case $choice in
            1) install_nockchain_complete ;;
            2) configure_mining_key ;;
            3) start_mining ;;
            4) view_logs ;;
            5) check_balance ;;
            6) system_monitor ;;
            7) backup_wallet ;;
            8) fix_environment ;;
            9)
                print_message "$GREEN" "感谢使用Nockchain无sudo权限解决方案！"
                log_message "脚本正常退出"
                exit 0
                ;;
            *)
                print_message "$RED" "无效选项，请输入1-9"
                ;;
        esac
        
        echo
        read -p "按回车键继续..." -r
    done
}

# 启动主程序
main
