#!/bin/bash

# ========= 色彩定义 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= 项目路径 =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= 横幅 =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain 安装助手 / Setup Tool"
  echo "==============================================="
  echo -e "${RESET}"
  echo "-----------------------------------------------"
  echo ""
  echo "✨ 优化挖矿: 配置线程利用, 推荐使用 Systemd 实现自动启动/重启 ✨"
  echo ""
}

# ========= 常用函数 =========

# 切换到项目目录
function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || { echo -e "${RED}[-] 无法切换到项目目录: $NCK_DIR${RESET}"; exit 1; }
  else
    echo -e "${RED}[-] 项目目录不存在: $NCK_DIR${RESET}"
    exit 1
  fi
}

# 检查并确认 MINING_PUBKEY 是否已设置
function check_pubkey() {
  echo -e "[*] 检查 MINING_PUBKEY 配置..."
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] 错误：.env 文件不存在: $ENV_FILE。请使用选项 1 安装或选项 3 设置。${RESET}"
    return 1 # Indicate failure
  fi

  local temp_pubkey=$(grep "^MINING_PUBKEY=" "$ENV_FILE" | cut -d= -f2)
  if [ -z "$temp_pubkey" ]; then
     echo -e "${RED}[-] 错误：.env 文件中 MINING_PUBKEY 未设置或为空。请使用选项 3 设置。${RESET}"
     return 1 # Indicate failure
  fi
  echo -e "${GREEN}[+] MINING_PUBKEY 已设置: ${temp_pubkey}${RESET}"
  return 0 # Indicate success
}

# 暂停并返回菜单
function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

# 安全执行命令并捕获输出进行检查
# 参数: $@ - 要执行的命令
# 参数: $1_DESCRIPTION - 命令的描述 (用于日志)
function safe_execute() {
    local command="$@"
    local description="$1" # Use the first argument as description
    local log_file=$(mktemp) # 创建一个临时文件

    echo -e "[*] 正在执行: ${description}..."
    echo "命令: $command" # Output the command being run

    # 执行命令，将 stdout 和 stderr 都重定向到临时文件
    if ! $command &> "$log_file"; then
        echo -e "${RED}[-] ${description} 失败!${RESET}"
        echo -e "${RED}--- 错误日志开始 (最近 100 行) ---${RESET}"
        tail -n 100 "$log_file" # 显示临时文件的最后 100 行
        echo -e "${RED}--- 错误日志结束 ---${RESET}"
        echo -e "${YELLOW}[!] 请查看上面的错误信息以诊断问题。${RESET}"
        echo -e "${YELLOW}[!] 常见的编译/安装失败原因包括：内存不足、磁盘空间不足、依赖缺失、网络问题或代码本身的问题。${RESET}"
        rm "$log_file" # 清理临时文件
        return 1 # 返回失败状态
    else
        echo -e "${GREEN}[+] ${description} 完成。${RESET}"
        rm "$log_file" # 清理临时文件
        return 0 # 返回成功状态
    fi
}


# ========= 主功能函数 =========

# 1) 一键安装并构建
function setup_all() {
  echo -e "${BLUE}[*] 开始一键安装并构建...${RESET}"

  echo -e "[*] 安装系统依赖..."
  # Adding common build dependencies just in case
  safe_execute "sudo apt update" "更新 apt 仓库" || { pause_and_return; return; }
  safe_execute "sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen" "安装系统依赖" || { pause_and_return; return; }
  echo -e "${GREEN}[+] 系统依赖安装完成${RESET}"

  echo -e "[*] 安装 Rust..."
  if ! command -v cargo &>/dev/null; then
    # Use -y for non-interactive installation
    safe_execute "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y" "安装 Rust" || { pause_and_return; return; }
    # Source env immediately for the current script session
    source "$HOME/.cargo/env"
    # Add sourcing to shell profile if not present
    RC_FILE="$HOME/.bashrc"
    [[ "$SHELL" == *"zsh"* ]] && RC_FILE="$HOME/.zshrc"
    if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$RC_FILE"; then
      echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$RC_FILE"
    fi
  else
      echo -e "${YELLOW}[*] Rust 已安装，跳过安装步骤。${RESET}"
      # Ensure path is updated for the current session even if already installed
      source "$HOME/.cargo/env"
  fi
  echo -e "${GREEN}[+] Rust 安装/配置完成${RESET}"


  echo -e "[*] 获取或更新仓库..."
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] 项目目录已存在，进行 git pull..."
    cd_nck_dir # Go to directory first
    safe_execute "git pull" "更新仓库" || { pause_and_return; return; }
  else
    echo -e "[*] 克隆项目仓库..."
    safe_execute "git clone https://github.com/zorp-corp/nockchain '$NCK_DIR'" "克隆仓库" || { pause_and_return; return; }
    cd_nck_dir # Go to directory after cloning
  fi
  echo -e "${GREEN}[+] 仓库获取完成${RESET}"

  echo -e "[*] 设置 .env 文件..."
  if [ ! -f "$ENV_FILE" ]; then
    safe_execute "cp .env_example '$ENV_FILE'" "创建 .env 文件" || { pause_and_return; return; }
    echo -e "${GREEN}[+] .env 文件创建完成${RESET}"
  else
    echo -e "${YELLOW}[*] .env 文件已存在，跳过创建。${RESET}"
  fi

  # --- 编译和安装步骤 (使用 safe_execute 封装) ---

  # Make sure we are in the correct directory for make commands
  cd_nck_dir

  safe_execute "make install-hoonc" "安装 hoonc" || { pause_and_return; return; }

  safe_execute "make build" "编译 Nockchain" || { pause_and_return; return; }

  safe_execute "make install-nockchain-wallet" "安装钱包" || { pause_and_return; return; }

  safe_execute "make install-nockchain" "安装节点可执行文件" || { pause_and_return; return; }

  # --- 编译和安装步骤结束 ---


  echo -e "${GREEN}[+] 一键安装并构建完成${RESET}"
  echo -e "${YELLOW}[!] 接下来请务必执行以下步骤以进行挖矿优化和启动:"
  echo -e "${YELLOW}    1. 生成钱包 (选项 2)"
  echo -e "${YELLOW}    2. 将生成的公钥设置到 .env 文件 (选项 3)"
  echo -e "${YELLOW}    3. 配置挖矿启动脚本以优化线程利用 (选项 8) - 强烈推荐!"
  echo -e "${YELLOW}    4. 配置 Systemd 服务实现自动启动/重启 (选项 9) - 强烈推荐!"
  echo -e "${YELLOW}    5. 启动 Systemd 服务: ${BOLD}sudo systemctl start nockchain-miner${RESET}${YELLOW}"
  echo -e "${YELLOW}    (或使用选项 6/7 使用 Screen 方式，但 Systemd 更稳定持久)${RESET}"

  pause_and_return
}

# 2) 生成钱包
function generate_wallet() {
  echo -e "${BLUE}[*] 生成钱包...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] 钱包可执行文件不存在。请先执行安装选项 1。${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] 正在生成钱包密钥对...请记录下公钥！${RESET}"
  # Using safe_execute for wallet command output capture too
  safe_execute "./target/release/nockchain-wallet keygen" "生成钱包密钥" || { pause_and_return; return; }

  echo -e "${YELLOW}[!] 钱包生成完成。请手动将上面输出的公钥复制，并使用选项 3 将其写入 .env 文件中的 MINING_PUBKEY=${RESET}"
  pause_and_return
}

# 3) 设置 MINING_PUBKEY 到 .env
function set_pubkey_env() {
  echo -e "${BLUE}[*] 设置 MINING_PUBKEY 到 .env...${RESET}"
  # No need to cd_nck_dir here, using full path for ENV_FILE

  if [ ! -f "$ENV_FILE" ]; then
      echo -e "${RED}[-] .env 文件不存在: $ENV_FILE。请先执行安装选项 1。${RESET}"
      pause_and_return
      return
  fi

  read -p "请输入您要挖矿的公钥 (MINING_PUBKEY): " pubkey
  if [ -z "$pubkey" ]; then
    echo -e "${RED}[-] 公钥不能为空。${RESET}"
    pause_and_return
    return
  fi

  # Use awk safely update or add MINING_PUBKEY
  # If line exists, replace it; otherwise, append to the end
  awk -v pubkey="$pubkey" '
    /^MINING_PUBKEY=/ { $0="MINING_PUBKEY="pubkey; found=1 }
    { print }
    END { if (!found) print "MINING_PUBKEY="pubkey }
  ' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"

  echo -e "${GREEN}[+] 已将 MINING_PUBKEY=${pubkey} 写入 ${ENV_FILE}${RESET}"
  pause_and_return
}

# 4) 导出钱包密钥
function export_keys() {
  echo -e "${BLUE}[*] 导出钱包密钥...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] 钱包可执行文件不存在。请先执行安装选项 1。${RESET}"
      pause_and_return
      return
  fi

  safe_execute "./target/release/nockchain-wallet export-keys" "导出钱包密钥" || { pause_and_return; return; }

  echo -e "${GREEN}[+] 密钥已导出到 keys.export${RESET}"
  echo -e "${YELLOW}[!] 请妥善保管 keys.export 文件！${RESET}"
  pause_and_return
}

# 5) 导入钱包密钥
function import_keys() {
  echo -e "${BLUE}[*] 导入钱包密钥...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] 钱包可执行文件不存在。请先执行安装选项 1。${RESET}"
      pause_and_return
      return
  fi

  read -p "[?] 请输入密钥文件路径 (默认: ./keys.export): " keyfile
  keyfile=${keyfile:-"./keys.export"}

  if [ ! -f "$keyfile" ]; then
      echo -e "${RED}[-] 密钥文件不存在: $keyfile${RESET}"
      pause_and_return
      return
  fi

  safe_execute "./target/release/nockchain-wallet import-keys --input '$keyfile'" "导入钱包密钥" || { pause_and_return; return; }

  echo -e "${GREEN}[+] 密钥已导入${RESET}"
  pause_and_return
}

# 8) 配置挖矿启动脚本 (优化线程利用)
function configure_miner_script() {
  echo -e "${BLUE}[*] 配置挖矿启动脚本以优化线程利用...${RESET}"
  cd_nck_dir

  MINER_SCRIPT="$NCK_DIR/scripts/run_nockchain_miner.sh"
  BACKUP_SCRIPT="$MINER_SCRIPT.bak_$(date +%Y%m%d%H%M%S)"

  if [ ! -f "$MINER_SCRIPT" ]; then
    echo -e "${RED}[-] 挖矿启动脚本模板不存在: $MINER_SCRIPT${RESET}"
    echo "请先执行安装选项 1。"
    pause_and_return
    return
  fi

  echo -e "[*] 备份原有脚本到 $BACKUP_SCRIPT"
  cp "$MINER_SCRIPT" "$BACKUP_SCRIPT" || { echo -e "${RED}[-] 备份脚本失败${RESET}"; pause_and_return; return; }

  # --- 创建新的脚本内容 ---
  # 假设 nockchain 可执行文件支持 --threads 参数。请根据实际情况验证或修改。
  NUM_CORES=$(nproc) # 获取CPU核心数
  # 也可以选择保留一个核心给系统，例如: NUM_CORES=$(( $(nproc) - 1 ))
  # 确保至少使用一个核心
  if [ "$NUM_CORES" -le 0 ]; then
      NUM_CORES=1
  fi

  echo -e "[*] 创建新的 $MINER_SCRIPT 内容，将使用 ${NUM_CORES} 个线程..."
  # 使用 heredoc 来方便地写入多行脚本内容
  # Use single quotes around EOL to prevent immediate variable expansion by the outer script
  cat << 'EOL' > "$MINER_SCRIPT"
#!/bin/bash
# This script was configured by the setup tool to use multiple CPU threads for mining.

# Define the NCK_DIR path explicitly as this script might be run by systemd
# and the user's HOME might not be the standard one.
# It's better to source the .env using its full path relative to NCK_DIR.
# Attempt to get NCK_DIR from the script's own path
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
NCK_DIR="$(dirname "$SCRIPT_DIR")"
ENV_FILE="$NCK_DIR/.env"

# Source .env file if it exists, needed for MINING_PUBKEY and other potential env vars
if [ -f "$ENV_FILE" ]; then
  source "$ENV_FILE"
fi

# Check if MINING_PUBKEY is set and not empty
if [ -z "$MINING_PUBKEY" ]; then
  echo "错误: MINING_PUBKEY 未在 $ENV_FILE 中设置或为空。"
  echo "请使用 setup 脚本的选项 3 设置公钥后再启动矿机。"
  exit 1
fi

# Get number of CPU cores - This value is hardcoded during script creation by the setup tool
# Setup tool calculated: $(nproc)
NUM_CORES=<NUM_CORES_PLACEHOLDER> # Placeholder for the number of cores calculated by the setup script

echo "启动 Nockchain Miner..."
echo "项目目录: $NCK_DIR"
echo "使用公钥: $MINING_PUBKEY"
echo "使用线程数: $NUM_CORES"
echo "挖矿日志将输出到标准输出/标准错误 (如果使用 Systemd 或 Screen 管理，请查看对应日志)."

# Execute the miner with optimized parameters
# IMPORTANT: Verify './target/release/nockchain' supports --threads parameter!
# Use exec to replace the current shell process with the miner process
exec "$NCK_DIR"/target/release/nockchain \
    --chain nockchain_mainnet \
    --miner \
    --mining-pubkey "$MINING_PUBKEY" \
    --threads "$NUM_CORES" # <-- Pass the calculated threads argument

# Note: 'exec' replaces the current shell process. Commands after it are not run
# unless the executed program fails immediately. If exec fails, the script exits.
EOL
          # --- 替换核心数占位符 ---
          # Now we replace the placeholder with the actual calculated value.
          # Using a temporary file for sed in-place editing to be safer
          sed "s/<NUM_CORES_PLACEHOLDER>/$NUM_CORES/" "$MINER_SCRIPT" > "$MINER_SCRIPT.tmp" && mv "$MINER_SCRIPT.tmp" "$MINER_SCRIPT"

          # --- 结束创建新的脚本内容 ---

          chmod +x "$MINER_SCRIPT" || { echo -e "${RED}[-] 设置脚本执行权限失败${RESET}"; pause_and_return; return; }

          echo -e "${GREEN}[+] 挖矿启动脚本已配置完成 ($MINER_SCRIPT)。${RESET}"
          echo -e "${YELLOW}[!] 重要: 此配置假设 Nockchain 节点程序支持 '--threads' 参数。请验证！${RESET}"
          echo -e "${YELLOW}[!] 您现在可以使用选项 6 (Screen) 或选项 9 (Systemd) 启动矿机。${RESET}"
          pause_and_return
        }


# 9) 配置 Systemd 服务
function setup_systemd_miner() {
  echo -e "${BLUE}[*] 配置 Systemd 服务 (推荐用于自动启动和重启)...${RESET}"
  # No need to cd_nck_dir here, using full paths

  # 检查 root 权限
  if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}[-] 错误: 配置 Systemd 服务需要 root 权限。请使用 ${BOLD}sudo $0${RESET}${RED} 运行此脚本或切换到 root 用户再执行此选项。${RESET}"
    pause_and_return
    return
  fi

  echo -e "${YELLOW}[!] 建议您在配置 Systemd 服务前，先使用选项 8 配置挖矿启动脚本以优化线程利用。${RESET}"
  echo -e "${YELLOW}[!] 并且确保已使用选项 3 设置了 MINING_PUBKEY。${RESET}"
  read -p "是否继续配置 Systemd 服务? (y/n): " confirm_systemd
  if [[ ! "$confirm_systemd" =~ ^[Yy]$ ]]; then
     echo -e "${RED}[-] 已取消 Systemd 配置。${RESET}"
     pause_and_return
     return
  fi

  SERVICE_FILE="/etc/systemd/system/nockchain-miner.service"
  USERNAME=$(whoami -u) # 获取执行脚本的用户的实际用户名

  # Check if the miner script exists, as Systemd will call it
   if [ ! -f "$NCK_DIR/scripts/run_nockchain_miner.sh" ]; then
      echo -e "${RED}[-] 错误: 挖矿启动脚本不存在 '$NCK_DIR/scripts/run_nockchain_miner.sh'${RESET}"
      echo "请先执行安装选项 1 和 8。"
      pause_and_return
      return
   fi

  # --- 创建 Systemd 服务文件内容 ---
  echo -e "[*] 创建 Systemd 服务文件: $SERVICE_FILE"
  # 使用 heredoc 写入服务文件内容
  cat <<EOL | safe_execute "tee '$SERVICE_FILE'" "写入 Systemd 服务文件" || { pause_and_return; return; }
[Unit]
Description=Nockchain Miner Node
After=network.target

[Service]
User=$USERNAME # 以当前用户身份运行
WorkingDirectory=$NCK_DIR # 工作目录为项目根目录
EnvironmentFile=$ENV_FILE # 从 .env 文件加载环境变量 (例如 MINING_PUBKEY)
# Note: The run_nockchain_miner.sh script should handle sourcing the env file internally
ExecStart=$NCK_DIR/scripts/run_nockchain_miner.sh # 执行配置好的挖矿启动脚本
Restart=always # 关键: 程序退出时自动重启
RestartSec=10 # 10秒后尝试重启

# 推荐的文件描述符和进程数限制，避免资源耗尽
LimitNOFILE=65536
LimitNPROC=65536

# 将日志输出到 journald
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOL
  # --- 结束服务文件内容 ---

  echo -e "[*] 重载 Systemd 管理器配置..."
  safe_execute "systemctl daemon-reload" "重载 Systemd" || { pause_and_return; return; }

  echo -e "[*] 启用 nockchain-miner 服务 (设置开机自启)..."
  safe_execute "systemctl enable nockchain-miner.service" "启用 Systemd 服务" || { pause_and_return; return; }

  echo -e "${GREEN}[+] Systemd 服务已配置 ($SERVICE_FILE) 并设为开机自启。${RESET}"
  echo -e "${YELLOW}[!] 您可以使用以下命令管理服务:${RESET}"
  echo -e "${YELLOW}    启动矿机: ${BOLD}sudo systemctl start nockchain-miner${RESET}"
  echo -e "${YELLOW}    检查状态: ${BOLD}sudo systemctl status nockchain-miner${RESET}"
  echo -e "${YELLOW}    查看日志: ${BOLD}sudo journalctl -u nockchain-miner -f${RESET}"
  echo -e "${YELLOW}    停止矿机: ${BOLD}sudo systemctl stop nockchain-miner${RESET}"
  echo -e "${YELLOW}    禁用开机自启: ${BOLD}sudo systemctl disable nockchain-miner${RESET}"

  pause_and_return
}


# 6) 启动节点 (Screen 后台)
function start_node_screen() {
  echo -e "${BLUE}[*] 启动节点 (screen 后台运行)...${RESET}"
  cd_nck_dir

  # 检查 MINING_PUBKEY 是否已设置
  if ! check_pubkey; then
    pause_and_return
    return # 如果检查失败则退出函数
  fi

  # 确保启动脚本存在并有执行权限
  local MINER_SCRIPT="$NCK_DIR/scripts/run_nockchain_miner.sh"
  if [ ! -f "$MINER_SCRIPT" ]; then
      echo -e "${RED}[-] 错误: 挖矿启动脚本不存在: $MINER_SCRIPT${RESET}"
      echo "请先执行安装选项 1。"
      pause_and_return
      return
  fi
  # Ensure executable permission is set
  chmod +x "$MINER_SCRIPT"

  # 检查旧的 screen 会话并关闭
  if screen -list | grep -qw "nockchain"; then
    echo "[*] 检测到旧的 'nockchain' screen 会话，正在关闭..."
    screen -S nockchain -X quit
    sleep 2 # 等待旧会话终止
    # Re-check if it's really gone
    if screen -list | grep -qw "nockchain"; then
        echo -e "${RED}[-] 无法关闭旧的 'nockchain' screen 会话。请手动关闭: ${BOLD}screen -S nockchain -X quit${RESET}"
        pause_and_return
        return
    fi
  fi

  echo -e "[*] 正在启动新的 'nockchain' screen 会话..."
  # Use screen -dmS to create a detached session and execute the script.
  # The script itself (run_nockchain_miner.sh) should handle cd and sourcing .env now.
  # Using safe_execute to launch the screen command itself, though errors here are less about the miner failing internally.
  safe_execute "screen -dmS nockchain '$MINER_SCRIPT'" "启动 screen 会话" || {
      echo -e "${RED}[-] Screen 会话启动命令失败。请检查是否安装了 screen (apt install screen)。${RESET}"
      pause_and_return
      return
  }


  sleep 3 # 等待片刻以检查会话是否启动
  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] 节点已成功启动在 'nockchain' screen 会话中。${RESET}"
    echo -e "${YELLOW}[!] 您可以使用选项 7 查看日志。${RESET}"
    echo -e "${YELLOW}[!] 注意: Screen 方式不如 Systemd (选项 9) 稳定和持久，不具备自动重启功能。${RESET}"
  else
    echo -e "${RED}[-] 节点启动失败。请尝试使用选项 7 查看日志（如果 screen 会话短暂启动后退出）。${RESET}"
    echo "请检查 $MINER_SCRIPT 脚本内容、权限或依赖是否正确。"
    echo "查看 screen 自身错误: less /var/log/syslog (或 journalctl -f) 可能会有关于 screen 启动失败的信息."
  fi
  pause_and_return
}

# 7) 查看 Screen 节点日志
function view_logs_screen() {
  echo -e "${BLUE}[*] 查看 Screen 节点日志...${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] 连接到 'nockchain' screen 会话。按 Ctrl+A+D 组合键可分离会话返回脚本菜单，不会停止矿机。${RESET}"
    # screen -d -r can detach a session elsewhere and reattach here
    screen -d -r nockchain
    # User detached from screen session, they return here
    echo -e "${GREEN}[+] 已从 screen 会话分离。${RESET}"
  else
    echo -e "${RED}[-] 未找到名为 'nockchain' 的 screen 会话。请确认节点已使用选项 6 启动。${RESET}"
  fi
  pause_and_return
}


# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo "  1) 一键安装并构建 (系统依赖, Rust, 代码, bin)"
  echo "-----------------------------------------------"
  echo "  2) 生成钱包 (查看输出日志)"
  echo "  3) 设置 MINING_PUBKEY 到 .env (手动输入)"
  echo "  4) 导出钱包密钥"
  echo "  5) 导入钱包密钥"
  echo "-----------------------------------------------"
  echo "  8) 配置挖矿启动脚本 (优化线程利用, 推荐!)"
  echo "  9) 配置 Systemd 服务 (推荐! 实现自动启动/重启)"
  echo "-----------------------------------------------"
  echo "  6) 启动节点 (Screen 后台运行, 基本方式)"
  echo "  7) 查看 Screen 节点日志"
  echo "-----------------------------------------------"
  echo "  0) 退出"
  echo ""
  read -p "请输入编号: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node_screen ;; # Screen 方式
    7) view_logs_screen ;;  # Screen 日志
    8) configure_miner_script ;; # 配置启动脚本
    9) setup_systemd_miner ;; # Systemd 方式
    0) echo -e "${GREEN}退出脚本.${RESET}"; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# ========= 脚本入口 =========
# 确保当前用户有sudo权限执行需要sudo的命令
# Systemd 配置和 apt 安装需要 root/sudo 权限，已在函数内部检查或通过 sudo 执行。
# 其他操作以当前用户身份执行。

# 运行主菜单
main_menu
