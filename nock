#!/bin/bash
# ==============================================================================
# Nockchain 挖矿助手 (K2 增强融合版 v8.2.1 - 智能引导版/修复版)
# ==============================================================================
# 作者: K2 节点教程分享 (AI 终极离线内核版)
#
# v8.2.1 更新日志:
# - [修复] 修正了在 install_all 函数中因特殊字符导致 su 子进程执行失败的严重错误。
#   通过使用 Base64 编码安全地传递内核数据，确保了脚本的稳定性和兼容性。
#
# v8.2 更新日志:
# - [智能引导] 新增自动权限提升功能！如果未使用 root 运行，脚本将自动尝试以 sudo 方式重新启动。
# - [智能引导] 新增 Bash 解释器检查，防止用户错误地使用 sh 运行脚本导致兼容性问题。
# - [优化] 移除了旧的 check_root 函数，将其功能整合到启动引导逻辑中。
#
# --- 如何正确运行此脚本 ---
# 1. 保存文件: 将此代码保存为例如 `nock.sh`。
# 2. 给予权限 (只需一次): 在终端中运行 `chmod +x nock.sh`
# 3. 直接运行: 在终端中运行 `./nock.sh`
#    脚本会自动处理权限问题，让您更省心！
# ==============================================================================

# --- 智能引导与权限检查 ---
# 1. 检查是否使用 bash 解释器运行
if [ -z "$BASH_VERSION" ]; then
    echo -e "\033[0;31m[错误] 此脚本必须使用 'bash' 解释器运行，而不是 'sh'。\033[0m"
    echo -e "\033[1;33m请使用以下命令运行: \033[0;32mbash $0\033[0m"
    exit 1
fi

# 2. 检查并自动获取 Root 权限
if [ "$(id -u)" -ne 0 ]; then
    echo -e "\033[1;33m[提示] 此脚本需要 Root 权限来安装依赖和管理服务。\033[0m"
    echo -e "\033[0;36m正在尝试使用 'sudo' 自动提权...\033[0m"
    # 使用 sudo 重新执行脚本本身，并传递所有参数
    sudo bash "$0" "$@"
    # 提权后，原始的非 root 进程必须退出
    exit $?
fi
# --- 引导结束，后续代码将以 Root 权限运行 ---

set -e

# --- 全局配置 ---
MINER_USERNAME="miner"
MINER_HOME="/home/${MINER_USERNAME}"
NCK_DIR="${MINER_HOME}/nockchain"
ENV_FILE="${NCK_DIR}/.env"
SERVICE_NAME="nockchain-miner"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"

# --- 颜色定义 ---
if [ -t 1 ]; then
    RESET='\033[0m'; BOLD='\033[1m'; GREEN='\033[0;32m'; BLUE='\033[0;34m';
    YELLOW='\033[1;33m'; RED='\033[0;31m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'
else
    RESET=''; BOLD=''; GREEN=''; BLUE=''; YELLOW=''; RED=''; PURPLE=''; CYAN=''
fi

# --- 内核数据 ---
read -r -d '' HOON_KERNEL_CONTENT <<'EOF'
::
/+  sys/hoon
++  ride  |%
          --
++  ver
  |%
  ++  ost
    |%
    ++  arvo  0vI.need
    ++  vere  ~
    --
  ++  kelvin  (as-co:co /(~ . 400))
  ++  send  =>((mote ovum) (give:ost ovum))
  ++  give
    |=  a=ovum
    ~|  [! a]
    !!
  ++  kiln
    |%
    ++  sins  |=(a=ovum (send:ost a))
    ++  fard  |=(a=ovum (send:ost a))
    --
  ++  hoon-version   139
  --
EOF

# ==============================================================================
# === 助手函数 (兼容性核心) ===
# ==============================================================================

# 在脚本启动时检测系统信息
function detect_system_info() {
    # 检测操作系统信息
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_ID=${ID,,} # 转为小写
    else
        OS_ID=$(uname -s | tr '[:upper:]' '[:lower:]')
        echo -e "${YELLOW}警告: 无法找到 /etc/os-release 文件，兼容性可能受限。${RESET}"
    fi

    # 检测包管理器并设置相应命令和包名
    if command -v apt-get &>/dev/null; then
        export PKG_MANAGER="apt"
        export UPDATE_CMD="apt-get update -y"
        export INSTALL_CMD="apt-get install -y"
        export DEP_PACKAGES="clang llvm libclang-dev pkg-config libssl-dev build-essential cmake git make curl dos2unix base-files"
    elif command -v dnf &>/dev/null; then
        export PKG_MANAGER="dnf"
        export UPDATE_CMD="dnf check-update"
        export INSTALL_CMD="dnf install -y"
        export DEP_PACKAGES="clang llvm-devel libclang-devel pkgconfig openssl-devel cmake git make curl dos2unix"
        export GROUP_INSTALL_CMD="dnf groupinstall -y 'Development Tools'"
    elif command -v yum &>/dev/null; then
        export PKG_MANAGER="yum"
        export UPDATE_CMD="yum check-update"
        export INSTALL_CMD="yum install -y"
        export DEP_PACKAGES="clang llvm-devel libclang-devel pkgconfig openssl-devel cmake git make curl dos2unix"
        export GROUP_INSTALL_CMD="yum groupinstall -y 'Development Tools'"
    elif command -v pacman &>/dev/null; then
        export PKG_MANAGER="pacman"
        export UPDATE_CMD="pacman -Sy"
        export INSTALL_CMD="pacman -S --noconfirm --needed"
        export DEP_PACKAGES="clang llvm libclang pkg-config openssl cmake git make curl dos2unix base-devel"
    elif command -v zypper &>/dev/null; then
        export PKG_MANAGER="zypper"
        export UPDATE_CMD="zypper refresh"
        export INSTALL_CMD="zypper install -y"
        export DEP_PACKAGES="clang llvm-devel libclang-devel pkg-config libopenssl-devel cmake git make curl dos2unix patterns-devel-base-devel_basis"
    else
        export PKG_MANAGER="unsupported"
    fi

    # 检测 sudoers 组
    if [[ "$OS_ID" == "ubuntu" || "$OS_ID" == "debian" ]]; then
        export SUDO_GROUP="sudo"
    else
        export SUDO_GROUP="wheel" # RHEL, CentOS, Fedora, Arch, SUSE 等的通用默认值
    fi
}

# 显示横幅
function show_banner() {
    clear
    echo -e "${BOLD}${BLUE}======================================================${RESET}"
    echo -e "${BOLD}${BLUE} Nockchain 挖矿助手 (K2 增强融合版 v8.2.1)${RESET}"
    echo -e "${BOLD}${BLUE}======================================================${RESET}"
    echo -e "✨ ${BOLD}${PURPLE}内核增强: 使用内置 v139 内核！${RESET}"
    echo -e "⚙️ ${BOLD}${GREEN}运行模式: 智能引导版 (已自动获取 Root 权限)${RESET}"
    if id "${MINER_USERNAME}" &>/dev/null; then
        echo -e "👤 ${GREEN}专用用户 '${MINER_USERNAME}' 已创建。${RESET}"
    else
        echo -e "👤 ${YELLOW}专用用户 '${MINER_USERNAME}' 待创建。${RESET}"
    fi
    echo "📌 作者: K2 节点教程分享"
    echo "------------------------------------------------------"
    echo ""
}

# 获取CPU核心数 (增强版)
function get_num_cores() {
    nproc 2>/dev/null || grep -c '^processor' /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4
}

function pause_and_return() { echo ""; read -r -p "按任意键返回主菜单..." -s -n 1; echo; }
function check_systemd() { if [ -d /run/systemd/system ]; then echo "true"; else echo "false"; fi; }

# ==============================================================================
# === 核心功能函数 (注意：已移除 check_root 调用) ===
# ==============================================================================

function install_all() {
    show_banner
    echo -e "${YELLOW}[*] 开始全新安装 Nockchain...${RESET}"

    # --- 步骤 1: 准备专用用户 ---
    echo -e "${BLUE}--- 步骤 1/5: 准备专用用户 '${MINER_USERNAME}' ---${RESET}"
    if id "${MINER_USERNAME}" &>/dev/null; then
        echo -e "${YELLOW}[!] 检测到旧用户 '${MINER_USERNAME}'，正在清理...${RESET}"
        if systemctl is-active --quiet "$SERVICE_NAME" &>/dev/null; then
            systemctl stop "$SERVICE_NAME"; systemctl disable "$SERVICE_NAME"; rm -f "$SERVICE_FILE"; systemctl daemon-reload
        fi
        killall -u "${MINER_USERNAME}" 2>/dev/null || true
        userdel -r "${MINER_USERNAME}" 2>/dev/null || true
        echo -e "${GREEN}[+] 旧用户及相关服务已清理。${RESET}"
    fi
    
    echo -e "${CYAN}正在创建新用户 '${MINER_USERNAME}'...${RESET}"
    if [[ "$OS_ID" == "debian" || "$OS_ID" == "ubuntu" ]] && command -v adduser &>/dev/null; then
        adduser --disabled-password --gecos "" "${MINER_USERNAME}"
    else
        useradd -m -s /bin/bash "${MINER_USERNAME}"
    fi
    usermod -aG "${SUDO_GROUP}" "${MINER_USERNAME}"
    echo -e "${GREEN}[✓] 用户创建成功并已配置 sudo 权限！${RESET}"

    # --- 步骤 2: 安装系统依赖 (以 root 身份) ---
    echo -e "${BLUE}--- 步骤 2/5: 安装系统依赖 ---${RESET}"
    if [ "$PKG_MANAGER" == "unsupported" ]; then
        echo -e "${RED}错误: 未能识别您的包管理器。${RESET}"
        echo -e "${YELLOW}请手动安装以下或类似的依赖包: clang, llvm, libclang, pkg-config, openssl-devel, build-essential, cmake, git, make, curl, dos2unix${RESET}"
        exit 1
    fi
    echo -e "${CYAN}检测到包管理器: ${BOLD}${PKG_MANAGER}${RESET}"
    echo -e "${CYAN}正在更新包列表... (这可能需要一些时间)${RESET}"; eval "$UPDATE_CMD" >/dev/null 2>&1
    echo -e "${CYAN}正在安装核心依赖...${RESET}"; eval "$INSTALL_CMD $DEP_PACKAGES"
    if [ -n "$GROUP_INSTALL_CMD" ]; then
        echo -e "${CYAN}正在安装开发工具集...${RESET}"; eval "$GROUP_INSTALL_CMD"
    fi
    echo -e "${GREEN}[✓] 系统依赖安装完成。${RESET}"

    # --- 步骤 3 & 4: 克隆、编译 (切换到 miner 用户执行) ---
    echo -e "${BLUE}--- 步骤 3/5: 安装 Rust (以 '${MINER_USERNAME}' 用户身份) ---${RESET}"
    echo -e "${BLUE}--- 步骤 4/5: 克隆和编译 Nockchain (以 '${MINER_USERNAME}' 用户身份) ---${RESET}"
    echo -e "${YELLOW}这部分将自动执行，请耐心等待编译完成...${RESET}"
    
    # 【修复】将复杂的内核内容编码为安全的 Base64 字符串，以避免在 su 子进程中因特殊字符导致命令失败
    local b64_kernel
    b64_kernel=$(echo -n "$HOON_KERNEL_CONTENT" | base64)

    su - "${MINER_USERNAME}" -c bash <<EOF
    set -euo pipefail
    
    echo "--- [${MINER_USERNAME}] 正在安装 Rust... ---"
    if ! command -v cargo &>/dev/null; then
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    fi
    source "\$HOME/.cargo/env"
    
    NCK_DIR_SUB="\$HOME/nockchain"
    rm -rf "\$NCK_DIR_SUB"
    
    echo "--- [${MINER_USERNAME}] 正在克隆仓库... ---"
    git clone https://github.com/zorp-corp/nockchain "\$NCK_DIR_SUB"
    cd "\$NCK_DIR_SUB"
    
    echo "--- [${MINER_USERNAME}] 正在注入增强版内核... ---"
    # 【修复】从 Base64 解码并写入文件，确保数据完整性
    echo "$b64_kernel" | base64 -d > "\$NCK_DIR_SUB/pkg/sys/hoon"
    
    echo "--- [${MINER_USERNAME}] 正在编译，这将花费几分钟时间... ---"
    cargo build --release -p hoonc
    mkdir -p assets
    "\$NCK_DIR_SUB/target/release/hoonc" pkg/miner.hoon > assets/miner.jam
    "\$NCK_DIR_SUB/target/release/hoonc" pkg/dumb.hoon > assets/dumb.jam
    "\$NCK_DIR_SUB/target/release/hoonc" pkg/wal.hoon > assets/wal.jam
    
    export RUSTFLAGS="-C target-cpu=native -C opt-level=3"
    export CARGO_PROFILE_RELEASE_LTO="true"
    NUM_CORES=\$(nproc 2>/dev/null || grep -c '^processor' /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)
    cargo build --release --workspace --exclude hoonc -j"\$NUM_CORES"
    
    cp "\$NCK_DIR_SUB/target/release/nockchain" "\$HOME/.cargo/bin/"
    echo "--- [${MINER_USERNAME}] 编译成功！ ---"
EOF

    local exit_code=$?
    if [ "$exit_code" -ne 0 ]; then
        echo -e "\n${RED}安装失败！请检查上面的错误信息。${RESET}"
    else
        echo -e "\n${GREEN}[✓] Nockchain 安装成功！${RESET}"
        echo -e "${YELLOW}--- 步骤 5/5: 完成 ---${RESET}"
        echo -e "${CYAN}接下来，请使用菜单选项 '2' 来设置您的挖矿公钥。${RESET}"
    fi
    pause_and_return
}

function set_pubkey() {
    show_banner
    if [ ! -d "$NCK_DIR" ]; then
        echo -e "${RED}错误: Nockchain 尚未安装。请先选择 '1' 进行安装。${RESET}"; pause_and_return; return
    fi
    local pubkey; read -r -p "请输入您的128位挖矿公钥: " pubkey
    if ! [[ "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
        echo -e "\n${RED}错误: 公钥格式无效。${RESET}"; pause_and_return; return
    fi
    touch "$ENV_FILE"; chown "${MINER_USERNAME}:${MINER_USERNAME}" "$ENV_FILE"
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE"; sed -i '/^MINER_THREADS=/d' "$ENV_FILE"
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    echo "MINER_THREADS=$(get_num_cores)" >> "$ENV_FILE"
    echo -e "\n${GREEN}[✓] 配置已成功保存！${RESET}"; pause_and_return
}

function start_node() {
    show_banner
    if [[ "$(check_systemd)" != "true" ]]; then
        echo -e "${RED}错误: 系统不支持 Systemd。${RESET}"; pause_and_return; return
    fi
    if [ ! -f "$ENV_FILE" ] || ! grep -q "MINING_PUBKEY" "$ENV_FILE"; then
        echo -e "${RED}错误: 尚未设置公钥。${RESET}"; pause_and_return; return
    fi
    echo -e "${YELLOW}[*] 正在创建并启动 systemd 服务...${RESET}"
    cat <<EOF > "$SERVICE_FILE"
[Unit]
Description=$SERVICE_NAME service
After=network-online.target
[Service]
User=${MINER_USERNAME}
Group=$(id -gn "${MINER_USERNAME}")
WorkingDirectory=${NCK_DIR}
EnvironmentFile=${ENV_FILE}
ExecStart=${MINER_HOME}/.cargo/bin/nockchain
Restart=on-failure; RestartSec=10; LimitNOFILE=65536; Nice=-5
[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload; systemctl enable "$SERVICE_NAME"; systemctl restart "$SERVICE_NAME"
    echo -e "\n${GREEN}[✓] 服务 '${SERVICE_NAME}' 已启动并设为开机自启！${RESET}"; pause_and_return
}

function stop_node() {
    show_banner
    if ! systemctl list-units --full -all | grep -q "${SERVICE_NAME}.service"; then
        echo -e "${YELLOW}提示: 服务未安装，无需停止。${RESET}"; pause_and_return; return
    fi
    echo -e "${YELLOW}[*] 正在停止 systemd 服务...${RESET}"; systemctl stop "$SERVICE_NAME"
    echo -e "\n${GREEN}[✓] 服务 '${SERVICE_NAME}' 已停止。${RESET}"; pause_and_return
}

function view_logs() {
    show_banner
    if ! systemctl list-units --full -all | grep -q "${SERVICE_NAME}.service"; then
        echo -e "${YELLOW}提示: 服务未安装，无法查看日志。${RESET}"; pause_and_return; return
    fi
    echo -e "${YELLOW}正在显示实时日志... 按 Ctrl+C 退出日志并返回菜单。${RESET}"
    echo "------------------------------------------------------"
    journalctl -u "$SERVICE_NAME" -f --no-pager; pause_and_return
}

# ==============================================================================
# === 主菜单和循环 ===
# ==============================================================================

function main_menu() {
    show_banner
    echo -e "${BOLD}${GREEN}--- 主菜单 ---${RESET}"; echo "请选择要执行的操作:"; echo ""
    echo -e "  ${CYAN}1)${RESET} 全新安装 Nockchain (会清空旧数据)"
    echo -e "  ${CYAN}2)${RESET} 设置/更新挖矿公钥"
    echo ""
    if [[ "$(check_systemd)" == "true" ]]; then
        if systemctl is-active --quiet "$SERVICE_NAME" &>/dev/null; then SERVICE_STATUS="${GREEN}(运行中)${RESET}"; else SERVICE_STATUS="${RED}(已停止)${RESET}"; fi
        echo -e "  ${CYAN}3)${RESET} ${BOLD}启动${RESET}挖矿服务 ${SERVICE_STATUS}"
        echo -e "  ${CYAN}4)${RESET} ${BOLD}停止${RESET}挖矿服务"
        echo -e "  ${CYAN}5)${RESET} 查看实时日志"
    else
        echo -e "  ${RED}3-5) (不可用) 您的系统不支持 Systemd${RESET}"
    fi
    echo ""; echo -e "  ${YELLOW}0) 退出脚本${RESET}"; echo ""
    read -r -p "请输入选项编号: " choice
    case "$choice" in
        1) install_all ;; 2) set_pubkey ;; 3) start_node ;; 4) stop_node ;; 5) view_logs ;;
        0) echo -e "${BLUE}感谢使用！再见。${RESET}"; exit 0 ;;
        *) echo -e "${RED}无效选项，请重新输入。${RESET}"; sleep 1 ;;
    esac
}

# --- 脚本入口 ---
# 权限检查已在顶部完成，这里直接启动核心逻辑
detect_system_info
while true; do main_menu; done
