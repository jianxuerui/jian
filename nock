#!/bin/bash

# ========= Nockchain 构建失败终极修复版脚本 v16.0 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'

NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$HOME/nockchain_build.log"
HOONC_LOG="$HOME/nockchain_hoonc.log"
NODE_LOG="$HOME/nockchain_node.log"

function show_banner() {
  clear
  echo -e "${BOLD}${CYAN}"
  echo "=========================================================="
  echo "   Nockchain 构建失败终极修复版脚本 v16.0"
  echo "=========================================================="
  echo -e "${RESET}"
  echo "🎯 针对问题: 主项目构建失败，mem.rs错误，内存不足"
  echo "🔧 核心修复: 内存优化 + 分离构建 + 错误恢复"
  echo "💾 内存管理: 智能swap配置，支持低至2GB内存"
  echo "🛠️ 构建策略: 单线程 + 分步骤 + 多重备选方案"
  echo "🚀 成功率: 基于社区经验，大幅提升构建成功率"
  echo "----------------------------------------------------------"
  echo ""
}

# ========= 检测并修复系统时间偏差问题 =========
function fix_clock_skew() {
  echo -e "[*] 检测并修复时钟偏差问题..."
  
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    
    # 检查是否存在时钟偏差警告的文件[3]
    if find . -name "*.rs" -newer Makefile 2>/dev/null | head -1; then
      echo -e "${YELLOW}[!] 检测到可能的时钟偏差问题${RESET}"
      echo -e "[*] 更新所有文件时间戳..."
      
      # 更新所有文件的时间戳到当前系统时间[3]
      find ./ -type f | xargs touch 2>/dev/null || true
      sync
      
      echo -e "${GREEN}[+] 文件时间戳已更新${RESET}"
    fi
  fi
}

# ========= 强化内存和系统优化 =========
function optimize_system_ultimate() {
  echo -e "[*] 终极系统优化（解决mem.rs错误）..."
  
  total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  total_mem_gb=$((total_mem_kb / 1024 / 1024))
  
  echo -e "${BLUE}[i] 系统内存: ${total_mem_gb}GB${RESET}"
  
  # 基于社区反馈，mem.rs错误主要是内存不足[4][5]
  if [ $total_mem_gb -lt 4 ]; then
    echo -e "${RED}[-] 严重警告: 内存不足可能导致mem.rs panic！${RESET}"
    echo -e "${YELLOW}[!] 2GB内存的VPS经常遇到thread panic错误${RESET}"
    
    # 配置超大swap来补偿内存不足
    required_swap=$((32 - total_mem_gb))  # 最大32GB swap
    echo -e "[*] 配置${required_swap}GB超大swap来解决内存问题..."
    
    # 清理旧swap
    sudo swapoff /swapfile-nockchain-ultimate 2>/dev/null || true
    sudo rm -f /swapfile-nockchain-ultimate
    
    # 创建新的超大swap
    if sudo fallocate -l ${required_swap}G /swapfile-nockchain-ultimate 2>/dev/null; then
      sudo chmod 600 /swapfile-nockchain-ultimate
      sudo mkswap /swapfile-nockchain-ultimate >/dev/null 2>&1
      sudo swapon /swapfile-nockchain-ultimate >/dev/null 2>&1
      echo -e "${GREEN}[+] ${required_swap}GB 超大Swap配置成功${RESET}"
    else
      echo -e "[*] 使用dd方法创建swap..."
      sudo dd if=/dev/zero of=/swapfile-nockchain-ultimate bs=1G count=$required_swap status=progress 2>/dev/null
      sudo chmod 600 /swapfile-nockchain-ultimate
      sudo mkswap /swapfile-nockchain-ultimate >/dev/null 2>&1
      sudo swapon /swapfile-nockchain-ultimate >/dev/null 2>&1
      echo -e "${GREEN}[+] ${required_swap}GB Swap创建成功${RESET}"
    fi
    
    # 添加到fstab
    if ! grep -q "/swapfile-nockchain-ultimate" /etc/fstab; then
      echo '/swapfile-nockchain-ultimate none swap sw 0 0' | sudo tee -a /etc/fstab >/dev/null
    fi
  fi
  
  # 强化内存过量使用设置（社区推荐）[2]
  sudo sysctl -w vm.overcommit_memory=1 >/dev/null 2>&1 || true
  sudo sysctl -w vm.max_map_count=2097152 >/dev/null 2>&1 || true
  sudo sysctl -w vm.dirty_ratio=3 >/dev/null 2>&1 || true
  sudo sysctl -w vm.swappiness=80 >/dev/null 2>&1 || true  # 积极使用swap
  sudo sysctl -w vm.vfs_cache_pressure=200 >/dev/null 2>&1 || true
  sudo sysctl -w vm.dirty_background_ratio=1 >/dev/null 2>&1 || true
  
  # 内存压缩优化
  echo 1 | sudo tee /sys/module/zswap/parameters/enabled >/dev/null 2>&1 || true
  
  # 显示内存状态
  echo -e "${BLUE}[i] 优化后内存状态:${RESET}"
  free -h
  
  echo -e "${GREEN}[+] 终极系统优化完成${RESET}"
}

# ========= 安装完整依赖（解决clang/llvm问题） =========
function install_ultimate_dependencies() {
  echo -e "[*] 安装终极构建依赖（解决clang/llvm问题）..."
  
  # 更新系统
  sudo apt-get update -y && sudo apt-get upgrade -y
  
  # 安装完整的构建依赖[2][4]
  sudo apt install -y \
    curl iptables build-essential git wget lz4 jq make gcc nano \
    automake autoconf tmux htop nvme-cli libgbm1 pkg-config \
    libssl-dev libleveldb-dev tar clang bsdmainutils ncdu unzip \
    libleveldb-dev libclang-dev llvm-dev \
    clang-12 clang-13 clang-14 llvm-12 llvm-13 llvm-14 \
    llvm-12-dev llvm-13-dev llvm-14-dev \
    libclang-12-dev libclang-13-dev libclang-14-dev \
    cmake ninja-build autotools-dev libtool \
    python3 python3-dev python3-pip \
    libffi-dev zlib1g-dev libbz2-dev \
    libreadline-dev libsqlite3-dev libncurses5-dev \
    xz-utils tk-dev libgdbm-dev liblzma-dev uuid-dev \
    screen strace gdb valgrind \
    libc6-dev linux-headers-$(uname -r) \
    lld-12 lld-13 lld-14 || true
  
  # 设置clang版本链接（多版本支持）
  if command -v clang-14 >/dev/null 2>&1; then
    sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-14 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/llvm-config llvm-config /usr/bin/llvm-config-14 100 2>/dev/null || true
    export LIBCLANG_PATH=/usr/lib/llvm-14/lib
    export LLVM_CONFIG_PATH=/usr/bin/llvm-config-14
  elif command -v clang-13 >/dev/null 2>&1; then
    sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-13 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-13 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/llvm-config llvm-config /usr/bin/llvm-config-13 100 2>/dev/null || true
    export LIBCLANG_PATH=/usr/lib/llvm-13/lib
    export LLVM_CONFIG_PATH=/usr/bin/llvm-config-13
  elif command -v clang-12 >/dev/null 2>&1; then
    sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-12 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-12 100 2>/dev/null || true
    sudo update-alternatives --install /usr/bin/llvm-config llvm-config /usr/bin/llvm-config-12 100 2>/dev/null || true
    export LIBCLANG_PATH=/usr/lib/llvm-12/lib
    export LLVM_CONFIG_PATH=/usr/bin/llvm-config-12
  fi
  
  # 验证关键依赖
  echo -e "${BLUE}[i] 验证关键依赖:${RESET}"
  for tool in gcc g++ clang llvm-config make cmake pkg-config git; do
    if command -v "$tool" >/dev/null 2>&1; then
      echo -e "${GREEN}  ✓ $tool${RESET}"
    else
      echo -e "${RED}  ✗ $tool${RESET}"
      return 1
    fi
  done
  
  echo -e "${GREEN}[+] 终极依赖安装完成${RESET}"
}

# ========= 配置终极Rust环境 =========
function setup_rust_ultimate() {
  echo -e "[*] 配置终极Rust环境（防止构建失败）..."
  
  # 清理可能存在的锁定
  pkill -f cargo 2>/dev/null || true
  pkill -f rustc 2>/dev/null || true
  sleep 5
  
  # 安装或更新Rust[2][4]
  if ! command -v rustc >/dev/null 2>&1; then
    echo -e "[*] 安装Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
    source "$HOME/.cargo/env"
  else
    echo -e "[*] 更新Rust..."
    source "$HOME/.cargo/env"
    rustup update stable 2>/dev/null || true
  fi
  
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 终极Cargo配置（防止内存问题和构建失败）
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1
rustc-wrapper = "sccache"

[net]
retry = 100
timeout = 3600
git-fetch-with-cli = true
offline = false

[env]
CC = "clang"
CXX = "clang++"

[profile.release]
opt-level = 1
debug = false
debug-assertions = false
overflow-checks = false
lto = "off"
panic = "abort"
incremental = false
codegen-units = 1
strip = true

[profile.dev]
opt-level = 0
debug = false
debug-assertions = false
overflow-checks = false
incremental = false
codegen-units = 1
strip = true

[target.x86_64-unknown-linux-gnu]
linker = "clang"
rustflags = ["-C", "link-arg=-fuse-ld=lld"]
EOF
  
  # 安装sccache来加速编译
  if ! command -v sccache >/dev/null 2>&1; then
    cargo install sccache --locked 2>/dev/null || true
  fi
  
  # 设置sccache
  export SCCACHE_CACHE_SIZE="10G"
  export RUSTC_WRAPPER=sccache
  
  echo -e "${GREEN}[+] 终极Rust环境配置完成${RESET}"
  echo -e "${GREEN}[+] Rust: $(rustc --version)${RESET}"
  echo -e "${GREEN}[+] Cargo: $(cargo --version)${RESET}"
}

# ========= 项目准备和清理 =========
function prepare_project_ultimate() {
  echo -e "[*] 终极项目准备..."
  
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] 发现现有项目，进行深度清理..."
    cd "$NCK_DIR"
    
    # 停止所有相关进程
    pkill -f nockchain 2>/dev/null || true
    pkill -f cargo 2>/dev/null || true
    screen -XS nockchain quit 2>/dev/null || true
    
    # 深度清理构建文件
    cargo clean >/dev/null 2>&1 || true
    rm -rf target/ 2>/dev/null || true
    rm -rf ~/.cargo/registry/cache/ 2>/dev/null || true
    rm -rf ~/.cargo/git/ 2>/dev/null || true
    
    # 清理socket文件（解决Address already in use错误）[5]
    find . -name "*.sock" -delete 2>/dev/null || true
    rm -rf .socket/ 2>/dev/null || true
    
    # 修复时钟偏差问题[3]
    fix_clock_skew
    
    echo -e "${GREEN}[+] 现有项目清理完成${RESET}"
  else
    echo -e "[*] 克隆新项目..."
    cd "$HOME"
    
    if [ -d "nockchain" ]; then
      rm -rf nockchain
    fi
    
    git clone --depth 1 https://github.com/zorp-corp/nockchain.git || {
      echo -e "${RED}[-] 项目克隆失败${RESET}"
      return 1
    }
    
    cd nockchain
    echo -e "${GREEN}[+] 项目克隆成功${RESET}"
  fi
  
  # 准备环境文件
  if [ -f ".env_example" ]; then
    cp .env_example .env
  else
    cat > .env << 'EOF'
MINING_PUBKEY=
RUST_LOG=info
EOF
  fi
  
  # 创建必要目录
  mkdir -p assets .socket test-leader logs
  chmod 755 .socket test-leader
  
  # 创建必要的资产文件
  touch assets/wal.jam assets/dumb.jam assets/miner.jam 2>/dev/null || true
  
  echo -e "${GREEN}[+] 项目准备完成${RESET}"
}

# ========= 终极分步骤构建（解决主项目构建失败） =========
function build_ultimate_step_by_step() {
  echo -e "[*] 终极分步骤构建（解决主项目构建失败）..."
  
  cd "$NCK_DIR" || return 1
  
  # 设置终极构建环境
  source "$HOME/.cargo/env"
  export PATH="$HOME/.cargo/bin:$PATH"
  export CC=clang
  export CXX=clang++
  export CARGO_BUILD_JOBS=1
  export RUST_BACKTRACE=1
  export RUSTFLAGS="-C opt-level=1 -C debuginfo=0 -C panic=abort -C target-cpu=native"
  
  # 设置LLVM路径
  if [ -n "$LIBCLANG_PATH" ]; then
    export LIBCLANG_PATH="$LIBCLANG_PATH"
  fi
  if [ -n "$LLVM_CONFIG_PATH" ]; then
    export LLVM_CONFIG_PATH="$LLVM_CONFIG_PATH"
  fi
  
  echo -e "[*] 构建环境设置完成"
  echo -e "${BLUE}[i] CC: $CC, CXX: $CXX${RESET}"
  echo -e "${BLUE}[i] CARGO_BUILD_JOBS: $CARGO_BUILD_JOBS${RESET}"
  
  build_success=0
  total_components=3
  
  # === 步骤1: 构建hoonc编译器 ===
  echo -e "${BLUE}[i] === 步骤1/3: 构建hoonc编译器 ===${RESET}"
  
  for attempt in 1 2 3; do
    echo -e "[*] hoonc构建尝试 $attempt/3..."
    
    if timeout 7200 make install-hoonc >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] hoonc构建成功${RESET}"
      ((build_success++))
      break
    else
      echo -e "${YELLOW}[!] hoonc构建尝试 $attempt 失败${RESET}"
      
      if [ $attempt -eq 3 ]; then
        echo -e "[*] 尝试手动构建hoonc..."
        if timeout 7200 cargo build --bin hoonc --release --verbose >>"$LOG_FILE" 2>&1; then
          mkdir -p "$HOME/.cargo/bin"
          cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null || true
          chmod +x "$HOME/.cargo/bin/hoonc"
          echo -e "${GREEN}[+] hoonc手动构建成功${RESET}"
          ((build_success++))
        else
          echo -e "${RED}[-] hoonc构建完全失败${RESET}"
        fi
      else
        # 清理后重试
        cargo clean >/dev/null 2>&1 || true
        sync && sudo sysctl -w vm.drop_caches=3 >/dev/null 2>&1 || true
        sleep 30
      fi
    fi
  done
  
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # === 步骤2: 构建主项目（关键步骤） ===
  echo -e "${BLUE}[i] === 步骤2/3: 构建主项目（关键步骤） ===${RESET}"
  
  # 方法1: 使用make build
  for attempt in 1 2 3 4 5; do
    echo -e "[*] 主项目构建尝试 $attempt/5..."
    
    # 每次尝试前清理内存
    sync && sudo sysctl -w vm.drop_caches=1 >/dev/null 2>&1 || true
    
    # 设置更严格的内存限制
    ulimit -v $((1024*1024*16)) 2>/dev/null || true  # 16GB虚拟内存限制
    
    if timeout 9000 make build >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] 主项目构建成功！${RESET}"
      build_main_success=true
      break
    else
      echo -e "${YELLOW}[!] 主项目构建尝试 $attempt 失败${RESET}"
      
      if [ $attempt -lt 5 ]; then
        echo -e "[*] 深度清理后重试..."
        cargo clean >/dev/null 2>&1 || true
        rm -rf target/ 2>/dev/null || true
        
        # 强制内存回收
        sync
        sudo sysctl -w vm.drop_caches=3 >/dev/null 2>&1 || true
        
        # 等待更长时间让系统恢复
        sleep 60
      fi
    fi
  done
  
  # 方法2: 如果make build失败，尝试分别构建每个组件
  if [ -z "$build_main_success" ]; then
    echo -e "${YELLOW}[!] make build失败，尝试分别构建组件...${RESET}"
    
    for component in "nockchain-wallet" "nockchain"; do
      echo -e "[*] 单独构建 $component..."
      
      for attempt in 1 2 3; do
        # 内存清理
        sync && sudo sysctl -w vm.drop_caches=1 >/dev/null 2>&1 || true
        
        if timeout 7200 cargo build --bin "$component" --release --verbose >>"$LOG_FILE" 2>&1; then
          echo -e "${GREEN}[+] $component 单独构建成功${RESET}"
          
          # 安装到bin目录
          mkdir -p "$HOME/.cargo/bin"
          if [ -f "target/release/$component" ]; then
            cp "target/release/$component" "$HOME/.cargo/bin/"
            chmod +x "$HOME/.cargo/bin/$component"
          fi
          break
        else
          echo -e "${YELLOW}[!] $component 构建尝试 $attempt 失败${RESET}"
          if [ $attempt -lt 3 ]; then
            cargo clean >/dev/null 2>&1 || true
            sleep 30
          fi
        fi
      done
    done
  fi
  
  # === 步骤3: 安装组件 ===
  echo -e "${BLUE}[i] === 步骤3/3: 安装组件 ===${RESET}"
  
  # 安装钱包
  if timeout 3600 make install-nockchain-wallet >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] nockchain-wallet安装成功${RESET}"
    ((build_success++))
  else
    echo -e "${YELLOW}[!] nockchain-wallet安装失败，检查二进制文件...${RESET}"
    if [ -f "target/release/nockchain-wallet" ]; then
      mkdir -p "$HOME/.cargo/bin"
      cp target/release/nockchain-wallet "$HOME/.cargo/bin/"
      chmod +x "$HOME/.cargo/bin/nockchain-wallet"
      echo -e "${GREEN}[+] nockchain-wallet手动安装成功${RESET}"
      ((build_success++))
    fi
  fi
  
  # 安装节点
  if timeout 3600 make install-nockchain >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] nockchain安装成功${RESET}"
    ((build_success++))
  else
    echo -e "${YELLOW}[!] nockchain安装失败，检查二进制文件...${RESET}"
    if [ -f "target/release/nockchain" ]; then
      mkdir -p "$HOME/.cargo/bin"
      cp target/release/nockchain "$HOME/.cargo/bin/"
      chmod +x "$HOME/.cargo/bin/nockchain"
      echo -e "${GREEN}[+] nockchain手动安装成功${RESET}"
      ((build_success++))
    fi
  fi
  
  # === 最终验证 ===
  echo -e "[*] === 最终构建结果验证 ==="
  component_count=0
  
  for binary in "hoonc" "nockchain-wallet" "nockchain"; do
    if command -v "$binary" >/dev/null 2>&1; then
      binary_path=$(command -v "$binary")
      binary_size=$(du -h "$binary_path" 2>/dev/null | cut -f1 || echo "unknown")
      echo -e "${GREEN}  ✓ $binary: $binary_path (大小: $binary_size)${RESET}"
      ((component_count++))
    else
      echo -e "${RED}  ✗ $binary: 未找到${RESET}"
    fi
  done
  
  echo -e "${BLUE}[i] 构建成功: $component_count/$total_components 个组件${RESET}"
  
  if [ $component_count -eq $total_components ]; then
    echo -e "${GREEN}[+] ✅ 所有组件构建成功！${RESET}"
    return 0
  elif [ $component_count -ge 2 ]; then
    echo -e "${YELLOW}[!] 大部分组件构建成功${RESET}"
    return 0
  else
    echo -e "${RED}[-] 构建失败，请查看日志: $LOG_FILE${RESET}"
    return 1
  fi
}

# ========= 主安装流程 =========
function complete_installation_ultimate() {
  echo -e "[*] 开始Nockchain终极安装流程（解决构建失败）..."
  
  echo "=== Nockchain构建失败终极修复版安装日志 $(date) ===" > "$LOG_FILE"
  
  echo -e "${BLUE}[i] 步骤1/6: 修复时钟偏差...${RESET}"
  fix_clock_skew
  
  echo -e "${BLUE}[i] 步骤2/6: 终极系统优化...${RESET}"
  optimize_system_ultimate
  
  echo -e "${BLUE}[i] 步骤3/6: 安装终极依赖...${RESET}"
  if ! install_ultimate_dependencies; then
    echo -e "${RED}[-] 依赖安装失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤4/6: 配置终极Rust环境...${RESET}"
  if ! setup_rust_ultimate; then
    echo -e "${RED}[-] Rust环境配置失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤5/6: 终极项目准备...${RESET}"
  if ! prepare_project_ultimate; then
    echo -e "${RED}[-] 项目准备失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤6/6: 终极分步骤构建...${RESET}"
  if build_ultimate_step_by_step; then
    echo -e "${GREEN}[+] ✅ Nockchain终极安装成功！${RESET}"
    echo -e "${GREEN}[+] 🎉 主项目构建失败问题已解决！${RESET}"
    echo -e "${BLUE}[i] 下一步: 生成钱包和设置挖矿公钥${RESET}"
  else
    echo -e "${YELLOW}[!] 安装部分成功，某些组件可能需要手动处理${RESET}"
  fi
  
  echo -e "${BLUE}[i] 详细日志: $LOG_FILE${RESET}"
  pause_and_return
}

# ========= 钱包和节点管理（保持原有功能） =========
function generate_wallet_enhanced() {
  echo -e "[*] 生成钱包..."
  
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"
  
  if command -v nockchain-wallet >/dev/null 2>&1; then
    echo -e "${GREEN}[+] 使用钱包程序: nockchain-wallet${RESET}"
    nockchain-wallet keygen[2]
  else
    echo -e "${RED}[-] 未找到nockchain-wallet程序${RESET}"
  fi
  
  pause_and_return
}

function set_mining_pubkey_enhanced() {
  echo -e "[*] 设置挖矿公钥..."
  
  cd "$NCK_DIR" || return
  
  read -p "请输入完整的挖矿公钥: " pubkey
  
  if [ ${#pubkey} -eq 128 ] && [[ "$pubkey" =~ ^[0-9a-f]{128}$ ]]; then
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || true
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    echo -e "${GREEN}[+] 公钥已成功写入.env文件${RESET}"[2]
  else
    echo -e "${RED}[-] 公钥格式错误，需要128位16进制${RESET}"
  fi
  
  pause_and_return
}

function start_node_enhanced() {
  echo -e "[*] 启动节点..."
  
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"
  
  if [ ! -f "$ENV_FILE" ] || [ -z "$(grep MINING_PUBKEY "$ENV_FILE" | cut -d'=' -f2)" ]; then
    echo -e "${RED}[-] 请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"
  
  # 清理socket文件（解决Address already in use错误）[5]
  pkill -f nockchain 2>/dev/null || true
  screen -XS nockchain quit 2>/dev/null || true
  find . -name "*.sock" -delete 2>/dev/null || true
  mkdir -p .socket test-leader
  
  # 启用内存过量使用[2]
  sudo sysctl -w vm.overcommit_memory=1 >/dev/null 2>&1 || true
  
  # 构建启动命令[2]
  start_cmd="RUST_LOG=info nockchain --mining-pubkey $MINING_PUBKEY \
--mine \
--peer /ip4/95.216.102.60/udp/3006/quic-v1 \
--peer /ip4/65.109.156.108/udp/3006/quic-v1 \
--peer /ip4/65.21.67.175/udp/3006/quic-v1 \
--peer /ip4/65.109.156.172/udp/3006/quic-v1 \
--peer /ip4/34.174.22.166/udp/3006/quic-v1 \
--npc-socket .socket/nockchain.sock \
--bind /ip4/0.0.0.0/udp/3006/quic-v1"
  
  if command -v screen >/dev/null 2>&1; then
    screen -dmS nockchain bash -c "cd '$NCK_DIR' && $start_cmd"
    sleep 3
    
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] ✅ 节点启动成功！${RESET}"
      echo -e "${BLUE}[i] 查看日志: screen -r nockchain${RESET}"
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
    fi
  fi
  
  pause_and_return
}

function check_status_enhanced() {
  echo -e "[*] 检查系统状态..."
  
  echo -e "${BLUE}[i] 组件状态:${RESET}"
  for binary in "hoonc" "nockchain-wallet" "nockchain"; do
    if command -v "$binary" >/dev/null 2>&1; then
      echo -e "  ✓ $binary: 已安装"
    else
      echo -e "  ✗ $binary: 未找到"
    fi
  done
  
  echo -e "${BLUE}[i] 节点状态:${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "  ✓ 节点运行中"
  else
    echo -e "  ✗ 节点未运行"
  fi
  
  echo -e "${BLUE}[i] 内存状态:${RESET}"
  free -h
  
  pause_and_return
}

function view_logs() {
  if screen -list | grep -qw "nockchain"; then
    screen -r nockchain
  elif [ -f "$LOG_FILE" ]; then
    tail -f "$LOG_FILE"
  fi
  pause_and_return
}

function stop_services() {
  echo -e "[*] 停止所有服务..."
  pkill -f nockchain 2>/dev/null || true
  screen -XS nockchain quit 2>/dev/null || true
  echo -e "${GREEN}[+] 服务已停止${RESET}"
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo ""
  echo "🚀 安装和构建:"
  echo "  1) 🎯 终极完整安装 (解决主项目构建失败)"
  echo ""
  echo "🔑 钱包管理:"
  echo "  2) 🔑 生成钱包"
  echo "  3) 📝 设置挖矿公钥"
  echo ""
  echo "⚡ 节点管理:"
  echo "  4) ⚡ 启动节点"
  echo "  5) 📊 查看日志"
  echo "  6) ⏹️  停止服务"
  echo ""
  echo "🔍 状态检查:"
  echo "  7) 🔍 检查状态"
  echo ""
  echo "  0) 退出脚本"
  echo ""
  echo -e "${CYAN}🎯 专门解决: 主项目构建失败，mem.rs错误，内存不足${RESET}"
  echo -e "${CYAN}💡 适用环境: 2GB+ 内存的 VPS，自动配置大容量swap${RESET}"
  echo ""
  read -p "请输入编号 (0-7): " choice

  case "$choice" in
    1) complete_installation_ultimate ;;
    2) generate_wallet_enhanced ;;
    3) set_mining_pubkey_enhanced ;;
    4) start_node_enhanced ;;
    5) view_logs ;;
    6) stop_services ;;
    7) check_status_enhanced ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# 检查权限
if [ "$EUID" -eq 0 ]; then
  echo -e "${RED}[-] 请不要以root用户运行此脚本${RESET}"
  exit 1
fi

# 启动主菜单
main_menu
