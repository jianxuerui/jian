#!/bin/bash

# ========= 色彩定义 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= 项目路径 =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= 环境变量设置 =========
export RUST_BACKTRACE=1
export CARGO_NET_RETRY=10
export CARGO_NET_TIMEOUT=60

# ========= 工作目录修复 =========
function fix_working_directory() {
  if ! pwd >/dev/null 2>&1; then
    echo -e "${YELLOW}[!] 当前工作目录无法访问，切换到HOME目录...${RESET}"
    cd "$HOME" || cd / || {
      echo -e "${RED}[-] 无法访问任何有效目录${RESET}"
      exit 1
    }
  fi
  
  current_dir=$(pwd 2>/dev/null)
  if [ -z "$current_dir" ] || [ ! -d "$current_dir" ]; then
    echo -e "${YELLOW}[!] 工作目录异常，重置到HOME目录...${RESET}"
    cd "$HOME" || cd / || exit 1
  fi
  
  echo -e "${GREEN}[+] 工作目录检查完成: $(pwd)${RESET}"
}

# ========= 兼容性检测 =========
function check_system() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    OS="linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    OS="macos"
    echo -e "${YELLOW}[!] 检测到 macOS，某些优化功能可能不可用${RESET}"
  else
    OS="unknown"
    echo -e "${YELLOW}[!] 未知操作系统，请谨慎使用${RESET}"
  fi
  
  if ! sudo -n true 2>/dev/null; then
    echo -e "${YELLOW}[!] 需要sudo权限进行系统优化${RESET}"
  fi
}

# ========= 横幅 =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain 挖矿优化助手 v2.5"
  echo "==============================================="
  echo -e "${RESET}"
  echo "📌 作者: K2 节点教程分享"
  echo "🔗 Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "🐦 Twitter:  https://x.com/BtcK241918"
  echo "⚡ 优化版本: 深度修复构建问题 + 缓存清理"
  echo "-----------------------------------------------"
  echo ""
}

function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || {
      echo -e "${RED}[-] 无法进入项目目录: $NCK_DIR${RESET}"
      exit 1
    }
  else
    echo -e "${RED}[-] 项目目录不存在: $NCK_DIR${RESET}"
    exit 1
  fi
}

function optimize_system() {
  echo -e "${YELLOW}[*] 应用系统级性能优化...${RESET}"
  
  check_system
  
  if [[ "$OS" == "linux" ]]; then
    cpu_gov_files=$(find /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor 2>/dev/null || true)
    
    if [ -n "$cpu_gov_files" ]; then
      echo "$cpu_gov_files" | while read -r gov; do
        if [ -w "$gov" ] && [ -f "$gov" ]; then
          echo performance | sudo tee "$gov" >/dev/null 2>&1 || true
        fi
      done
      echo -e "${GREEN}[+] CPU性能模式已设置${RESET}"
    else
      echo -e "${YELLOW}[!] 未找到CPU调速器文件，跳过CPU优化${RESET}"
    fi
    
    if command -v sysctl >/dev/null 2>&1; then
      sudo sysctl -w net.core.rmem_max=16777216 >/dev/null 2>&1 || true
      sudo sysctl -w net.core.wmem_max=16777216 >/dev/null 2>&1 || true
      echo -e "${GREEN}[+] 网络参数优化完成${RESET}"
    else
      echo -e "${YELLOW}[!] sysctl命令不可用，跳过网络优化${RESET}"
    fi
  else
    echo -e "${YELLOW}[!] 非Linux系统，跳过系统级优化${RESET}"
  fi
  
  echo -e "${GREEN}[+] 系统优化完成${RESET}"
}

function install_dependencies() {
  echo -e "[*] 安装系统依赖..."
  
  if [[ "$OS" == "linux" ]]; then
    if command -v apt >/dev/null 2>&1; then
      sudo apt update -qq
      # 安装更完整的依赖包，包括构建失败常见缺失的包
      sudo apt install -y \
        clang llvm-dev libclang-dev \
        pkg-config pkgconf \
        libssl-dev libssl3 \
        build-essential cmake \
        curl git make screen htop unzip \
        libc6-dev gcc g++ \
        libffi-dev \
        python3-dev \
        autoconf automake libtool
    elif command -v yum >/dev/null 2>&1; then
      sudo yum groupinstall -y "Development Tools"
      sudo yum install -y \
        clang llvm-devel \
        openssl-devel \
        cmake curl git make screen htop unzip \
        gcc gcc-c++ \
        pkgconf-pkg-config \
        libffi-devel \
        python3-devel
    elif command -v pacman >/dev/null 2>&1; then
      sudo pacman -S --noconfirm \
        clang llvm \
        pkg-config pkgconf \
        openssl cmake curl git make screen htop unzip \
        gcc \
        libffi \
        python
    else
      echo -e "${RED}[-] 未识别的包管理器，请手动安装依赖${RESET}"
      return 1
    fi
  elif [[ "$OS" == "macos" ]]; then
    if command -v brew >/dev/null 2>&1; then
      brew install llvm openssl cmake curl git make screen htop unzip pkg-config
    else
      echo -e "${RED}[-] 请先安装 Homebrew${RESET}"
      return 1
    fi
  fi
  
  echo -e "${GREEN}[+] 系统依赖安装完成${RESET}"
  return 0
}

function deep_clean_cargo() {
  echo -e "[*] 深度清理Cargo环境..."
  
  # 停止所有cargo进程
  pkill -f cargo 2>/dev/null || true
  sleep 2
  
  # 完全清理cargo目录
  if [ -d "$HOME/.cargo" ]; then
    echo -e "${YELLOW}[*] 备份并清理cargo缓存...${RESET}"
    
    # 备份config
    if [ -f "$HOME/.cargo/config" ]; then
      cp "$HOME/.cargo/config" "$HOME/.cargo/config.backup" 2>/dev/null || true
    fi
    if [ -f "$HOME/.cargo/config.toml" ]; then
      cp "$HOME/.cargo/config.toml" "$HOME/.cargo/config.toml.backup" 2>/dev/null || true
    fi
    
    # 删除可能损坏的缓存目录
    rm -rf "$HOME/.cargo/registry" 2>/dev/null || true
    rm -rf "$HOME/.cargo/git" 2>/dev/null || true
    rm -rf "$HOME/.cargo/.global-cache" 2>/dev/null || true
    
    # 恢复config
    if [ -f "$HOME/.cargo/config.backup" ]; then
      mv "$HOME/.cargo/config.backup" "$HOME/.cargo/config" 2>/dev/null || true
    fi
    if [ -f "$HOME/.cargo/config.toml.backup" ]; then
      mv "$HOME/.cargo/config.toml.backup" "$HOME/.cargo/config.toml" 2>/dev/null || true
    fi
  fi
  
  # 清理临时文件
  rm -rf /tmp/cargo-* 2>/dev/null || true
  
  echo -e "${GREEN}[+] Cargo环境深度清理完成${RESET}"
}

function setup_rust() {
  echo -e "[*] 设置 Rust 工具链..."
  
  # 检查并安装Rust
  if ! command -v cargo &>/dev/null; then
    echo -e "[*] 安装Rust工具链..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
    source "$HOME/.cargo/env"
  else
    echo -e "[*] 检测到现有Rust安装，清理环境..."
    deep_clean_cargo
  fi

  # 更新工具链
  echo -e "[*] 更新Rust工具链..."
  rustup update stable >/dev/null 2>&1 || true
  rustup default stable >/dev/null 2>&1 || true
  
  # 配置环境变量
  for rc_file in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
    if [ -f "$rc_file" ] && ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$rc_file"; then
      echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    fi
  done
  
  # 确保当前会话可用
  export PATH="$HOME/.cargo/bin:$PATH"
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  # 设置cargo优化配置
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 4

[net]
retry = 10
timeout = 60000

[registry]
default = "sparse"

[source.crates-io]
registry = "sparse+https://index.crates.io/"
EOF
  
  echo -e "${GREEN}[+] Rust工具链设置完成${RESET}"
}

function safe_remove_directory() {
  local dir="$1"
  if [ -d "$dir" ]; then
    echo -e "${YELLOW}[*] 安全删除目录: $dir${RESET}"
    if [[ "$(pwd)" == "$dir"* ]]; then
      cd "$HOME" || cd /
    fi
    rm -rf "$dir"
  fi
}

function clone_repository() {
  echo -e "[*] 获取Nockchain仓库..."
  
  fix_working_directory
  cd "$HOME" || {
    echo -e "${RED}[-] 无法访问HOME目录${RESET}"
    return 1
  }
  
  if [ -d "$NCK_DIR" ]; then
    echo -e "${YELLOW}[*] 发现现有目录，检查git仓库状态...${RESET}"
    
    cd "$NCK_DIR" 2>/dev/null && {
      if git status >/dev/null 2>&1; then
        echo -e "${YELLOW}[*] 发现有效git仓库，尝试更新...${RESET}"
        if git pull origin main 2>/dev/null || git pull origin master 2>/dev/null; then
          echo -e "${GREEN}[+] 仓库更新成功${RESET}"
          return 0
        else
          echo -e "${YELLOW}[!] 更新失败，重新克隆...${RESET}"
        fi
      else
        echo -e "${YELLOW}[!] 目录存在但不是git仓库，重新克隆...${RESET}"
      fi
    } || {
      echo -e "${YELLOW}[!] 无法访问现有目录，重新克隆...${RESET}"
    }
    
    cd "$HOME"
    safe_remove_directory "$NCK_DIR"
  fi
  
  cd "$HOME" || {
    echo -e "${RED}[-] 无法访问HOME目录进行克隆${RESET}"
    return 1
  }
  
  echo -e "[*] 开始克隆仓库到: $NCK_DIR"
  
  clone_success=false
  
  if git clone https://github.com/zorp-corp/nockchain "$NCK_DIR" 2>/dev/null; then
    clone_success=true
  else
    echo -e "${YELLOW}[!] HTTPS克隆失败，尝试其他方法...${RESET}"
    
    mkdir -p "$NCK_DIR" 2>/dev/null
    if cd "$NCK_DIR" 2>/dev/null; then
      if git clone https://github.com/zorp-corp/nockchain . 2>/dev/null; then
        clone_success=true
      else
        cd "$HOME"
        safe_remove_directory "$NCK_DIR"
        
        echo -e "${YELLOW}[!] Git克隆失败，尝试下载zip包...${RESET}"
        if curl -L "https://github.com/zorp-corp/nockchain/archive/refs/heads/main.zip" -o nockchain.zip 2>/dev/null; then
          if command -v unzip >/dev/null 2>&1; then
            unzip -q nockchain.zip && mv nockchain-main "$NCK_DIR" 2>/dev/null && {
              rm -f nockchain.zip
              clone_success=true
            }
          else
            echo -e "${RED}[-] 需要unzip命令来解压文件${RESET}"
          fi
        fi
      fi
    fi
  fi
  
  if [ "$clone_success" = true ] && [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    echo -e "${GREEN}[+] 仓库获取成功${RESET}"
    return 0
  else
    echo -e "${RED}[-] 仓库获取失败${RESET}"
    return 1
  fi
}

function build_hoonc_advanced() {
  echo -e "[*] 高级构建hoonc工具..."
  
  cd_nck_dir
  
  # 检查hoonc目录
  if [ ! -d "crates/hoonc" ]; then
    echo -e "${YELLOW}[!] 未找到hoonc源码目录，跳过hoonc构建${RESET}"
    return 1
  fi
  
  # 清理之前的构建
  cargo clean >/dev/null 2>&1 || true
  rm -rf target/release/hoonc 2>/dev/null || true
  rm -rf "$HOME/.cargo/bin/hoonc" 2>/dev/null || true
  
  echo -e "[*] 尝试多种方法构建hoonc..."
  
  # 方法1: 简单构建
  echo -e "[*] 方法1: 基础构建..."
  if cargo build --release --bin hoonc 2>/dev/null; then
    if [ -f "target/release/hoonc" ]; then
      cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null || true
      echo -e "${GREEN}[+] hoonc构建成功 (方法1)${RESET}"
      return 0
    fi
  fi
  
  # 方法2: 直接在hoonc目录构建
  echo -e "[*] 方法2: 目录构建..."
  cd crates/hoonc
  if cargo build --release 2>/dev/null; then
    mkdir -p "$HOME/.cargo/bin"
    if [ -f "target/release/hoonc" ]; then
      cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null
      echo -e "${GREEN}[+] hoonc构建成功 (方法2)${RESET}"
      cd "$NCK_DIR"
      return 0
    fi
  fi
  cd "$NCK_DIR"
  
  # 方法3: 强制安装
  echo -e "[*] 方法3: 强制安装..."
  if cargo install --force --path crates/hoonc 2>/dev/null; then
    echo -e "${GREEN}[+] hoonc安装成功 (方法3)${RESET}"
    return 0
  fi
  
  # 方法4: 无特性构建
  echo -e "[*] 方法4: 最小化构建..."
  if cargo install --force --path crates/hoonc --no-default-features 2>/dev/null; then
    echo -e "${GREEN}[+] hoonc安装成功 (方法4)${RESET}"
    return 0
  fi
  
  echo -e "${YELLOW}[!] hoonc构建失败，但继续主项目构建${RESET}"
  return 1
}

function build_project_advanced() {
  echo -e "[*] 高级构建Nockchain项目..."
  
  cd_nck_dir
  
  # 设置环境变量
  export RUST_BACKTRACE=1
  export CARGO_INCREMENTAL=0
  export RUSTFLAGS="-C target-cpu=native -C opt-level=3"
  
  # 清理构建环境
  echo -e "[*] 清理构建环境..."
  cargo clean >/dev/null 2>&1 || true
  rm -rf target/ 2>/dev/null || true
  
  # 首先尝试构建hoonc
  build_hoonc_advanced
  
  echo -e "[*] 开始主项目构建..."
  
  # 更新依赖
  echo -e "[*] 更新项目依赖..."
  cargo update --aggressive >/dev/null 2>&1 || cargo update >/dev/null 2>&1 || true
  
  # 构建方法1: 完整构建
  echo -e "[*] 尝试完整项目构建..."
  if timeout 1800 cargo build --release --all 2>/dev/null; then
    echo -e "${GREEN}[+] 完整项目构建成功${RESET}"
    return 0
  fi
  
  # 构建方法2: 分包构建
  echo -e "[*] 尝试分包构建..."
  success_count=0
  
  # 获取所有包
  packages=$(cargo metadata --no-deps --format-version 1 2>/dev/null | grep '"name"' | cut -d'"' -f4 | head -20)
  
  for package in $packages; do
    echo -e "[*] 构建包: $package"
    if timeout 600 cargo build --release --package "$package" 2>/dev/null; then
      echo -e "${GREEN}[+] 包 $package 构建成功${RESET}"
      ((success_count++))
    else
      echo -e "${YELLOW}[!] 包 $package 构建失败${RESET}"
    fi
  done
  
  # 构建方法3: 核心二进制文件
  echo -e "[*] 尝试构建核心二进制文件..."
  
  for binary in "nockchain-wallet" "nockchain" "nockchain-miner"; do
    echo -e "[*] 构建二进制: $binary"
    if timeout 600 cargo build --release --bin "$binary" 2>/dev/null; then
      echo -e "${GREEN}[+] 二进制 $binary 构建成功${RESET}"
      ((success_count++))
    else
      echo -e "${YELLOW}[!] 二进制 $binary 构建失败${RESET}"
    fi
  done
  
  # 构建方法4: Makefile
  if [ -f "Makefile" ] && [ $success_count -lt 2 ]; then
    echo -e "[*] 尝试Makefile构建..."
    
    # 修复Makefile
    if grep -q "cargo install --locked" Makefile; then
      sed -i.bak 's/cargo install --locked/cargo install --force/g' Makefile 2>/dev/null || true
      sed -i.bak 's/--locked//g' Makefile 2>/dev/null || true
    fi
    
    for target in "build" "all" "release"; do
      echo -e "[*] 尝试Makefile目标: $target"
      if timeout 900 make "$target" 2>/dev/null; then
        echo -e "${GREEN}[+] Makefile构建成功 (目标: $target)${RESET}"
        ((success_count++))
        break
      fi
    done
  fi
  
  # 检查构建结果
  binary_count=0
  for path in "target/release/nockchain-wallet" "target/release/nockchain" "target/release/nockchain-miner"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      echo -e "${GREEN}[+] 发现二进制文件: $path${RESET}"
      ((binary_count++))
    fi
  done
  
  if [ $binary_count -gt 0 ] || [ $success_count -gt 0 ]; then
    echo -e "${GREEN}[+] 项目构建部分成功${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] 构建可能有问题，但可以继续配置${RESET}"
    return 1
  fi
}

function setup_environment() {
  echo -e "[*] 设置环境配置..."
  cd_nck_dir
  
  # 创建.env文件
  if [ -f ".env.example" ] || [ -f ".env_example" ]; then
    if [ -f ".env.example" ]; then
      cp -n .env.example "$ENV_FILE"
    else
      cp -n .env_example "$ENV_FILE"
    fi
    echo -e "${GREEN}[+] 从示例文件创建.env${RESET}"
  else
    echo -e "${YELLOW}[!] 未找到示例文件，创建基本.env文件${RESET}"
    cat > "$ENV_FILE" << 'EOF'
# Nockchain Configuration
MINING_PUBKEY=
RUST_LOG=info
RUST_BACKTRACE=1
EOF
  fi
  
  echo -e "${GREEN}[+] 环境配置完成${RESET}"
}

function setup_all() {
  echo -e "[*] 开始深度优化安装流程..."
  
  fix_working_directory
  optimize_system
  
  if ! install_dependencies; then
    echo -e "${RED}[-] 依赖安装失败${RESET}"
    pause_and_return
    return
  fi
  
  setup_rust
  
  if ! clone_repository; then
    echo -e "${RED}[-] 仓库获取失败${RESET}"
    echo -e "${YELLOW}[!] 请检查网络连接或手动下载项目${RESET}"
    pause_and_return
    return
  fi
  
  setup_environment
  
  if build_project_advanced; then
    echo -e "${GREEN}[+] 项目安装完成！${RESET}"
    
    # 显示构建结果
    echo -e "${BLUE}[i] 构建结果检查:${RESET}"
    cd_nck_dir
    for binary in "target/release/nockchain-wallet" "target/release/nockchain" "target/release/nockchain-miner"; do
      if [ -f "$binary" ]; then
        size=$(du -h "$binary" | cut -f1)
        echo -e "${GREEN}  ✓ $binary (大小: $size)${RESET}"
      else
        echo -e "${YELLOW}  ✗ $binary (未找到)${RESET}"
      fi
    done
  else
    echo -e "${YELLOW}[!] 构建可能有问题，请手动检查构建日志${RESET}"
  fi
  
  pause_and_return
}

function generate_wallet() {
  echo -e "[*] 生成钱包..."
  cd_nck_dir
  
  # 查找钱包二进制文件
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    echo -e "${YELLOW}[!] 请先完成项目构建${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${GREEN}[+] 使用钱包: $wallet_bin${RESET}"
  "$wallet_bin" keygen
  
  echo -e "${YELLOW}[!] 钱包生成完成，请复制上方公钥到下一步设置中${RESET}"
  echo -e "${BLUE}[i] 公钥格式为128位16进制字符串${RESET}"
  pause_and_return
}

function validate_pubkey() {
  local pubkey="$1"
  
  if [ ${#pubkey} -ne 128 ]; then
    echo -e "${RED}[-] 公钥长度错误！应为128位，当前为${#pubkey}位${RESET}"
    return 1
  fi
  
  if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
    echo -e "${RED}[-] 公钥格式错误！只能包含0-9和a-f字符${RESET}"
    return 1
  fi
  
  return 0
}

function set_pubkey_env() {
  echo -e "[*] 设置 MINING_PUBKEY 到 .env..."
  cd_nck_dir

  echo -e "${BLUE}[i] 公钥格式要求：128位16进制字符串${RESET}"
  echo -e "${BLUE}[i] 示例格式：d24c0c53d1162325eba695f32b7194f4c9b2943441a3162837922d36f3325c341ce049e7b3992080a9603e91147e4529f79261a355e16570c975a6c0e81716e3${RESET}"
  echo ""
  
  while true; do
    read -p "请输入公钥 (MINING_PUBKEY): " pubkey
    
    if [ -z "$pubkey" ]; then
      echo -e "${RED}[-] 公钥不能为空${RESET}"
      continue
    fi
    
    pubkey=$(echo "$pubkey" | tr -d ' \n\r\t')
    
    if validate_pubkey "$pubkey"; then
      pubkey=$(echo "$pubkey" | tr '[:upper:]' '[:lower:]')
      
      if command -v sed >/dev/null 2>&1; then
        sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || {
          grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        }
      else
        grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
      fi
      echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
      
      echo -e "${GREEN}[+] 公钥格式验证通过，已写入 .env 文件${RESET}"
      echo -e "${GREEN}[+] 公钥: $pubkey${RESET}"
      break
    else
      echo -e "${YELLOW}[!] 请重新输入正确格式的公钥${RESET}"
    fi
  done
  
  pause_and_return
}

function export_keys() {
  echo -e "[*] 导出钱包密钥..."
  cd_nck_dir
  
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  "$wallet_bin" export-keys
  echo -e "${GREEN}[+] 密钥已导出到 keys.export${RESET}"
  pause_and_return
}

function import_keys() {
  echo -e "[*] 导入钱包密钥..."
  cd_nck_dir
  
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  read -p "[?] 请输入密钥文件路径 (默认: ./keys.export): " keyfile
  keyfile=${keyfile:-"./keys.export"}
  
  if [ -f "$keyfile" ]; then
    "$wallet_bin" import-keys --input "$keyfile"
    echo -e "${GREEN}[+] 密钥已导入${RESET}"
  else
    echo -e "${RED}[-] 密钥文件不存在: $keyfile${RESET}"
  fi
  pause_and_return
}

function start_node() {
  echo -e "[*] 启动优化节点..."
  cd_nck_dir
  
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] .env文件不存在${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"

  if [ -z "$MINING_PUBKEY" ]; then
    echo -e "${RED}[-] 未设置 MINING_PUBKEY，请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi

  # 查找节点二进制文件
  node_bin=""
  for path in "./target/release/nockchain" "./target/release/nockchain-miner" "./nockchain" "./nockchain-miner" "/usr/local/bin/nockchain" "$HOME/.cargo/bin/nockchain"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      node_bin="$path"
      break
    fi
  done
  
  if [ -z "$node_bin" ]; then
    echo -e "${RED}[-] 未找到节点二进制文件${RESET}"
    echo -e "${YELLOW}[!] 请先完成项目构建${RESET}"
    pause_and_return
    return
  fi

  echo -e "${GREEN}[+] 使用节点: $node_bin${RESET}"

  # 检查启动脚本或直接运行
  if [ -f "./scripts/run_nockchain_miner.sh" ]; then
    chmod +x ./scripts/run_nockchain_miner.sh
    start_script="./scripts/run_nockchain_miner.sh"
  else
    start_script="$node_bin"
  fi

  if ! command -v screen >/dev/null 2>&1; then
    echo -e "${YELLOW}[!] screen未安装，直接后台启动...${RESET}"
    nohup "$start_script" > nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动，日志文件: nockchain.log${RESET}"
  else
    if screen -list | grep -qw "nockchain"; then
      echo "[*] 关闭旧的 screen 会话..."
      screen -S nockchain -X quit >/dev/null 2>&1
      sleep 2
    fi

    screen -dmS nockchain bash -c "cd '$NCK_DIR' && '$start_script'"

    sleep 3
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] 节点已启动 (screen 会话名: nockchain)${RESET}"
      echo -e "${GREEN}[+] 使用公钥: $MINING_PUBKEY${RESET}"
      echo -e "${YELLOW}[!] 使用 'screen -r nockchain' 查看日志${RESET}"
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
      echo "请检查错误日志"
    fi
  fi
  
  pause_and_return
}

function view_logs() {
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] 进入日志查看 (Ctrl+A+D 可退出)...${RESET}"
    screen -r nockchain
  elif [ -f "$NCK_DIR/nockchain.log" ]; then
    echo -e "${YELLOW}[!] 显示最近日志 (按q退出):${RESET}"
    tail -f "$NCK_DIR/nockchain.log"
  else
    echo -e "${RED}[-] 节点未运行且无日志文件${RESET}"
  fi
  pause_and_return
}

function check_status() {
  echo -e "[*] 检查节点状态..."
  
  cd_nck_dir
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE" >/dev/null 2>&1
    if [ -n "$MINING_PUBKEY" ]; then
      echo -e "${GREEN}[+] 已配置公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}${RESET}"
    else
      echo -e "${YELLOW}[!] 未设置挖矿公钥${RESET}"
    fi
  fi
  
  running=false
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] 节点运行中 (screen模式)${RESET}"
    running=true
  elif pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "${GREEN}[+] 节点运行中 (后台模式)${RESET}"
    running=true
  else
    echo -e "${RED}[-] 节点未运行${RESET}"
  fi
  
  if [ "$running" = true ]; then
    echo -e "${YELLOW}[*] 系统资源使用情况:${RESET}"
    if command -v htop >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] 启动htop监控 (5秒后自动返回):${RESET}"
      timeout 5 htop -d 1 2>/dev/null || true
    elif command -v top >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] CPU和内存使用情况:${RESET}"
      top -b -n1 | head -20
    fi
  fi
  
  pause_and_return
}

function stop_node() {
  echo -e "[*] 停止节点..."
  stopped=false
  
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    screen -S nockchain -X quit >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if pgrep -f "nockchain" >/dev/null 2>&1; then
    pkill -f "nockchain" >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if [ "$stopped" = true ]; then
    echo -e "${GREEN}[+] 节点已停止${RESET}"
  else
    echo -e "${YELLOW}[!] 节点未运行${RESET}"
  fi
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

function main_menu() {
  show_banner
  echo "请选择操作:"
  echo "  1) 🚀 一键优化安装"
  echo "  2) 🔑 生成钱包"
  echo "  3) 📝 设置挖矿公钥 (128位16进制)"
  echo "  4) 💾 导出密钥"
  echo "  5) 📂 导入密钥"
  echo "  6) ⚡ 启动节点"
  echo "  7) 📊 查看日志"
  echo "  8) 🔍 检查状态"
  echo "  9) ⏹️  停止节点"
  echo "  0) 退出"
  echo ""
  read -p "请输入编号: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node ;;
    7) view_logs ;;
    8) check_status ;;
    9) stop_node ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

main_menu
