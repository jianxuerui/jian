#!/bin/bash
# -*- coding: UTF-8 -*-
# Nockchain 增强版挖矿节点安装脚本 v12.0
# 解决启动失败、编译兼容性、系统稳定性问题

# 颜色定义
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RESET='\033[0m'

# 路径和环境配置
INSTALL_PREFIX="$HOME/.local"
NOCKCHAIN_DIR="$HOME/nockchain"
LOG_FILE="$HOME/nockchain_enhanced.log"
BACKUP_DIR="$HOME/nockchain_backup"
MINICONDA_DIR="$HOME/.miniconda3"
RUNTIME_DIR="$HOME/.nockchain_runtime"

# 增强版环境变量配置
export PATH="$INSTALL_PREFIX/bin:$HOME/.cargo/bin:$PATH"
export RUST_MIN_STACK=268435456  # 256MB stack size (增大)
export RUST_LOG=warn
export RUSTFLAGS="-C debuginfo=0 -C opt-level=2 -C codegen-units=1 -C link-arg=-Wl,--no-keep-memory -C target-cpu=native"
export CARGO_BUILD_JOBS=2  # 允许2个并发任务
export CARGO_INCREMENTAL=0
export CARGO_NET_RETRY=20
export CARGO_HTTP_TIMEOUT=900  # 15分钟超时
export MALLOC_ARENA_MAX=4
export OMP_NUM_THREADS=2

# 消息输出函数
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${RESET}"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$LOG_FILE"
}

# 命令检查函数
check_command() {
    command -v "$1" >/dev/null 2>&1
}

# 系统检测函数
detect_system_info() {
    print_message "$CYAN" "检测系统信息..."
    
    # 检测发行版
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$ID
        VERSION=$VERSION_ID
    else
        DISTRO="unknown"
        VERSION="unknown"
    fi
    
    # 检测架构
    ARCH=$(uname -m)
    
    # 检测资源
    TOTAL_RAM=$(free -m 2>/dev/null | awk '/^Mem:/{print $2}' || echo "4096")
    AVAILABLE_SPACE=$(df -m ~ 2>/dev/null | awk 'NR==2{print $4}' || echo "10240")
    CPU_CORES=$(nproc)
    
    print_message "$YELLOW" "系统信息："
    print_message "$YELLOW" "- 发行版: $DISTRO $VERSION"
    print_message "$YELLOW" "- 架构: $ARCH"
    print_message "$YELLOW" "- CPU核心: $CPU_CORES"
    print_message "$YELLOW" "- 内存: ${TOTAL_RAM}MB"
    print_message "$YELLOW" "- 可用空间: ${AVAILABLE_SPACE}MB"
    
    # 调整并发设置
    if [ "$CPU_CORES" -gt 4 ]; then
        export CARGO_BUILD_JOBS=4
        export OMP_NUM_THREADS=4
    elif [ "$CPU_CORES" -gt 2 ]; then
        export CARGO_BUILD_JOBS=2
        export OMP_NUM_THREADS=2
    else
        export CARGO_BUILD_JOBS=1
        export OMP_NUM_THREADS=1
    fi
    
    print_message "$GREEN" "并发设置: CARGO_BUILD_JOBS=$CARGO_BUILD_JOBS"
}

# 增强版系统依赖安装
install_enhanced_system_deps() {
    print_message "$CYAN" "安装增强版系统依赖..."
    
    local install_success=false
    
    case $DISTRO in
        "ubuntu"|"debian"|"mint"|"pop")
            if sudo -n true 2>/dev/null; then
                sudo apt update
                sudo apt install -y \
                    build-essential gcc g++ make cmake clang llvm-dev libclang-dev \
                    pkg-config libssl-dev libc6-dev curl wget git bc \
                    screen tmux htop procps lsof \
                    libffi-dev zlib1g-dev libncurses5-dev libgdbm-dev \
                    libnss3-dev libreadline-dev libsqlite3-dev libbz2-dev \
                    libexpat1-dev liblzma-dev libgmp-dev \
                    software-properties-common apt-transport-https ca-certificates \
                    gnupg lsb-release
                install_success=true
            fi
            ;;
            
        "centos"|"rhel"|"rocky"|"almalinux"|"fedora")
            if sudo -n true 2>/dev/null; then
                if check_command "dnf"; then
                    sudo dnf groupinstall -y "Development Tools"
                    sudo dnf install -y clang llvm-devel openssl-devel cmake \
                        curl wget git bc screen tmux htop procps-ng lsof \
                        libffi-devel zlib-devel ncurses-devel gdbm-devel \
                        nss-devel readline-devel sqlite-devel bzip2-devel \
                        expat-devel xz-devel gmp-devel
                elif check_command "yum"; then
                    sudo yum groupinstall -y "Development Tools"
                    sudo yum install -y clang llvm-devel openssl-devel cmake \
                        curl wget git bc screen tmux htop procps-ng lsof
                fi
                install_success=true
            fi
            ;;
    esac
    
    if [ "$install_success" = true ]; then
        print_message "$GREEN" "系统依赖安装完成"
        return 0
    else
        print_message "$YELLOW" "系统依赖安装失败或无权限，将使用Conda"
        return 1
    fi
}

# 智能Miniconda管理
smart_conda_setup() {
    print_message "$CYAN" "智能设置Conda环境..."
    
    # 检查现有安装
    if [ -d "$MINICONDA_DIR" ] && [ -f "$MINICONDA_DIR/bin/conda" ]; then
        if "$MINICONDA_DIR/bin/conda" --version >/dev/null 2>&1; then
            print_message "$GREEN" "发现有效的Conda安装"
            source "$MINICONDA_DIR/etc/profile.d/conda.sh"
            return 0
        else
            print_message "$YELLOW" "清理损坏的Conda安装"
            rm -rf "$MINICONDA_DIR"
        fi
    fi
    
    # 下载并安装Miniconda
    print_message "$CYAN" "下载Miniconda..."
    case $ARCH in
        x86_64) CONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) CONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "不支持的架构: $ARCH"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_installer.sh"
    
    # 多源下载尝试
    for mirror in \
        "$CONDA_URL" \
        "https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-${ARCH}.sh" \
        "https://mirrors.ustc.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-${ARCH}.sh"
    do
        if wget -q --show-progress --timeout=180 --tries=3 "$mirror" -O "$installer"; then
            break
        fi
        print_message "$YELLOW" "镜像 $mirror 下载失败，尝试下一个..."
    done
    
    if [ ! -f "$installer" ]; then
        print_message "$RED" "Miniconda下载失败"
        return 1
    fi
    
    chmod +x "$installer"
    if bash "$installer" -b -p "$MINICONDA_DIR"; then
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        conda config --set auto_activate_base false
        conda config --set channel_priority strict
        # 添加国内镜像
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
        rm -f "$installer"
        print_message "$GREEN" "Miniconda安装完成"
        return 0
    else
        print_message "$RED" "Miniconda安装失败"
        return 1
    fi
}

# 增强版Conda编译环境
setup_enhanced_conda_env() {
    print_message "$CYAN" "设置增强版Conda编译环境..."
    
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    
    # 创建或更新环境
    conda create -n nockchain-enhanced -y python=3.9 --no-default-packages || {
        print_message "$YELLOW" "环境已存在，正在更新..."
        conda activate nockchain-enhanced
    }
    
    conda activate nockchain-enhanced
    
    # 安装编译工具链
    local packages=(
        "compilers" "gcc_linux-64" "gxx_linux-64" "clang" "clangxx"
        "make" "cmake" "pkg-config" "binutils" "ld_impl_linux-64"
        "openssl" "libffi" "curl" "wget" "bc" "git"
        "tmux" "screen" "htop" "procps-ng"
    )
    
    for package in "${packages[@]}"; do
        print_message "$YELLOW" "安装 $package..."
        conda install -y "$package" -c conda-forge --quiet || {
            print_message "$YELLOW" "跳过 $package（可能不可用）"
        }
    done
    
    # 验证编译器
    if check_command "gcc" && check_command "g++"; then
        print_message "$GREEN" "编译器安装成功"
        # 创建符号链接
        if ! check_command "cc"; then
            ln -sf "$(which gcc)" "$CONDA_PREFIX/bin/cc" 2>/dev/null || true
        fi
        return 0
    else
        print_message "$RED" "编译器安装失败"
        return 1
    fi
}

# 增强版Rust环境设置
setup_enhanced_rust() {
    print_message "$CYAN" "设置增强版Rust环境..."
    
    # 安装Rust
    if ! check_command "rustc"; then
        print_message "$CYAN" "安装Rust..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
            --default-toolchain stable \
            --profile default \
            --no-modify-path
        source "$HOME/.cargo/env"
    fi
    
    # 更新Rust
    rustup update stable
    rustup default stable
    
    # 增强版Cargo配置
    mkdir -p "$HOME/.cargo"
    cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 2

[net]
retry = 20
git-fetch-with-cli = true
offline = false

[http]
timeout = 900
low-speed-limit = 1

[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = "https://mirrors.ustc.edu.cn/crates.io-index"

[target.x86_64-unknown-linux-gnu]
linker = "cc"
rustflags = [
    "-C", "link-arg=-Wl,--no-keep-memory",
    "-C", "link-arg=-Wl,--reduce-memory-overheads",
    "-C", "link-arg=-Wl,--gc-sections",
    "-C", "target-cpu=native"
]

[profile.dev]
debug = 0
opt-level = 1
incremental = false
codegen-units = 1

[profile.release]
debug = 0
lto = "thin"
codegen-units = 1
incremental = false
panic = "abort"
opt-level = 3
EOF
    
    print_message "$GREEN" "Rust环境配置完成"
}

# 智能Bootstrap文件生成
generate_smart_bootstrap() {
    print_message "$CYAN" "智能生成Bootstrap文件..."
    
    cd "$NOCKCHAIN_DIR" || return 1
    mkdir -p "crates/hoonc/bootstrap"
    
    # 方法1: 尝试现有Makefile
    if [ -f "Makefile" ] && grep -q "bootstrap\|install-hoonc" Makefile; then
        print_message "$CYAN" "尝试使用Makefile生成..."
        if timeout 1200 make bootstrap 2>/dev/null || timeout 1200 make install-hoonc 2>/dev/null; then
            if [ -f "crates/hoonc/bootstrap/hoonc.jam" ] && [ -s "crates/hoonc/bootstrap/hoonc.jam" ]; then
                print_message "$GREEN" "Makefile生成成功"
                return 0
            fi
        fi
    fi
    
    # 方法2: 网络下载
    print_message "$CYAN" "尝试网络下载..."
    local urls=(
        "https://raw.githubusercontent.com/zorp-corp/nockchain/master/crates/hoonc/bootstrap/hoonc.jam"
        "https://github.com/zorp-corp/nockchain/raw/master/crates/hoonc/bootstrap/hoonc.jam"
        "https://gitee.com/mirrors/nockchain/raw/master/crates/hoonc/bootstrap/hoonc.jam"
    )
    
    for url in "${urls[@]}"; do
        if wget -q --timeout=60 "$url" -O "crates/hoonc/bootstrap/hoonc.jam.tmp"; then
            if [ -s "crates/hoonc/bootstrap/hoonc.jam.tmp" ]; then
                mv "crates/hoonc/bootstrap/hoonc.jam.tmp" "crates/hoonc/bootstrap/hoonc.jam"
                print_message "$GREEN" "网络下载成功"
                return 0
            fi
        fi
        rm -f "crates/hoonc/bootstrap/hoonc.jam.tmp"
    done
    
    # 方法3: 生成最小JAM文件
    print_message "$CYAN" "生成最小化JAM文件..."
    python3 -c "
import struct
import os

# 创建有效的最小JAM文件
jam_data = bytearray()
jam_data.extend(b'\\x00\\x00\\x00\\x01')  # 基础原子
jam_data.extend(b'\\x00\\x00\\x00\\x00')  # 填充
jam_data.extend(b'\\x01\\x00\\x00\\x00')  # 计算核心
jam_data.extend(b'\\x00' * 16)           # 额外填充

with open('crates/hoonc/bootstrap/hoonc.jam', 'wb') as f:
    f.write(jam_data)
print('最小JAM文件创建完成')
" 2>/dev/null || {
        # Python不可用时的备选方案
        printf '\x00\x00\x00\x01\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' > "crates/hoonc/bootstrap/hoonc.jam"
    }
    
    if [ -f "crates/hoonc/bootstrap/hoonc.jam" ] && [ -s "crates/hoonc/bootstrap/hoonc.jam" ]; then
        print_message "$GREEN" "最小JAM文件生成成功"
        return 0
    fi
    
    print_message "$RED" "Bootstrap文件生成失败"
    return 1
}

# 增强版项目编译
compile_enhanced_nockchain() {
    print_message "$CYAN" "开始增强版项目编译..."
    
    cd "$NOCKCHAIN_DIR" || return 1
    
    # 激活环境
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-enhanced
    
    # 设置编译环境
    export CC=$(which gcc || which clang)
    export CXX=$(which g++ || which clang++)
    export RUSTFLAGS="-C debuginfo=0 -C opt-level=2 -C linker=$CC -C link-arg=-Wl,--no-keep-memory -C target-cpu=native"
    
    print_message "$GREEN" "编译环境: CC=$CC, CXX=$CXX"
    
    # 步骤1: 生成Bootstrap文件
    if ! generate_smart_bootstrap; then
        print_message "$RED" "Bootstrap文件生成失败"
        return 1
    fi
    
    # 步骤2: 清理编译缓存
    print_message "$CYAN" "清理编译缓存..."
    cargo clean 2>/dev/null || true
    rm -rf target/debug/build/*hoonc* target/release/build/*hoonc* 2>/dev/null || true
    
    # 步骤3: 编译hoonc编译器
    print_message "$CYAN" "编译hoonc编译器..."
    local hoonc_success=false
    
    # 尝试多种编译方法
    for method in "makefile" "cargo-install" "cargo-build"; do
        print_message "$YELLOW" "尝试方法: $method"
        
        case $method in
            "makefile")
                if timeout 2400 make install-hoonc; then
                    if check_command "hoonc"; then
                        hoonc_success=true
                        break
                    fi
                fi
                ;;
            "cargo-install")
                if timeout 2400 cargo install --locked --force --path crates/hoonc --bin hoonc; then
                    if check_command "hoonc"; then
                        hoonc_success=true
                        break
                    fi
                fi
                ;;
            "cargo-build")
                cd crates/hoonc || continue
                if timeout 2400 cargo build --release --bin hoonc; then
                    if [ -f "target/release/hoonc" ]; then
                        mkdir -p "$HOME/.cargo/bin"
                        cp target/release/hoonc "$HOME/.cargo/bin/"
                        chmod +x "$HOME/.cargo/bin/hoonc"
                        if check_command "hoonc"; then
                            hoonc_success=true
                            cd ../..
                            break
                        fi
                    fi
                fi
                cd ../..
                ;;
        esac
        
        print_message "$YELLOW" "方法 $method 失败，尝试下一个..."
    done
    
    if [ "$hoonc_success" = false ]; then
        print_message "$RED" "hoonc编译器安装失败"
        return 1
    fi
    
    print_message "$GREEN" "hoonc编译器安装成功: $(which hoonc)"
    
    # 步骤4: 编译主项目
    print_message "$CYAN" "编译主项目..."
    
    # 内存清理
    sync
    echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null 2>&1 || true
    
    if timeout 3600 make build; then
        print_message "$GREEN" "主项目编译成功"
    else
        print_message "$YELLOW" "主项目编译超时，尝试手动编译关键组件..."
        
        # 手动编译关键组件
        for component in "nockchain" "nockchain-wallet"; do
            if [ -d "crates/$component" ]; then
                print_message "$CYAN" "编译 $component..."
                cd "crates/$component" || continue
                if timeout 1800 cargo build --release --bin "$component"; then
                    if [ -f "target/release/$component" ]; then
                        mkdir -p "$HOME/.cargo/bin"
                        cp "target/release/$component" "$HOME/.cargo/bin/"
                        chmod +x "$HOME/.cargo/bin/$component"
                        print_message "$GREEN" "$component 编译成功"
                    fi
                fi
                cd ../..
            fi
        done
    fi
    
    # 步骤5: 安装组件
    print_message "$CYAN" "安装组件..."
    make install-nockchain-wallet 2>/dev/null || print_message "$YELLOW" "钱包安装失败"
    make install-nockchain 2>/dev/null || print_message "$YELLOW" "主程序安装失败"
    
    print_message "$GREEN" "项目编译完成"
}

# 智能进程监控系统
setup_process_monitor() {
    print_message "$CYAN" "设置智能进程监控系统..."
    
    mkdir -p "$RUNTIME_DIR"
    
    # 创建进程监控脚本
    cat > "$RUNTIME_DIR/monitor.sh" << 'EOF'
#!/bin/bash
# Nockchain 智能进程监控脚本

NOCKCHAIN_DIR="$HOME/nockchain"
LOG_DIR="$HOME/.nockchain_runtime"
MONITOR_LOG="$LOG_DIR/monitor.log"
RESTART_COUNT_FILE="$LOG_DIR/restart_count"
MAX_RESTARTS=10
CHECK_INTERVAL=30

# 初始化重启计数
[ ! -f "$RESTART_COUNT_FILE" ] && echo "0" > "$RESTART_COUNT_FILE"

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$MONITOR_LOG"
}

check_and_restart() {
    local restart_count=$(cat "$RESTART_COUNT_FILE")
    
    # 检查是否超过最大重启次数
    if [ "$restart_count" -gt "$MAX_RESTARTS" ]; then
        log_message "超过最大重启次数 ($MAX_RESTARTS)，停止监控"
        exit 1
    fi
    
    # 检查nockchain进程
    if ! pgrep -f "nockchain.*run\|make.*run-nockchain" >/dev/null; then
        log_message "检测到nockchain进程未运行，准备重启..."
        
        # 清理残留进程
        pkill -f "nockchain" 2>/dev/null || true
        sleep 5
        
        # 重启进程
        cd "$NOCKCHAIN_DIR" || exit 1
        source "$HOME/.miniconda3/etc/profile.d/conda.sh"
        conda activate nockchain-enhanced
        
        # 启动新的挖矿进程
        screen -dmS nockchain-mining bash -c "
            cd '$NOCKCHAIN_DIR'
            source '$HOME/.miniconda3/etc/profile.d/conda.sh'
            conda activate nockchain-enhanced
            while true; do
                timeout 7200 make run-nockchain 2>&1 | tee -a logs/mining.log
                case \$? in
                    0) echo 'Normal exit'; break ;;
                    124) echo 'Timeout restart'; sleep 10; continue ;;
                    *) echo 'Error restart'; sleep 15; continue ;;
                esac
            done
        "
        
        # 更新重启计数
        echo $((restart_count + 1)) > "$RESTART_COUNT_FILE"
        log_message "重启完成，重启次数: $((restart_count + 1))"
        
        # 每天重置重启计数
        if [ $((restart_count % 20)) -eq 0 ]; then
            echo "0" > "$RESTART_COUNT_FILE"
            log_message "重置重启计数"
        fi
    else
        # 进程正常运行，重置计数
        if [ "$restart_count" -gt 0 ]; then
            echo "0" > "$RESTART_COUNT_FILE"
            log_message "进程稳定运行，重置重启计数"
        fi
    fi
}

# 主循环
while true; do
    check_and_restart
    sleep "$CHECK_INTERVAL"
done
EOF
    
    chmod +x "$RUNTIME_DIR/monitor.sh"
    print_message "$GREEN" "进程监控系统设置完成"
}

# 主安装函数
install_enhanced_nockchain() {
    print_message "$GREEN" ">>> 开始Nockchain增强版安装..."
    
    # 系统检测
    detect_system_info
    
    # 检查基本要求
    if [ "$TOTAL_RAM" -lt 3072 ]; then
        print_message "$RED" "错误：系统内存不足3GB"
        return 1
    fi
    
    if [ "$AVAILABLE_SPACE" -lt 8192 ]; then
        print_message "$RED" "错误：可用磁盘空间不足8GB"
        return 1
    fi
    
    mkdir -p "$BACKUP_DIR" "$RUNTIME_DIR" "$INSTALL_PREFIX"/{bin,lib,include}
    
    # 步骤1: 安装系统依赖
    print_message "$MAGENTA" "步骤 1/7: 安装系统依赖..."
    local use_conda=false
    if ! install_enhanced_system_deps; then
        use_conda=true
    fi
    
    # 步骤2: 设置Conda环境
    print_message "$MAGENTA" "步骤 2/7: 设置Conda环境..."
    if ! smart_conda_setup; then
        print_message "$RED" "Conda设置失败"
        return 1
    fi
    
    # 步骤3: 设置编译环境
    if [ "$use_conda" = true ]; then
        print_message "$MAGENTA" "步骤 3/7: 设置Conda编译环境..."
        if ! setup_enhanced_conda_env; then
            print_message "$RED" "编译环境设置失败"
            return 1
        fi
    else
        print_message "$MAGENTA" "步骤 3/7: 使用系统编译器"
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        conda create -n nockchain-enhanced -y python=3.9 --no-default-packages
        conda activate nockchain-enhanced
    fi
    
    # 步骤4: 设置Rust环境
    print_message "$MAGENTA" "步骤 4/7: 设置Rust环境..."
    if ! setup_enhanced_rust; then
        print_message "$RED" "Rust环境设置失败"
        return 1
    fi
    
    # 步骤5: 获取源码
    print_message "$MAGENTA" "步骤 5/7: 获取Nockchain源码..."
    if [ -d "$NOCKCHAIN_DIR" ]; then
        print_message "$YELLOW" "更新现有项目..."
        cd "$NOCKCHAIN_DIR"
        git stash 2>/dev/null || true
        git pull origin main || {
            cd "$HOME"
            rm -rf "$NOCKCHAIN_DIR"
            git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR"
        }
    else
        git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR" || {
            print_message "$RED" "源码获取失败"
            return 1
        }
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 配置环境文件
    if [ -f ".env_example" ]; then
        cp .env_example .env
    else
        cat > .env << 'EOF'
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
NETWORK=mainnet
MAX_PEERS=1000
LOG_LEVEL=warn
RUST_LOG=warn
RUST_MIN_STACK=268435456
CARGO_BUILD_JOBS=2
CARGO_HTTP_TIMEOUT=900
CARGO_NET_RETRY=20
EOF
    fi
    
    # 创建日志目录
    mkdir -p logs
    
    # 步骤6: 编译项目
    print_message "$MAGENTA" "步骤 6/7: 编译项目..."
    if ! compile_enhanced_nockchain; then
        print_message "$RED" "项目编译失败"
        return 1
    fi
    
    # 步骤7: 设置监控系统
    print_message "$MAGENTA" "步骤 7/7: 设置监控系统..."
    setup_process_monitor
    
    # 生成钱包
    if check_command "nockchain-wallet"; then
        print_message "$CYAN" "生成钱包..."
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        conda activate nockchain-enhanced
        
        local wallet_output
        wallet_output=$(timeout 60 nockchain-wallet keygen 2>&1)
        
        if [ $? -eq 0 ]; then
            print_message "$GREEN" "钱包生成成功！"
            echo "$wallet_output"
            echo "$wallet_output" > "$BACKUP_DIR/wallet_$(date +%Y%m%d_%H%M%S).txt"
            
            # 提取公钥
            local pubkey=$(echo "$wallet_output" | grep -E "Public key:|公钥:" | awk '{print $NF}')
            if [ -n "$pubkey" ] && [[ $pubkey =~ ^[0-9a-fA-F]{128}$ ]]; then
                sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$pubkey/" .env
                print_message "$GREEN" "公钥自动配置完成"
            fi
        fi
    fi
    
    # 创建启动脚本
    cat > "$HOME/nockchain_enhanced.sh" << 'EOF'
#!/bin/bash
# Nockchain增强版环境激活脚本

export PATH="$HOME/.cargo/bin:$PATH"
export RUST_MIN_STACK=268435456
export RUST_LOG=warn
export CARGO_BUILD_JOBS=2

source "$HOME/.miniconda3/etc/profile.d/conda.sh"
conda activate nockchain-enhanced

cd "$HOME/nockchain"
echo "Nockchain增强版环境已激活"
echo "编译器: $(which gcc)"
echo "hoonc: $(which hoonc)"
echo "钱包: $(which nockchain-wallet)"
echo "Bootstrap: $(ls -la crates/hoonc/bootstrap/hoonc.jam 2>/dev/null || echo '未找到')"
echo ""
echo "使用命令："
echo "  启动挖矿: make run-nockchain"
echo "  启动监控: $HOME/.nockchain_runtime/monitor.sh &"
echo "  查看日志: tail -f logs/mining.log"
EOF
    chmod +x "$HOME/nockchain_enhanced.sh"
    
    print_message "$GREEN" "🎉 Nockchain增强版安装完成！"
    print_message "$CYAN" "环境激活: source ~/nockchain_enhanced.sh"
    print_message "$CYAN" "进程监控: ~/.nockchain_runtime/monitor.sh &"
}

# 启动增强版挖矿
start_enhanced_mining() {
    print_message "$GREEN" ">>> 启动增强版挖矿节点..."
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到配置文件"
        return 1
    fi
    
    # 检查Bootstrap文件
    if [ ! -f "$NOCKCHAIN_DIR/crates/hoonc/bootstrap/hoonc.jam" ]; then
        print_message "$RED" "错误：Bootstrap文件缺失"
        return 1
    fi
    
    # 停止现有进程
    if screen -list | grep -q "nockchain"; then
        screen -S nockchain-mining -X quit 2>/dev/null || true
        sleep 3
    fi
    
    cd "$NOCKCHAIN_DIR"
    source "$HOME/nockchain_enhanced.sh"
    
    # 启动挖矿进程
    screen -dmS nockchain-mining bash -c "
        source '$HOME/nockchain_enhanced.sh'
        cd '$NOCKCHAIN_DIR'
        
        echo '=== Nockchain增强版挖矿启动 ===' | tee -a logs/mining.log
        echo '启动时间: \$(date)' | tee -a logs/mining.log
        echo '版本: 增强版 v12.0' | tee -a logs/mining.log
        echo '=================================' | tee -a logs/mining.log
        
        while true; do
            timeout 7200 make run-nockchain 2>&1 | tee -a logs/mining.log
            exit_code=\$?
            case \$exit_code in
                0) echo '\$(date): 正常退出' | tee -a logs/mining.log; break ;;
                124) echo '\$(date): 运行超时，重启...' | tee -a logs/mining.log; sleep 10; continue ;;
                *) echo '\$(date): 异常退出(\$exit_code)，等待重启...' | tee -a logs/mining.log; sleep 15; continue ;;
            esac
        done
    "
    
    sleep 5
    
    if screen -list | grep -q "nockchain-mining"; then
        print_message "$GREEN" "🚀 增强版挖矿节点启动成功！"
        print_message "$CYAN" "- 查看进程: screen -r nockchain-mining"
        print_message "$CYAN" "- 启动监控: ~/.nockchain_runtime/monitor.sh &"
        print_message "$CYAN" "- 查看日志: tail -f ~/nockchain/logs/mining.log"
        
        # 自动启动监控
        if [ -f "$RUNTIME_DIR/monitor.sh" ]; then
            nohup "$RUNTIME_DIR/monitor.sh" > "$RUNTIME_DIR/monitor.log" 2>&1 &
            print_message "$GREEN" "进程监控已自动启动"
        fi
    else
        print_message "$RED" "启动失败，请查看日志"
    fi
}

# 显示菜单
show_menu() {
    clear
    echo -e "${BLUE}
=======================================
 Nockchain 增强版挖矿解决方案 v12.0
=======================================
${RESET}"
    echo -e "${YELLOW}1. 完整安装增强版Nockchain（推荐）"
    echo "2. 启动增强版挖矿节点"
    echo "3. 查看挖矿日志"
    echo "4. 检查系统状态"
    echo "5. 重启挖矿进程"
    echo "6. 配置挖矿公钥"
    echo "7. 备份钱包数据"
    echo "8. 故障诊断"
    echo "9. 卸载清理"
    echo "10. 退出"
    echo -e "${BLUE}=======================================${RESET}"
}

# 其他功能函数（简化版）
check_status() {
    print_message "$CYAN" "系统状态检查..."
    
    # 进程状态
    if pgrep -f "nockchain.*run\|make.*run-nockchain" >/dev/null; then
        print_message "$GREEN" "✅ 挖矿进程正在运行"
    else
        print_message "$RED" "❌ 挖矿进程未运行"
    fi
    
    # 监控状态
    if pgrep -f "monitor.sh" >/dev/null; then
        print_message "$GREEN" "✅ 进程监控正在运行"
    else
        print_message "$YELLOW" "⚠️ 进程监控未运行"
    fi
    
    # Bootstrap文件
    if [ -f "$NOCKCHAIN_DIR/crates/hoonc/bootstrap/hoonc.jam" ]; then
        local size=$(stat -c%s "$NOCKCHAIN_DIR/crates/hoonc/bootstrap/hoonc.jam" 2>/dev/null || echo "0")
        print_message "$GREEN" "✅ Bootstrap文件存在 (${size} 字节)"
    else
        print_message "$RED" "❌ Bootstrap文件缺失"
    fi
    
    # 系统资源
    local mem_usage=$(free | awk '/^Mem:/{printf "%.1f", $3/$2*100}')
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    print_message "$CYAN" "内存使用率: ${mem_usage}%"
    print_message "$CYAN" "系统负载: $load_avg"
}

view_logs() {
    print_message "$GREEN" ">>> 查看挖矿日志"
    
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        tail -f "$NOCKCHAIN_DIR/logs/mining.log"
    else
        print_message "$RED" "日志文件不存在"
    fi
}

restart_mining() {
    print_message "$GREEN" ">>> 重启挖矿进程"
    
    # 停止现有进程
    screen -S nockchain-mining -X quit 2>/dev/null || true
    pkill -f "nockchain.*run\|make.*run-nockchain" 2>/dev/null || true
    sleep 5
    
    # 重新启动
    start_enhanced_mining
}

configure_pubkey() {
    print_message "$GREEN" ">>> 配置挖矿公钥"
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "配置文件不存在"
        return 1
    fi
    
    local current_key=$(grep "MINING_PUBKEY" "$NOCKCHAIN_DIR/.env" | cut -d'=' -f2)
    print_message "$YELLOW" "当前公钥: $current_key"
    
    read -p "请输入新的128位16进制公钥: " new_pubkey
    
    if [[ $new_pubkey =~ ^[0-9a-fA-F]{128}$ ]]; then
        cd "$NOCKCHAIN_DIR"
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" .env
        print_message "$GREEN" "公钥更新成功！"
    else
        print_message "$RED" "公钥格式错误，必须是128位16进制"
    fi
}

backup_wallet() {
    print_message "$GREEN" ">>> 备份钱包数据"
    
    local backup_file="$BACKUP_DIR/nockchain_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    mkdir -p "$BACKUP_DIR"
    
    if [ -d "$NOCKCHAIN_DIR" ]; then
        cd "$NOCKCHAIN_DIR"
        tar -czf "$backup_file" .env logs/ *.txt crates/hoonc/bootstrap/hoonc.jam 2>/dev/null || true
        print_message "$GREEN" "备份完成: $backup_file"
    else
        print_message "$RED" "项目目录不存在"
    fi
}

diagnose_issues() {
    print_message "$GREEN" ">>> 故障诊断"
    
    echo "=== 基础检查 ==="
    check_command "gcc" && print_message "$GREEN" "✅ gcc: $(which gcc)" || print_message "$RED" "❌ gcc未找到"
    check_command "rustc" && print_message "$GREEN" "✅ rustc: $(rustc --version)" || print_message "$RED" "❌ rustc未找到"
    check_command "hoonc" && print_message "$GREEN" "✅ hoonc: $(which hoonc)" || print_message "$RED" "❌ hoonc未找到"
    
    echo -e "\n=== 文件检查 ==="
    [ -f "$NOCKCHAIN_DIR/Makefile" ] && print_message "$GREEN" "✅ Makefile存在" || print_message "$RED" "❌ Makefile缺失"
    [ -f "$NOCKCHAIN_DIR/.env" ] && print_message "$GREEN" "✅ 配置文件存在" || print_message "$RED" "❌ 配置文件缺失"
    [ -f "$NOCKCHAIN_DIR/crates/hoonc/bootstrap/hoonc.jam" ] && print_message "$GREEN" "✅ Bootstrap文件存在" || print_message "$RED" "❌ Bootstrap文件缺失"
    
    echo -e "\n=== 进程检查 ==="
    if pgrep -f "nockchain" >/dev/null; then
        print_message "$GREEN" "✅ 发现nockchain相关进程:"
        pgrep -f "nockchain" | while read pid; do
            ps -p $pid -o pid,cmd --no-headers
        done
    else
        print_message "$RED" "❌ 未发现nockchain进程"
    fi
    
    echo -e "\n=== 日志检查 ==="
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        print_message "$CYAN" "最近的日志:"
        tail -10 "$NOCKCHAIN_DIR/logs/mining.log"
    else
        print_message "$YELLOW" "无挖矿日志"
    fi
}

cleanup_installation() {
    print_message "$GREEN" ">>> 卸载清理"
    
    read -p "确定要卸载所有组件吗？(y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # 停止所有进程
        screen -S nockchain-mining -X quit 2>/dev/null || true
        pkill -f "nockchain\|monitor.sh" 2>/dev/null || true
        
        # 删除文件
        rm -rf "$NOCKCHAIN_DIR" "$RUNTIME_DIR" "$MINICONDA_DIR/envs/nockchain-enhanced"
        rm -f "$HOME/nockchain_enhanced.sh"
        
        print_message "$GREEN" "卸载完成"
    fi
}

# 主函数
main() {
    if [ "$EUID" -eq 0 ]; then
        print_message "$RED" "请不要以root用户运行"
        exit 1
    fi
    
    mkdir -p "$BACKUP_DIR" "$RUNTIME_DIR"
    touch "$LOG_FILE"
    
    while true; do
        show_menu
        read -p "请选择操作 (1-10): " choice
        
        case $choice in
            1) install_enhanced_nockchain ;;
            2) start_enhanced_mining ;;
            3) view_logs ;;
            4) check_status ;;
            5) restart_mining ;;
            6) configure_pubkey ;;
            7) backup_wallet ;;
            8) diagnose_issues ;;
            9) cleanup_installation ;;
            10) print_message "$GREEN" "谢谢使用！"; exit 0 ;;
            *) print_message "$RED" "无效选项" ;;
        esac
        
        echo
        read -p "按回车键继续..." -r
    done
}

# 启动脚本
main
