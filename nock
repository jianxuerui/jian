#!/bin/bash
# -*- coding: UTF-8 -*-
# Nockchain内存优化完全解决方案 v5.0

# 颜色定义
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RESET='\033[0m'

# 路径配置
INSTALL_PREFIX="$HOME/.local"
NOCKCHAIN_DIR="$HOME/nockchain"
LOG_FILE="$HOME/nockchain_install.log"
BACKUP_DIR="$HOME/nockchain_backup"
SWAP_FILE="/tmp/nockchain_swap"

# 内存优化环境变量
export PATH="$INSTALL_PREFIX/bin:$HOME/.cargo/bin:$PATH"
export RUST_MIN_STACK=16777216  # 16MB栈空间
export RUST_LOG=error           # 减少日志内存使用
export RUST_BACKTRACE=0         # 禁用回溯减少内存
export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1"
export CARGO_BUILD_JOBS=1       # 强制单线程编译
export MALLOC_ARENA_MAX=2       # 限制内存分配器

# 消息输出函数
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${RESET}"
}

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

check_command() {
    command -v "$1" >/dev/null 2>&1
}

# 显示主菜单
show_menu() {
    clear
    echo -e "${BLUE}
=======================================
 Nockchain 内存优化完全解决方案 v5.0
=======================================
${RESET}"
    echo -e "${YELLOW}1. 内存优化完整安装（彻底解决编译问题）"
    echo "2. 配置挖矿公钥"
    echo "3. 启动优化挖矿"
    echo "4. 查看实时日志"
    echo "5. 检查钱包余额"
    echo "6. 系统内存监控"
    echo "7. 备份钱包密钥"
    echo "8. 内存问题诊断修复"
    echo "9. 退出脚本"
    echo -e "${BLUE}=======================================${RESET}"
}

# 检查并创建swap空间
setup_swap_space() {
    print_message "$CYAN" "正在检查并优化虚拟内存..."
    
    local total_ram=$(free -m | awk '/^Mem:/{print $2}')
    local current_swap=$(free -m | awk '/^Swap:/{print $2}')
    local recommended_swap=$((total_ram * 2))
    
    print_message "$YELLOW" "内存状态："
    print_message "$YELLOW" "- 物理内存: ${total_ram}MB"
    print_message "$YELLOW" "- 当前Swap: ${current_swap}MB"
    print_message "$YELLOW" "- 推荐Swap: ${recommended_swap}MB"
    
    if [ "$current_swap" -lt "$recommended_swap" ]; then
        print_message "$CYAN" "创建临时swap文件以确保编译成功..."
        
        local swap_size=$((recommended_swap - current_swap))
        if [ "$swap_size" -gt 16384 ]; then
            swap_size=16384  # 最大16GB临时swap
        fi
        
        # 创建swap文件
        if ! sudo dd if=/dev/zero of="$SWAP_FILE" bs=1M count="$swap_size" 2>/dev/null; then
            print_message "$YELLOW" "无法创建swap文件，将在低内存模式下编译"
            return 1
        fi
        
        sudo chmod 600 "$SWAP_FILE"
        sudo mkswap "$SWAP_FILE" >/dev/null 2>&1
        sudo swapon "$SWAP_FILE" >/dev/null 2>&1
        
        print_message "$GREEN" "临时swap空间创建成功: ${swap_size}MB"
        log_message "创建临时swap: ${swap_size}MB"
    fi
}

# 清理swap空间
cleanup_swap() {
    if [ -f "$SWAP_FILE" ]; then
        print_message "$CYAN" "清理临时swap空间..."
        sudo swapoff "$SWAP_FILE" 2>/dev/null
        sudo rm -f "$SWAP_FILE" 2>/dev/null
        print_message "$GREEN" "临时swap空间已清理"
    fi
}

# 内存优化系统配置
optimize_system_memory() {
    print_message "$CYAN" "正在优化系统内存配置..."
    
    # 设置内存过量分配策略
    echo 1 | sudo tee /proc/sys/vm/overcommit_memory >/dev/null 2>&1
    echo 80 | sudo tee /proc/sys/vm/overcommit_ratio >/dev/null 2>&1
    
    # 优化swap使用策略
    echo 10 | sudo tee /proc/sys/vm/swappiness >/dev/null 2>&1
    
    # 增加文件描述符限制
    ulimit -n 65536 2>/dev/null
    
    # 设置进程内存限制
    ulimit -v unlimited 2>/dev/null
    
    print_message "$GREEN" "系统内存配置优化完成"
}

# 安装Miniconda（内存优化版）
install_miniconda_optimized() {
    print_message "$CYAN" "正在安装内存优化版Miniconda..."
    
    if check_command "conda"; then
        print_message "$GREEN" "Miniconda已安装"
        return 0
    fi
    
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "不支持的架构: $arch"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_installer.sh"
    
    # 使用内存优化的下载方式
    if ! wget -q --show-progress --limit-rate=1m "$MINICONDA_URL" -O "$installer"; then
        print_message "$RED" "Miniconda下载失败"
        return 1
    fi
    
    chmod +x "$installer"
    
    # 静默安装，减少内存使用
    if ! bash "$installer" -b -p "$HOME/.miniconda3" -s; then
        print_message "$RED" "Miniconda安装失败"
        return 1
    fi
    
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda config --set auto_activate_base false
    conda config --set channel_priority strict
    
    export PATH="$HOME/.miniconda3/bin:$PATH"
    rm -f "$installer"
    
    print_message "$GREEN" "Miniconda内存优化版安装完成"
}

# 安装编译工具（超低内存模式）
install_build_tools_low_memory() {
    print_message "$CYAN" "正在安装编译工具（超低内存模式）..."
    
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    
    # 创建最小化编译环境
    conda create -n nockchain-minimal -y python=3.9 --no-default-packages
    conda activate nockchain-minimal
    
    # 逐个安装工具，避免内存峰值
    local tools=("gcc_linux-64" "make" "clang" "pkg-config" "openssl")
    
    for tool in "${tools[@]}"; do
        print_message "$YELLOW" "安装 $tool..."
        conda install -y "$tool" -c conda-forge --no-deps --quiet || {
            print_message "$YELLOW" "跳过 $tool"
        }
        sleep 2  # 给内存回收时间
    done
    
    print_message "$GREEN" "编译工具安装完成"
}

# 内存优化的Rust安装
install_rust_low_memory() {
    print_message "$CYAN" "正在安装Rust工具链（内存优化）..."
    
    if check_command "rustc"; then
        print_message "$YELLOW" "Rust已安装: $(rustc --version)"
        return 0
    fi
    
    # 设置内存友好的安装选项
    export RUSTUP_INIT_SKIP_PATH_CHECK=yes
    
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
        --default-toolchain stable \
        --profile minimal \
        --no-modify-path
    
    source "$HOME/.cargo/env"
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 配置Cargo使用单线程
    mkdir -p "$HOME/.cargo"
    cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[profile.dev]
debug = false
opt-level = 1

[profile.release]
debug = false
lto = false
codegen-units = 1
EOF
    
    print_message "$GREEN" "Rust内存优化版安装完成"
}

# 超低内存编译Nockchain
compile_nockchain_low_memory() {
    print_message "$MAGENTA" "开始超低内存模式编译Nockchain..."
    
    cd "$NOCKCHAIN_DIR" || return 1
    
    # 设置最严格的内存控制
    export RUST_MIN_STACK=16777216      # 16MB
    export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1 -C incremental=false"
    export CARGO_BUILD_JOBS=1
    export CARGO_INCREMENTAL=0
    export RUST_LOG=error
    export RUST_BACKTRACE=0
    
    # 激活conda环境
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda activate nockchain-minimal
    
    print_message "$CYAN" "步骤1: 清理之前的编译缓存..."
    rm -rf target/ || true
    cargo clean || true
    
    print_message "$CYAN" "步骤2: 编译hoonc（单线程模式）..."
    
    # 创建内存监控脚本
    cat > memory_monitor.sh << 'EOF'
#!/bin/bash
while true; do
    mem_usage=$(free -m | awk '/^Mem:/{print $3}')
    if [ "$mem_usage" -gt 6144 ]; then  # 如果超过6GB
        echo "$(date): 内存使用过高: ${mem_usage}MB" >> memory_warning.log
    fi
    sleep 30
done
EOF
    chmod +x memory_monitor.sh
    ./memory_monitor.sh &
    monitor_pid=$!
    
    # 分步骤编译，每步之间清理内存
    if ! timeout 3600 make install-hoonc; then
        kill $monitor_pid 2>/dev/null
        print_message "$RED" "hoonc编译失败，尝试备用方案..."
        
        # 备用编译方案：手动编译
        print_message "$CYAN" "使用手动编译方案..."
        cd crates/hoonc
        
        # 逐个编译依赖
        cargo build --release --bin hoonc --jobs 1 || {
            print_message "$RED" "手动编译也失败"
            return 1
        }
        
        # 手动安装
        cp target/release/hoonc "$HOME/.cargo/bin/"
        cd ../..
    fi
    
    kill $monitor_pid 2>/dev/null
    
    print_message "$CYAN" "步骤3: 编译主项目..."
    sleep 5  # 让内存稳定
    
    if ! timeout 3600 make build; then
        print_message "$RED" "主项目编译失败"
        return 1
    fi
    
    print_message "$CYAN" "步骤4: 安装钱包..."
    if ! make install-nockchain-wallet; then
        print_message "$YELLOW" "钱包安装失败，但可以继续"
    fi
    
    print_message "$CYAN" "步骤5: 安装主程序..."
    if ! make install-nockchain; then
        print_message "$YELLOW" "主程序安装失败，但编译已完成"
    fi
    
    print_message "$GREEN" "Nockchain编译完成！"
}

# 主安装函数（内存优化版）
install_nockchain_memory_optimized() {
    print_message "$GREEN" ">>> 开始Nockchain内存优化完整安装..."
    log_message "开始内存优化安装"
    
    # 检查系统资源
    local total_ram=$(free -m | awk '/^Mem:/{print $2}')
    local available_space=$(df -m ~ | awk 'NR==2{print $4}')
    
    print_message "$YELLOW" "系统配置检查："
    print_message "$YELLOW" "- 物理内存: ${total_ram}MB"
    print_message "$YELLOW" "- 可用空间: ${available_space}MB"
    
    if [ "$total_ram" -lt 2048 ]; then
        print_message "$RED" "错误：系统内存不足2GB，无法安全编译"
        return 1
    fi
    
    if [ "$available_space" -lt 10240 ]; then
        print_message "$RED" "错误：磁盘空间不足10GB"
        return 1
    fi
    
    # 步骤1: 设置虚拟内存
    print_message "$MAGENTA" "步骤 1/7: 设置虚拟内存..."
    setup_swap_space
    
    # 步骤2: 优化系统内存配置
    print_message "$MAGENTA" "步骤 2/7: 优化系统内存配置..."
    optimize_system_memory
    
    # 步骤3: 安装Miniconda
    print_message "$MAGENTA" "步骤 3/7: 安装环境管理器..."
    if ! install_miniconda_optimized; then
        print_message "$RED" "环境管理器安装失败"
        cleanup_swap
        return 1
    fi
    
    # 步骤4: 安装编译工具
    print_message "$MAGENTA" "步骤 4/7: 安装编译工具..."
    if ! install_build_tools_low_memory; then
        print_message "$RED" "编译工具安装失败"
        cleanup_swap
        return 1
    fi
    
    # 步骤5: 安装Rust
    print_message "$MAGENTA" "步骤 5/7: 安装Rust工具链..."
    if ! install_rust_low_memory; then
        print_message "$RED" "Rust安装失败"
        cleanup_swap
        return 1
    fi
    
    # 步骤6: 克隆项目
    print_message "$MAGENTA" "步骤 6/7: 克隆Nockchain项目..."
    if [ -d "$NOCKCHAIN_DIR" ]; then
        print_message "$YELLOW" "发现现有安装，正在更新..."
        cd "$NOCKCHAIN_DIR"
        git pull origin main || {
            cd "$HOME"
            rm -rf "$NOCKCHAIN_DIR"
            git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR"
        }
    else
        git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR" || {
            print_message "$RED" "项目克隆失败"
            cleanup_swap
            return 1
        }
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 配置环境文件
    if [ -f ".env_example" ]; then
        cp .env_example .env
    else
        cat > .env << 'EOF'
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000
NETWORK=mainnet
MAX_PEERS=2000
LOG_LEVEL=error
RUST_LOG=error
RUST_MIN_STACK=16777216
EOF
    fi
    
    # 步骤7: 编译项目
    print_message "$MAGENTA" "步骤 7/7: 编译项目（可能需要1-2小时）..."
    if ! compile_nockchain_low_memory; then
        print_message "$RED" "项目编译失败"
        cleanup_swap
        return 1
    fi
    
    # 生成钱包（如果可能）
    if check_command "nockchain-wallet"; then
        print_message "$CYAN" "正在生成钱包..."
        local wallet_output
        wallet_output=$(nockchain-wallet keygen 2>&1)
        
        if [ $? -eq 0 ]; then
            print_message "$GREEN" "钱包生成成功！"
            echo "$wallet_output"
            
            local pubkey=$(echo "$wallet_output" | grep -E "Public key:|公钥:" | awk '{print $NF}')
            if [ -n "$pubkey" ]; then
                sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$pubkey/" .env
                print_message "$GREEN" "公钥已配置: $pubkey"
            fi
            
            mkdir -p "$BACKUP_DIR"
            echo "$wallet_output" > "$BACKUP_DIR/wallet_$(date +%Y%m%d_%H%M%S).txt"
        fi
    fi
    
    # 创建启动脚本
    cat > "$HOME/start_nockchain.sh" << 'EOF'
#!/bin/bash
# Nockchain启动脚本（内存优化版）
source "$HOME/.miniconda3/etc/profile.d/conda.sh"
conda activate nockchain-minimal
export RUST_MIN_STACK=16777216
export RUST_LOG=error
export PATH="$HOME/.cargo/bin:$PATH"
cd "$HOME/nockchain"
echo "启动Nockchain挖矿节点..."
make run-nockchain
EOF
    chmod +x "$HOME/start_nockchain.sh"
    
    # 清理临时文件
    cleanup_swap
    
    print_message "$GREEN" "🎉 Nockchain内存优化安装完成！"
    print_message "$YELLOW" "安装路径: $NOCKCHAIN_DIR"
    print_message "$YELLOW" "启动脚本: $HOME/start_nockchain.sh"
    print_message "$CYAN" "所有内存问题已彻底解决！"
    
    log_message "内存优化安装完成"
}

# 验证公钥格式
validate_pubkey() {
    local pubkey=$1
    if [[ $pubkey =~ ^[0-9a-fA-F]{128}$ ]] || [[ $pubkey =~ ^[1-9A-HJ-NP-Za-km-z]{40,50}$ ]]; then
        return 0
    else
        print_message "$RED" "错误：公钥格式无效"
        return 1
    fi
}

# 配置挖矿公钥
configure_mining_key() {
    print_message "$CYAN" ">>> 配置挖矿公钥"
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到配置文件"
        return 1
    fi
    
    local current_key=$(grep "MINING_PUBKEY" "$NOCKCHAIN_DIR/.env" | cut -d'=' -f2)
    print_message "$YELLOW" "当前公钥: $current_key"
    
    read -p "请输入新的挖矿公钥: " new_pubkey
    
    if [ -n "$new_pubkey" ] && validate_pubkey "$new_pubkey"; then
        cd "$NOCKCHAIN_DIR"
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" .env
        print_message "$GREEN" "公钥更新成功！"
    fi
}

# 启动挖矿（内存优化版）
start_mining_optimized() {
    print_message "$GREEN" ">>> 启动内存优化挖矿节点..."
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到安装"
        return 1
    fi
    
    # 检查现有进程
    if screen -list | grep -q "nockchain"; then
        print_message "$YELLOW" "检测到挖矿进程正在运行"
        read -p "是否重启？(y/N): " restart
        if [[ "$restart" =~ ^[Yy]$ ]]; then
            screen -S nockchain -X quit
            sleep 3
        else
            return 0
        fi
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 设置内存优化环境
    export RUST_MIN_STACK=16777216
    export RUST_LOG=error
    export MALLOC_ARENA_MAX=2
    
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda activate nockchain-minimal
    
    print_message "$CYAN" "正在启动挖矿节点..."
    
    # 在screen中启动
    screen -dmS nockchain bash -c "
        source '$HOME/.miniconda3/etc/profile.d/conda.sh'
        conda activate nockchain-minimal
        cd '$NOCKCHAIN_DIR'
        export RUST_MIN_STACK=16777216
        export RUST_LOG=error
        export MALLOC_ARENA_MAX=2
        source .env
        echo '=== Nockchain 内存优化挖矿 ===' > logs/mining.log
        echo '启动时间: \$(date)' >> logs/mining.log
        echo '内存模式: 超低内存优化' >> logs/mining.log
        echo '==========================' >> logs/mining.log
        make run-nockchain 2>&1 | tee -a logs/mining.log
    "
    
    sleep 5
    
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "🚀 挖矿节点启动成功！"
        print_message "$CYAN" "- 查看状态: screen -r nockchain"
        print_message "$CYAN" "- 停止挖矿: screen -S nockchain -X quit"
    else
        print_message "$RED" "启动失败"
    fi
}

# 查看日志
view_logs() {
    print_message "$GREEN" ">>> 显示挖矿日志"
    
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        tail -f "$NOCKCHAIN_DIR/logs/mining.log"
    else
        if screen -list | grep -q "nockchain"; then
            screen -r nockchain
        else
            print_message "$RED" "未找到日志文件或运行进程"
        fi
    fi
}

# 检查余额
check_balance() {
    print_message "$GREEN" ">>> 检查钱包余额"
    
    source "$HOME/.miniconda3/etc/profile.d/conda.sh"
    conda activate nockchain-minimal
    
    cd "$NOCKCHAIN_DIR"
    local pubkey=$(grep "MINING_PUBKEY" .env | cut -d'=' -f2)
    
    if [ -z "$pubkey" ] || [ "$pubkey" = "0000000000000000000000000000000000000000000000000000000000000000" ]; then
        print_message "$RED" "未配置有效公钥"
        return 1
    fi
    
    print_message "$CYAN" "查询余额: $pubkey"
    
    if check_command "nockchain-wallet"; then
        for socket in ./nockchain*.sock; do
            if [ -S "$socket" ]; then
                nockchain-wallet --nockchain-socket "$socket" list-notes-by-pubkey -p "$pubkey" 2>/dev/null && break
            fi
        done
    fi
}

# 系统内存监控
memory_monitor() {
    print_message "$BLUE" "====== 系统内存监控 ======"
    
    # 内存使用情况
    local mem_info=$(free -h | awk '/^Mem:/{print "使用: "$3" / 总计: "$2" ("int($3/$2*100)"%)"}')
    print_message "$YELLOW" "内存状态: $mem_info"
    
    # Swap使用情况
    local swap_info=$(free -h | awk '/^Swap:/{print "使用: "$3" / 总计: "$2}')
    print_message "$YELLOW" "Swap状态: $swap_info"
    
    # 系统负载
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    print_message "$YELLOW" "系统负载: $load_avg"
    
    # 挖矿进程状态
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "挖矿状态: ✅ 正在运行"
        
        # 进程内存使用
        local nock_mem=$(ps aux | grep nockchain | grep -v grep | awk '{sum+=$6} END {print sum/1024}')
        if [ -n "$nock_mem" ]; then
            print_message "$CYAN" "挖矿进程内存: ${nock_mem}MB"
        fi
    else
        print_message "$RED" "挖矿状态: ❌ 未运行"
    fi
    
    # 磁盘空间
    local disk_usage=$(df -h ~ | awk 'NR==2{print $4" 可用"}')
    print_message "$YELLOW" "磁盘空间: $disk_usage"
}

# 备份钱包
backup_wallet() {
    print_message "$GREEN" ">>> 备份钱包密钥"
    
    local backup_file="$BACKUP_DIR/complete_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    mkdir -p "$BACKUP_DIR"
    
    cd "$NOCKCHAIN_DIR"
    
    # 创建备份
    tar -czf "$backup_file" .env logs/ *.txt 2>/dev/null || true
    
    # 备份钱包配置
    if [ -f ".env" ]; then
        cp .env "$BACKUP_DIR/env_$(date +%Y%m%d_%H%M%S).backup"
    fi
    
    print_message "$GREEN" "备份完成: $backup_file"
}

# 内存问题诊断修复
diagnose_memory_issues() {
    print_message "$GREEN" ">>> 内存问题诊断修复"
    
    print_message "$CYAN" "正在检查内存配置..."
    
    # 检查swap
    local swap_total=$(free -m | awk '/^Swap:/{print $2}')
    local mem_total=$(free -m | awk '/^Mem:/{print $2}')
    
    print_message "$YELLOW" "诊断结果："
    print_message "$YELLOW" "- 物理内存: ${mem_total}MB"
    print_message "$YELLOW" "- 虚拟内存: ${swap_total}MB"
    
    if [ "$swap_total" -lt "$((mem_total * 2))" ]; then
        print_message "$RED" "问题：虚拟内存不足"
        read -p "是否创建临时swap空间？(Y/n): " create_swap
        if [[ ! "$create_swap" =~ ^[Nn]$ ]]; then
            setup_swap_space
        fi
    fi
    
    # 检查编译配置
    if [ -f "$HOME/.cargo/config.toml" ]; then
        if grep -q "jobs = 1" "$HOME/.cargo/config.toml"; then
            print_message "$GREEN" "✅ Cargo已配置单线程编译"
        else
            print_message "$YELLOW" "⚠️  Cargo未配置单线程编译"
        fi
    else
        print_message "$RED" "❌ Cargo配置文件不存在"
        print_message "$CYAN" "正在创建优化配置..."
        mkdir -p "$HOME/.cargo"
        cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[profile.dev]
debug = false
opt-level = 1
EOF
        print_message "$GREEN" "Cargo配置已优化"
    fi
    
    # 检查环境变量
    local issues=()
    
    if [ -z "$RUST_MIN_STACK" ] || [ "$RUST_MIN_STACK" -lt 16777216 ]; then
        issues+=("RUST_MIN_STACK未设置或过小")
    fi
    
    if [ "$RUSTFLAGS" != *"debuginfo=0"* ]; then
        issues+=("RUSTFLAGS未优化")
    fi
    
    if [ ${#issues[@]} -gt 0 ]; then
        print_message "$YELLOW" "发现配置问题："
        for issue in "${issues[@]}"; do
            print_message "$RED" "- $issue"
        done
        
        read -p "是否自动修复？(Y/n): " fix_issues
        if [[ ! "$fix_issues" =~ ^[Nn]$ ]]; then
            # 创建环境配置文件
            cat >> "$HOME/.bashrc" << 'EOF'

# Nockchain内存优化配置
export RUST_MIN_STACK=16777216
export RUSTFLAGS="-C debuginfo=0 -C opt-level=1"
export CARGO_BUILD_JOBS=1
export RUST_LOG=error
export MALLOC_ARENA_MAX=2
EOF
            print_message "$GREEN" "配置问题已修复"
            print_message "$YELLOW" "请运行: source ~/.bashrc"
        fi
    else
        print_message "$GREEN" "✅ 所有配置检查通过"
    fi
}

# 清理退出函数
cleanup_on_exit() {
    cleanup_swap
    print_message "$CYAN" "清理完成"
}

# 设置退出清理
trap cleanup_on_exit EXIT

# 主循环
main() {
    if [ "$EUID" -eq 0 ]; then
        print_message "$RED" "请不要以root用户运行"
        exit 1
    fi
    
    mkdir -p "$BACKUP_DIR"
    touch "$LOG_FILE"
    log_message "内存优化脚本启动 v5.0"
    
    while true; do
        show_menu
        read -p "请输入选项编号（1-9）: " choice
        
        case $choice in
            1) install_nockchain_memory_optimized ;;
            2) configure_mining_key ;;
            3) start_mining_optimized ;;
            4) view_logs ;;
            5) check_balance ;;
            6) memory_monitor ;;
            7) backup_wallet ;;
            8) diagnose_memory_issues ;;
            9)
                print_message "$GREEN" "感谢使用Nockchain内存优化解决方案！"
                cleanup_on_exit
                exit 0
                ;;
            *)
                print_message "$RED" "无效选项"
                ;;
        esac
        
        echo
        read -p "按回车键继续..." -r
    done
}

# 启动程序
main
