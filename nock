#!/bin/bash

# Nockchain 节点管理脚本 - 修复 dpkg 中断错误版
# 版本：10.0 解决 dpkg 中断和配置错误专版
# 主要修复：dpkg 中断错误、包配置失败、锁文件冲突、数据库损坏

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 配置常量
NOCKCHAIN_REPO="https://github.com/zorp-corp/nockchain.git"
ENV_FILE=".env"
ENV_EXAMPLE=".env_example"
LOG_FILE="nockchain.log"
BACKUP_DIR="backups"

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${CYAN}[DEBUG]${NC} $1"
}

log_success() {
    echo -e "${PURPLE}[SUCCESS]${NC} $1"
}

# 强化的 dpkg 修复函数
fix_dpkg_issues_comprehensive() {
    log_info "执行全面的 dpkg 问题修复..."
    
    # 第一步：检查并终止相关进程
    log_info "检查正在运行的包管理进程..."
    local apt_processes=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg" | wc -l)
    
    if [ "$apt_processes" -gt 0 ]; then
        log_warn "发现正在运行的包管理进程，准备终止..."
        ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg"
        
        # 获取进程 ID 并优雅终止
        local pids=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg" | awk '{print $2}')
        
        for pid in $pids; do
            if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                log_info "终止进程 PID: $pid"
                sudo kill -TERM "$pid" 2>/dev/null || true
            fi
        done
        
        # 等待优雅终止
        sleep 5
        
        # 强制终止仍在运行的进程
        pids=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg" | awk '{print $2}')
        for pid in $pids; do
            if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                log_warn "强制终止进程 PID: $pid"
                sudo kill -9 "$pid" 2>/dev/null || true
            fi
        done
    fi
    
    # 第二步：清理锁文件
    log_info "清理包管理锁文件..."
    local lock_files=(
        "/var/lib/dpkg/lock"
        "/var/lib/dpkg/lock-frontend"
        "/var/lib/apt/lists/lock"
        "/var/cache/apt/archives/lock"
    )
    
    for lock_file in "${lock_files[@]}"; do
        if [ -f "$lock_file" ]; then
            log_info "删除锁文件: $lock_file"
            sudo rm -f "$lock_file" 2>/dev/null || true
        fi
    done
    
    # 第三步：修复 dpkg 数据库
    log_info "修复 dpkg 数据库和配置..."
    
    # 备份原始配置
    if [ -d "/var/lib/dpkg/info" ]; then
        sudo cp -r /var/lib/dpkg/info /var/lib/dpkg/info.backup.$(date +%Y%m%d_%H%M%S) 2>/dev/null || true
    fi
    
    # 使用多种方法修复 dpkg
    log_info "方法1: 执行 dpkg --configure -a（带超时保护）..."
    timeout 300 sudo dpkg --configure -a 2>/dev/null || {
        log_warn "dpkg --configure -a 超时或失败，尝试其他方法..."
        
        # 方法2: 使用 apt --fix-broken install
        log_info "方法2: 执行 apt --fix-broken install..."
        timeout 300 sudo apt --fix-broken install -y 2>/dev/null || {
            log_warn "apt --fix-broken install 失败，尝试高级修复..."
            
            # 方法3: 高级 dpkg 修复（参考 Stack Overflow 解决方案）
            log_info "方法3: 执行高级 dpkg 修复..."
            sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_silent 2>/dev/null || true
            sudo mkdir -p /var/lib/dpkg/info 2>/dev/null || true
            
            timeout 180 sudo apt-get update 2>/dev/null || true
            timeout 300 sudo apt-get -f install -y 2>/dev/null || true
            
            # 恢复信息目录
            if [ -d "/var/lib/dpkg/info_silent" ]; then
                sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_silent/ 2>/dev/null || true
                sudo rm -rf /var/lib/dpkg/info 2>/dev/null || true
                sudo mv /var/lib/dpkg/info_silent /var/lib/dpkg/info 2>/dev/null || true
            fi
        }
    }
    
    # 第四步：清理和更新包缓存
    log_info "清理和更新包缓存..."
    sudo apt clean 2>/dev/null || true
    sudo apt autoclean 2>/dev/null || true
    
    # 第五步：验证修复结果
    log_info "验证 dpkg 修复结果..."
    if timeout 60 sudo dpkg --configure -a 2>/dev/null; then
        log_success "dpkg 修复成功"
        return 0
    else
        log_warn "dpkg 修复可能未完全成功，但继续执行..."
        return 1
    fi
}

# 增强的安全 apt 命令执行器
safe_apt_command_enhanced() {
    local command="$1"
    local max_retries=5
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        log_info "执行: $command (尝试 $((retry_count + 1))/$max_retries)"
        
        # 设置非交互模式和各种超时选项
        export DEBIAN_FRONTEND=noninteractive
        local timeout_options="-o DPkg::Lock::Timeout=300 -o APT::Acquire::Retries=3 -o APT::Acquire::http::Timeout=30"
        
        # 在执行前先修复可能的 dpkg 问题
        if [ $retry_count -gt 0 ]; then
            fix_dpkg_issues_comprehensive
        fi
        
        local enhanced_command="$command $timeout_options"
        
        if timeout 600 eval "$enhanced_command"; then
            log_success "命令执行成功: $command"
            return 0
        else
            log_warn "命令执行失败，错误代码: $?"
            retry_count=$((retry_count + 1))
            
            if [ $retry_count -lt $max_retries ]; then
                log_info "等待 10 秒后重试..."
                sleep 10
                
                # 执行更深层的修复
                fix_dpkg_issues_comprehensive
                
                # 尝试使用 aptitude 作为备选方案
                if [ $retry_count -eq 3 ] && command -v aptitude &> /dev/null; then
                    log_info "尝试使用 aptitude 作为备选方案..."
                    local aptitude_cmd=$(echo "$command" | sed 's/apt/aptitude/g')
                    if timeout 600 eval "$aptitude_cmd $timeout_options"; then
                        log_success "aptitude 命令执行成功"
                        return 0
                    fi
                fi
            fi
        fi
    done
    
    log_error "命令执行失败，已达到最大重试次数: $command"
    log_error "建议手动执行以下命令："
    log_error "1. sudo dpkg --configure -a"
    log_error "2. sudo apt --fix-broken install"
    log_error "3. sudo apt update"
    log_error "4. 然后重新尝试安装"
    
    return 1
}

# 检查系统资源
check_system_resources_enhanced() {
    log_info "执行系统资源检查..."
    
    local warnings=0
    
    # 检查内存
    local total_mem=$(free -g | awk '/^Mem:/{print $2}')
    local available_mem=$(free -g | awk '/^Mem:/{print $7}')
    
    if [ "$total_mem" -lt 32 ]; then
        log_error "系统内存不足: ${total_mem}GB (最低要求32GB)"
        warnings=$((warnings + 1))
    elif [ "$total_mem" -lt 64 ]; then
        log_warn "系统内存: ${total_mem}GB (推荐64GB+)"
        warnings=$((warnings + 1))
    else
        log_success "系统内存: ${total_mem}GB ✓"
    fi
    
    # 检查磁盘空间
    local disk_space=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
    if [ "$disk_space" -lt 50 ]; then
        log_error "可用磁盘空间不足: ${disk_space}GB (最低要求50GB)"
        warnings=$((warnings + 1))
    else
        log_success "可用磁盘空间: ${disk_space}GB ✓"
    fi
    
    # 检查CPU
    local cpu_cores=$(nproc)
    if [ "$cpu_cores" -lt 4 ]; then
        log_warn "CPU核心数: ${cpu_cores}核 (推荐6核+)"
        warnings=$((warnings + 1))
    else
        log_success "CPU核心数: ${cpu_cores}核 ✓"
    fi
    
    if [ $warnings -gt 0 ]; then
        log_warn "发现 $warnings 个资源警告"
        read -p "是否继续安装？(y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# 安装系统依赖 - 集成强化的 dpkg 修复
install_system_dependencies_enhanced() {
    log_info "开始安装系统依赖..."
    
    # 首先执行全面的 dpkg 修复
    fix_dpkg_issues_comprehensive
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # 更新包列表
        log_info "更新包列表..."
        safe_apt_command_enhanced "sudo apt update"
        
        # 核心编译工具 - 分批安装以减少失败风险
        log_info "安装核心编译工具..."
        local core_packages_1=("build-essential" "cmake" "ninja-build" "pkg-config")
        local core_packages_2=("autoconf" "automake" "libtool" "git")
        local core_packages_3=("curl" "wget" "unzip" "lz4")
        
        safe_apt_command_enhanced "sudo apt install -y ${core_packages_1[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${core_packages_2[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${core_packages_3[*]}"
        
        # LLVM 和 Clang 相关
        log_info "安装 LLVM 和 Clang..."
        local llvm_packages_1=("clang" "clang-tools" "llvm" "llvm-dev")
        local llvm_packages_2=("libclang-dev" "libclang1" "lld")
        local llvm_packages_3=("libc++-dev" "libc++abi-dev")
        
        safe_apt_command_enhanced "sudo apt install -y ${llvm_packages_1[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${llvm_packages_2[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${llvm_packages_3[*]}"
        
        # 系统库
        log_info "安装系统库..."
        local system_packages_1=("libssl-dev" "libffi-dev" "zlib1g-dev" "libbz2-dev")
        local system_packages_2=("libreadline-dev" "libsqlite3-dev" "libncursesw5-dev")
        local system_packages_3=("xz-utils" "tk-dev" "libxml2-dev" "liblzma-dev" "libleveldb-dev")
        
        safe_apt_command_enhanced "sudo apt install -y ${system_packages_1[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${system_packages_2[*]}"
        safe_apt_command_enhanced "sudo apt install -y ${system_packages_3[*]}"
        
        log_success "系统依赖安装完成"
    fi
    
    # 安装 Rust
    if ! command -v rustc &> /dev/null || ! command -v cargo &> /dev/null; then
        log_info "安装 Rust..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
        source $HOME/.cargo/env
        rustup component add rustfmt clippy
        log_success "Rust 安装完成: $(rustc --version)"
    else
        log_info "Rust 已安装: $(rustc --version)"
        rustup update stable
        rustup default stable
    fi
}

# 检查项目根目录
check_project_root() {
    local current_dir=$(pwd)
    log_debug "当前目录: $current_dir"
    
    if [ -f "Cargo.toml" ] || [ -f "Makefile" ]; then
        if [ -f "Cargo.toml" ] && grep -q "nockchain" "Cargo.toml" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        elif [ -f "Makefile" ] && grep -q "nockchain\|hoonc" "Makefile" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        fi
    fi
    
    return 1
}

# 自动查找 nockchain 目录
find_nockchain_directory() {
    log_info "正在查找 nockchain 项目目录..."
    
    local found_dirs=($(find . -maxdepth 3 -name "nockchain*" -type d 2>/dev/null))
    
    if [ ${#found_dirs[@]} -gt 0 ]; then
        for dir in "${found_dirs[@]}"; do
            if [ -f "$dir/Cargo.toml" ] || [ -f "$dir/Makefile" ]; then
                log_success "找到 nockchain 项目目录: $dir"
                cd "$dir"
                return 0
            fi
        done
    fi
    
    return 1
}

# 自动初始化项目
auto_initialize_project() {
    log_warn "未找到 nockchain 项目，将自动初始化..."
    
    read -p "是否自动克隆 nockchain 项目？(y/n): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local target_dir="nockchain_$(date +%Y%m%d_%H%M%S)"
        
        log_info "正在克隆 nockchain 项目到: $target_dir"
        
        if git clone "$NOCKCHAIN_REPO" "$target_dir"; then
            cd "$target_dir"
            log_success "项目克隆成功，已切换到项目目录"
            return 0
        else
            log_error "项目克隆失败"
            return 1
        fi
    else
        log_error "请手动进入 nockchain 项目根目录后重新运行脚本"
        exit 1
    fi
}

# 智能目录检测和初始化
smart_directory_setup() {
    log_info "开始智能目录检测..."
    
    if check_project_root; then
        return 0
    fi
    
    log_warn "当前目录不是 nockchain 项目根目录"
    
    if find_nockchain_directory; then
        if check_project_root; then
            return 0
        fi
    fi
    
    auto_initialize_project
}

# 初始化环境配置
initialize_environment() {
    log_info "初始化环境配置..."
    
    # 设置 Rust 环境
    if [ -f "$HOME/.cargo/env" ]; then
        source "$HOME/.cargo/env"
    fi
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 设置编译优化环境变量
    export RUSTFLAGS="-C target-cpu=native -C opt-level=3"
    export CARGO_NET_RETRY=3
    export CARGO_NET_TIMEOUT=300
    export CARGO_HTTP_TIMEOUT=300
    
    # 设置 LLVM 环境变量
    export LLVM_CONFIG_PATH="/usr/bin/llvm-config"
    export LIBCLANG_PATH="/usr/lib/x86_64-linux-gnu"
    
    # 设置非交互模式
    export DEBIAN_FRONTEND=noninteractive
    
    # 创建环境文件
    if [ ! -f "$ENV_FILE" ]; then
        if [ -f "$ENV_EXAMPLE" ]; then
            cp "$ENV_EXAMPLE" "$ENV_FILE"
            log_success "已从 .env_example 创建 .env 文件"
        else
            log_info "创建默认 .env 文件"
            cat > "$ENV_FILE" << 'EOF'
RUST_LOG=info,nockchain=info,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info
MINIMAL_LOG_FORMAT=true
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
EOF
        fi
    fi
    
    # 创建备份目录
    [ ! -d "$BACKUP_DIR" ] && mkdir -p "$BACKUP_DIR"
    
    log_success "环境初始化完成"
}

# 验证128位16进制挖矿公钥格式
validate_mining_pubkey() {
    local pubkey="$1"
    
    if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
        log_error "无效的挖矿公钥格式"
        log_error "挖矿公钥必须是128位16进制格式（128个十六进制字符）"
        return 1
    fi
    
    return 0
}

# 修复版 hoonc 安装
install_hoonc_fixed() {
    log_info "开始安装 hoonc 编译器..."
    
    # 清理之前的构建产物
    if [ -d "target" ]; then
        log_info "清理之前的构建产物..."
        rm -rf target/
    fi
    
    cargo clean 2>/dev/null || true
    
    # 设置编译环境
    local cpu_cores=$(nproc)
    export CARGO_BUILD_JOBS=$(( cpu_cores / 2 ))
    export CARGO_TARGET_DIR="$(pwd)/target"
    
    log_info "使用 $CARGO_BUILD_JOBS 个并行编译任务"
    
    # 尝试多种方法安装 hoonc
    log_info "方法1: 使用 make install-hoonc..."
    if timeout 1200 make install-hoonc; then
        log_success "hoonc 编译器安装成功（方法1）"
        return 0
    else
        log_warn "方法1失败，尝试方法2..."
        
        if timeout 1800 cargo install --locked --force --path crates/hoonc --bin hoonc; then
            log_success "hoonc 编译器安装成功（方法2）"
            return 0
        else
            log_warn "方法2失败，尝试方法3..."
            
            export RUSTFLAGS="-C opt-level=1"
            if timeout 2400 cargo install --locked --force --path crates/hoonc --bin hoonc; then
                log_success "hoonc 编译器安装成功（方法3）"
                return 0
            else
                log_error "所有方法都失败，hoonc 编译器安装失败"
                return 1
            fi
        fi
    fi
}

# 功能1：完整安装 Nockchain
install_nockchain_complete_fixed() {
    log_info "开始完整安装 Nockchain..."
    
    # 系统检查和优化
    check_system_resources_enhanced
    install_system_dependencies_enhanced
    initialize_environment
    
    # 设置环境
    source $HOME/.cargo/env 2>/dev/null || true
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 显示系统信息
    log_info "系统信息："
    log_info "- Rust: $(rustc --version)"
    log_info "- Cargo: $(cargo --version)"
    log_info "- LLVM: $(llvm-config --version 2>/dev/null || echo 'N/A')"
    log_info "- Clang: $(clang --version | head -1 2>/dev/null || echo 'N/A')"
    
    # 安装 hoonc 编译器
    install_hoonc_fixed || return 1
    
    # 验证 hoonc 安装
    if command -v hoonc &> /dev/null; then
        log_success "hoonc 验证成功: $(command -v hoonc)"
    else
        log_error "hoonc 验证失败"
        return 1
    fi
    
    # 构建项目
    log_info "构建 Nockchain 项目..."
    if timeout 3600 make build; then
        log_success "项目构建成功"
    else
        log_error "项目构建失败"
        return 1
    fi
    
    # 安装组件
    log_info "安装 Nockchain 组件..."
    
    if make install-nockchain-wallet; then
        log_success "Nockchain 钱包安装成功"
    else
        log_error "Nockchain 钱包安装失败"
        return 1
    fi
    
    if make install-nockchain; then
        log_success "Nockchain 节点安装成功"
    else
        log_error "Nockchain 节点安装失败"
        return 1
    fi
    
    # 更新 PATH
    if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' ~/.bashrc; then
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
        log_success "已添加 Cargo bin 目录到 PATH"
    fi
    
    # 生成默认的128位挖矿公钥
    log_info "生成128位16进制挖矿公钥..."
    local hex_pubkey
    if command -v openssl &> /dev/null; then
        hex_pubkey=$(openssl rand -hex 64)
    else
        hex_pubkey=$(xxd -l 64 -p /dev/urandom | tr -d '\n')
    fi
    
    # 更新配置文件
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "${ENV_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$hex_pubkey/" "$ENV_FILE"
        log_success "已生成并设置128位挖矿公钥"
        log_info "挖矿公钥: $hex_pubkey"
    fi
    
    log_success "Nockchain 完整安装成功！"
}

# 功能2：更改挖矿公钥
change_mining_pubkey() {
    log_info "更改挖矿公钥（128位16进制格式）"
    echo
    log_info "请输入128位16进制格式的挖矿公钥（128个十六进制字符）"
    echo
    
    while true; do
        read -p "挖矿公钥 (128位16进制): " new_pubkey
        
        if [ -z "$new_pubkey" ]; then
            log_error "公钥不能为空"
            continue
        fi
        
        if validate_mining_pubkey "$new_pubkey"; then
            if [ -f "$ENV_FILE" ]; then
                cp "$ENV_FILE" "$BACKUP_DIR/.env.backup.$(date +%Y%m%d_%H%M%S)"
                
                if grep -q "MINING_PUBKEY=" "$ENV_FILE"; then
                    sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" "$ENV_FILE"
                else
                    echo "MINING_PUBKEY=$new_pubkey" >> "$ENV_FILE"
                fi
                
                log_success "挖矿公钥已更新"
                log_info "新公钥: $new_pubkey"
                break
            else
                log_error ".env 文件不存在，请先运行安装选项"
                break
            fi
        else
            log_error "请输入正确格式的128位16进制公钥"
        fi
    done
}

# 功能3：启动节点
start_node() {
    log_info "启动 Nockchain 挖矿节点"
    
    if ! command -v nockchain &> /dev/null; then
        log_error "nockchain 未安装，请先运行安装选项"
        return 1
    fi
    
    if [ ! -f "$ENV_FILE" ]; then
        log_error ".env 文件不存在，请先运行安装选项"
        return 1
    fi
    
    source "$ENV_FILE"
    export RUST_LOG MINIMAL_LOG_FORMAT MINING_PUBKEY
    
    if ! validate_mining_pubkey "$MINING_PUBKEY" 2>/dev/null; then
        log_error "当前配置的挖矿公钥格式不正确"
        return 1
    fi
    
    if pgrep -f "nockchain" > /dev/null; then
        local existing_pids=$(pgrep -f nockchain | tr '\n' ' ')
        log_warn "检测到运行中的 Nockchain 进程: $existing_pids"
        
        read -p "是否停止现有进程并重新启动？(y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            pkill -TERM -f nockchain 2>/dev/null || true
            sleep 3
            if pgrep -f nockchain > /dev/null; then
                pkill -KILL -f nockchain 2>/dev/null || true
                sleep 2
            fi
            log_info "现有进程已停止"
        else
            return 0
        fi
    fi
    
    log_info "配置信息："
    log_info "- 挖矿公钥: $MINING_PUBKEY"
    log_info "- 日志文件: $LOG_FILE"
    
    log_info "正在启动挖矿节点..."
    
    nohup nockchain --mining-pubkey "${MINING_PUBKEY}" --mine > "$LOG_FILE" 2>&1 &
    local node_pid=$!
    
    sleep 5
    
    if kill -0 $node_pid 2>/dev/null; then
        log_success "节点启动成功！进程ID: $node_pid"
        
        if [ -f "$LOG_FILE" ]; then
            log_info "最近几行日志："
            tail -n 5 "$LOG_FILE" 2>/dev/null || true
        fi
    else
        log_error "节点启动失败"
        if [ -f "$LOG_FILE" ]; then
            tail -n 10 "$LOG_FILE"
        fi
        return 1
    fi
}

# 功能4：查看日志
view_logs() {
    log_info "查看 Nockchain 节点日志"
    
    if [ ! -f "$LOG_FILE" ]; then
        log_warn "日志文件不存在: $LOG_FILE"
        return 1
    fi
    
    echo
    log_info "=== 日志文件信息 ==="
    echo "文件位置: $(realpath $LOG_FILE)"
    echo "文件大小: $(du -h "$LOG_FILE" | cut -f1)"
    
    echo
    log_info "=== 最近50行日志 ==="
    tail -n 50 "$LOG_FILE"
    
    echo
    log_info "=== 实时日志监控 ==="
    log_info "按 Ctrl+C 退出监控"
    tail -f "$LOG_FILE"
}

# 主菜单显示
show_main_menu() {
    clear
    echo -e "${PURPLE}"
    echo "╔════════════════════════════════════════════════════════════════╗"
    echo "║                 Nockchain 节点管理工具                        ║"
    echo "║            （修复 dpkg 中断错误版 v10.0）                     ║"
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    echo
    echo -e "${GREEN}🔧 核心功能菜单${NC}"
    echo "────────────────────────────────────────────────────────────────"
    echo "  1. 安装 Nockchain（修复 dpkg 中断问题版）"
    echo "  2. 更改挖矿公钥（128位16进制格式）"
    echo "  3. 启动挖矿节点"
    echo "  4. 查看节点日志"
    echo
    echo "  0. 退出"
    echo
    echo -e "${YELLOW}🔨 修复改进点：${NC}"
    echo -e "${YELLOW}• 强化 dpkg 中断错误处理和自动修复${NC}"
    echo -e "${YELLOW}• 多层次包管理修复策略和超时保护${NC}"
    echo -e "${YELLOW}• 智能进程冲突检测和锁文件清理${NC}"
    echo -e "${YELLOW}• 分批安装依赖减少单点失败风险${NC}"
    echo -e "${YELLOW}• 集成 aptitude 备选方案和高级修复${NC}"
    echo
    
    # 显示当前状态
    if [ -f "$ENV_FILE" ]; then
        local current_pubkey=$(grep "MINING_PUBKEY=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$current_pubkey" ] && [ "$current_pubkey" != "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" ]; then
            echo -e "${CYAN}📍 当前挖矿公钥: ${current_pubkey:0:20}...${current_pubkey: -20}${NC}"
        else
            echo -e "${CYAN}📍 当前挖矿公钥: 未设置或使用默认值${NC}"
        fi
    fi
    
    if pgrep -f "nockchain" > /dev/null; then
        echo -e "${CYAN}📍 节点状态: ✅ 运行中 (PID: $(pgrep -f nockchain | tr '\n' ' '))${NC}"
    else
        echo -e "${CYAN}📍 节点状态: ❌ 未运行${NC}"
    fi
    echo
}

# 主程序
main() {
    log_info "Nockchain 节点管理工具启动中..."
    
    # 启动时立即修复可能的 dpkg 问题
    fix_dpkg_issues_comprehensive
    
    if ! smart_directory_setup; then
        log_error "无法初始化项目环境"
        exit 1
    fi
    
    # 主循环
    while true; do
        show_main_menu
        read -p "请选择操作 (0-4): " choice
        
        case $choice in
            1)
                install_nockchain_complete_fixed
                read -p "按回车键继续..."
                ;;
            2)
                change_mining_pubkey
                read -p "按回车键继续..."
                ;;
            3)
                start_node
                read -p "按回车键继续..."
                ;;
            4)
                view_logs
                ;;
            0)
                log_info "感谢使用 Nockchain 节点管理工具！"
                exit 0
                ;;
            *)
                log_error "无效选择，请输入 0-4 之间的数字"
                sleep 2
                ;;
        esac
    done
}

# 脚本入口
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    set -eE
    trap 'log_error "脚本在第 $LINENO 行出错"' ERR
    main "$@"
fi
