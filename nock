#!/bin/bash

# ========= è‰²å½©å®šä¹‰ =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= é¡¹ç›®è·¯å¾„ =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= æ¨ªå¹… =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain å®‰è£…åŠ©æ‰‹ / Setup Tool"
  echo "==============================================="
  echo -e "${RESET}"
  echo "ğŸ“Œ ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº«"
  echo "ğŸ”— Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "ğŸ¦ Twitter:  https://x.com/BtcK241918"
  echo "-----------------------------------------------"
  echo ""
  echo "âœ¨ ä¼˜åŒ–æŒ–çŸ¿: é…ç½®çº¿ç¨‹åˆ©ç”¨, æ¨èä½¿ç”¨ Systemd å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯ âœ¨"
  echo ""
}

# ========= å¸¸ç”¨å‡½æ•° =========

# åˆ‡æ¢åˆ°é¡¹ç›®ç›®å½•
function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || { echo -e "${RED}[-] é”™è¯¯: æ— æ³•è¿›å…¥é¡¹ç›®ç›®å½•: $NCK_DIR${RESET}"; exit 1; }
  else
    echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
    exit 1
  fi
}

# æ£€æŸ¥å¹¶ç¡®è®¤ MINING_PUBKEY æ˜¯å¦å·²è®¾ç½®
function check_pubkey() {
  echo -e "[*] æ£€æŸ¥ MINING_PUBKEY é…ç½®..."
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] é”™è¯¯ï¼š.env æ–‡ä»¶ä¸å­˜åœ¨: $ENV_FILEã€‚è¯·ä½¿ç”¨é€‰é¡¹ 1 å®‰è£…æˆ–é€‰é¡¹ 3 è®¾ç½®ã€‚${RESET}"
    return 1 # Indicate failure
  fi

  # Source the file safely to get the value
  local temp_pubkey=""
  # Avoid sourcing the whole file directly to prevent potential issues with untrusted content
  # Read line by line or use grep
  while IFS= read -r line; do
      if [[ "$line" =~ ^MINING_PUBKEY= ]]; then
          temp_pubkey="${line#*=}" # Get value after '='
          break
      fi
  done < "$ENV_FILE"

  if [ -z "$temp_pubkey" ]; then
     echo -e "${RED}[-] é”™è¯¯ï¼š.env æ–‡ä»¶ä¸­ MINING_PUBKEY ä¸ºç©ºã€‚è¯·ä½¿ç”¨é€‰é¡¹ 3 è®¾ç½®ã€‚${RESET}"
     return 1 # Indicate failure
  fi
  echo -e "${GREEN}[+] MINING_PUBKEY å·²è®¾ç½®: ${temp_pubkey}${RESET}"
  return 0 # Indicate success
}

# æš‚åœå¹¶è¿”å›èœå•
function pause_and_return() {
  echo ""
  read -n1 -r -p "æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•..." key
  main_menu
}

# æ£€æŸ¥äº’è”ç½‘è¿æ¥
function check_internet() {
  echo -e "[*] æ£€æŸ¥äº’è”ç½‘è¿æ¥..."
  # ä½¿ç”¨ ping æ£€æŸ¥ï¼Œè®¾ç½®è¶…æ—¶å’Œæ¬¡æ•°
  if ping -c 1 -W 3 8.8.8.8 &> /dev/null; then
    echo -e "${GREEN}[+] äº’è”ç½‘è¿æ¥æ­£å¸¸${RESET}"
    return 0
  else
    echo -e "${RED}[-] é”™è¯¯: æ— æ³•è¿æ¥åˆ°äº’è”ç½‘ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè®¾ç½®ã€‚${RESET}"
    return 1
  fi
}

# è¿è¡Œå‘½ä»¤å¹¶è¿›è¡Œé‡è¯•
# Usage: run_with_retries <command> [retries] [delay_seconds]
function run_with_retries() {
  local cmd="$1"
  local retries=${2:-3} # Default 3 retries
  local delay=${3:-10} # Default 10 seconds delay
  local attempt=1

  echo -e "[*] æ‰§è¡Œå‘½ä»¤: ${BOLD}$cmd${RESET}"

  while [ "$attempt" -le $((retries + 1)) ]; do
    echo -e "[*] å°è¯• $attempt/$((retries + 1))..."
    # Use 'eval' to execute the command string correctly, preserving quotes/arguments
    # Redirect stdout/stderr to see progress during retries
    if eval "$cmd"; then
      echo -e "${GREEN}[+] å‘½ä»¤æˆåŠŸ: ${BOLD}$cmd${RESET}"
      return 0 # Success
    else
      local exit_code=$?
      if [ "$attempt" -le "$retries" ]; then
        echo -e "${YELLOW}[-] å°è¯• $attempt/$((retries + 1)) å¤±è´¥ (é€€å‡ºç : $exit_code)ã€‚ç­‰å¾… ${delay}s åé‡è¯•...${RESET}"
        sleep "$delay"
      else
        echo -e "${RED}[-] é”™è¯¯: å‘½ä»¤åœ¨æ‰€æœ‰ $((retries + 1)) æ¬¡å°è¯•åå¤±è´¥: ${BOLD}$cmd${RESET} (é€€å‡ºç : $exit_code)${RESET}"
        return 1 # Failure after all retries
      fi
    fi
    attempt=$((attempt + 1))
  done

  return 1 # Should not reach here, but as a fallback
}


# ========= ä¸»åŠŸèƒ½å‡½æ•° =========

# 1) ä¸€é”®å®‰è£…å¹¶æ„å»º
function setup_all() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¼€å§‹ä¸€é”®å®‰è£…å¹¶æ„å»º...${RESET}"

  # æ£€æŸ¥ç½‘ç»œ
  if ! check_internet; then
    pause_and_return
    return
  fi

  echo -e "[*] å®‰è£…ç³»ç»Ÿä¾èµ–..."
  # --- ä¿®å¤: å°† update å’Œ install å‘½ä»¤ç”¨ && è¿æ¥ï¼Œå¹¶æ·»åŠ é‡è¯• ---
  # Using run_with_retries for apt commands
  if ! run_with_retries "sudo apt update && sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen"; then
    echo -e "${RED}[-] ç³»ç»Ÿä¾èµ–å®‰è£…å¤±è´¥${RESET}"
    pause_and_return
    return
  fi
  # --- ä¿®å¤ç»“æŸ ---
  echo -e "${GREEN}[+] ç³»ç»Ÿä¾èµ–å®‰è£…å®Œæˆ${RESET}"

  echo -e "[*] å®‰è£… Rust..."
  if ! command -v cargo &>/dev/null; then
    # Using run_with_retries for curl | sh
    if ! run_with_retries "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"; then
       echo -e "${RED}[-] Rust å®‰è£…å¤±è´¥${RESET}"
       pause_and_return
       return
    fi
    source "$HOME/.cargo/env"
    RC_FILE="$HOME/.bashrc"
    [[ "$SHELL" == *"zsh"* ]] && RC_FILE="$HOME/.zshrc"
    if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$RC_FILE"; then
      echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$RC_FILE"
      echo -e "${GREEN}[+] Rust PATH æ·»åŠ åˆ° $RC_FILE${RESET}"
    fi
    # Ensure path is updated for the current session
    export PATH="$HOME/.cargo/bin:$PATH"
    echo -e "${GREEN}[+] Rust å®‰è£…å®Œæˆ${RESET}"
  else
      echo -e "${YELLOW}[*] Rust å·²å®‰è£…ï¼Œè·³è¿‡å®‰è£…æ­¥éª¤ã€‚${RESET}"
      source "$HOME/.cargo/env" # Ensure path is sourced
  fi
  echo -e "${GREEN}[+] Rust å®‰è£…/é…ç½®å®Œæˆ${RESET}"


  echo -e "[*] è·å–æˆ–æ›´æ–°ä»“åº“..."
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] é¡¹ç›®ç›®å½•å·²å­˜åœ¨ï¼Œè¿›è¡Œ git pull..."
    cd_nck_dir
    if ! run_with_retries "git pull"; then
        echo -e "${RED}[-] git pull å¤±è´¥${RESET}"
        pause_and_return
        return
    fi
  else
    echo -e "[*] å…‹éš†é¡¹ç›®ä»“åº“..."
    # Using run_with_retries for git clone
    if ! run_with_retries "git clone https://github.com/zorp-corp/nockchain \"$NCK_DIR\""; then
        echo -e "${RED}[-] git clone å¤±è´¥${RESET}"
        pause_and_return
        return
    fi
    cd_nck_dir
  fi
  echo -e "${GREEN}[+] ä»“åº“è·å–å®Œæˆ${RESET}"

  echo -e "[*] è®¾ç½® .env æ–‡ä»¶..."
  if [ ! -f "$ENV_FILE" ]; then
    cp .env_example "$ENV_FILE" || { echo -e "${RED}[-] å¤åˆ¶ .env_example å¤±è´¥${RESET}"; pause_and_return; return; }
    echo -e "${GREEN}[+] .env æ–‡ä»¶åˆ›å»ºå®Œæˆ${RESET}"
  else
    echo -e "${YELLOW}[*] .env æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»ºã€‚${RESET}"
  fi

  # --- ä½¿ç”¨ run_with_retries åŒ…è£…æ‰€æœ‰ make å‘½ä»¤ ---
  echo -e "[*] å®‰è£… hoonc..."
  if ! run_with_retries "make install-hoonc"; then
      echo -e "${RED}[-] install-hoonc å¤±è´¥${RESET}"
      pause_and_return
      return
  fi
  echo -e "${GREEN}[+] hoonc å®‰è£…å®Œæˆ${RESET}"

  echo -e "[*] ç¼–è¯‘ Nockchain..."
  if ! run_with_retries "make build"; then
      echo -e "${RED}[-] build å¤±è´¥${RESET}"
      pause_and_return
      return
  fi
  echo -e "${GREEN}[+] Nockchain ç¼–è¯‘å®Œæˆ${RESET}"

  echo -e "[*] å®‰è£…é’±åŒ…..."
  if ! run_with_retries "make install-nockchain-wallet"; then
      echo -e "${RED}[-] install-nockchain-wallet å¤±è´¥${RESET}"
      pause_and_return
      return
  fi
    # Optional: Verify wallet executable exists
    if [ ! -f "./target/release/nockchain-wallet" ]; then
        echo -e "${RED}[-] è­¦å‘Š: é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå³ä½¿ make install-nockchain-wallet æŠ¥å‘ŠæˆåŠŸã€‚${RESET}"
    fi
  echo -e "${GREEN}[+] é’±åŒ…å®‰è£…å®Œæˆ${RESET}"

  echo -e "[*] å®‰è£…èŠ‚ç‚¹..."
  if ! run_with_retries "make install-nockchain"; then
      echo -e "${RED}[-] install-nockchain å¤±è´¥${RESET}"
      pause_and_return
      return
  fi
    # Optional: Verify node executable exists
    if [ ! -f "./target/release/nockchain" ]; then
        echo -e "${RED}[-] è­¦å‘Š: èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå³ä½¿ make install-nockchain æŠ¥å‘ŠæˆåŠŸã€‚${RESET}"
    fi
  echo -e "${GREEN}[+] èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶å®‰è£…å®Œæˆ${RESET}"
  # --- make å‘½ä»¤åŒ…è£…ç»“æŸ ---

  echo -e "${GREEN}[+] ä¸€é”®å®‰è£…å¹¶æ„å»ºå®Œæˆ${RESET}"
  echo -e "${YELLOW}[!] æ¥ä¸‹æ¥è¯·åŠ¡å¿…æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ä»¥è¿›è¡ŒæŒ–çŸ¿ä¼˜åŒ–å’Œå¯åŠ¨:"
  echo -e "${YELLOW}    1. ç”Ÿæˆé’±åŒ… (é€‰é¡¹ 2)"
  echo -e "${YELLOW}    2. å°†ç”Ÿæˆçš„å…¬é’¥è®¾ç½®åˆ° .env æ–‡ä»¶ (é€‰é¡¹ 3)"
  echo -e "${YELLOW}    3. é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨ (é€‰é¡¹ 8) - å¼ºçƒˆæ¨è!"
  echo -e "${YELLOW}    4. é…ç½® Systemd æœåŠ¡å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯ (é€‰é¡¹ 9) - å¼ºçƒˆæ¨è!"
  echo -e "${YELLOW}    5. å¯åŠ¨ Systemd æœåŠ¡: ${BOLD}sudo systemctl start nockchain-miner${RESET}${YELLOW}"
  echo -e "${YELLOW}    (æˆ–ä½¿ç”¨é€‰é¡¹ 6/7 ä½¿ç”¨ Screen æ–¹å¼ï¼Œä½† Systemd æ›´ç¨³å®šæŒä¹…)${RESET}"

  pause_and_return
}

# 2) ç”Ÿæˆé’±åŒ…
function generate_wallet() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] ç”Ÿæˆé’±åŒ…...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹...è¯·è®°å½•ä¸‹å…¬é’¥ï¼${RESET}"
  # Removed run_with_retries here as this command is usually not network dependent
  ./target/release/nockchain-wallet keygen || { echo -e "${RED}[-] é’±åŒ…ç”Ÿæˆå¤±è´¥${RESET}"; }

  echo -e "${YELLOW}[!] é’±åŒ…ç”Ÿæˆå®Œæˆã€‚è¯·æ‰‹åŠ¨å°†ä¸Šé¢è¾“å‡ºçš„å…¬é’¥å¤åˆ¶ï¼Œå¹¶ä½¿ç”¨é€‰é¡¹ 3 å°†å…¶å†™å…¥ .env æ–‡ä»¶ä¸­çš„ MINING_PUBKEY=${RESET}"
  pause_and_return
}

# 3) è®¾ç½® MINING_PUBKEY åˆ° .env
function set_pubkey_env() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] è®¾ç½® MINING_PUBKEY åˆ° .env...${RESET}"
  cd_nck_dir

  if [ ! -f "$ENV_FILE" ]; then
      echo -e "${RED}[-] .env æ–‡ä»¶ä¸å­˜åœ¨: $ENV_FILEã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  read -p "è¯·è¾“å…¥æ‚¨è¦æŒ–çŸ¿çš„å…¬é’¥ (MINING_PUBKEY): " pubkey
  if [ -z "$pubkey" ]; then
    echo -e "${RED}[-] å…¬é’¥ä¸èƒ½ä¸ºç©ºã€‚${RESET}"
    pause_and_return
    return
  fi

  # ä½¿ç”¨ awk å®‰å…¨åœ°æ›´æ–°æˆ–æ·»åŠ  MINING_PUBKEY
  # å¦‚æœè¡Œå­˜åœ¨ï¼Œæ›¿æ¢å®ƒï¼›å¦åˆ™ï¼Œæ·»åŠ åˆ°æ–‡ä»¶æœ«å°¾
  awk -v pubkey="$pubkey" '
    /^MINING_PUBKEY=/ { $0="MINING_PUBKEY="pubkey; found=1 }
    { print }
    END { if (!found) print "MINING_PUBKEY="pubkey }
  ' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"

  echo -e "${GREEN}[+] å·²å°† MINING_PUBKEY=${pubkey} å†™å…¥ ${ENV_FILE}${RESET}"
  pause_and_return
}

# 4) å¯¼å‡ºé’±åŒ…å¯†é’¥
function export_keys() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯¼å‡ºé’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  ./target/release/nockchain-wallet export-keys || { echo -e "${RED}[-] å¯†é’¥å¯¼å‡ºå¤±è´¥${RESET}"; }

  echo -e "${GREEN}[+] å¯†é’¥å·²å¯¼å‡ºåˆ° keys.export${RESET}"
  echo -e "${YELLOW}[!] è¯·å¦¥å–„ä¿ç®¡ keys.export æ–‡ä»¶ï¼${RESET}"
  pause_and_return
}

# 5) å¯¼å…¥é’±åŒ…å¯†é’¥
function import_keys() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯¼å…¥é’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir

  if [ ! -f "./target/release/nockchain-wallet" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  read -p "[?] è¯·è¾“å…¥å¯†é’¥æ–‡ä»¶è·¯å¾„ (é»˜è®¤: ./keys.export): " keyfile
  keyfile=${keyfile:-"./keys.export"}

  if [ ! -f "$keyfile" ]; then
      echo -e "${RED}[-] å¯†é’¥æ–‡ä»¶ä¸å­˜åœ¨: $keyfile${RESET}"
      pause_and_return
      return
  fi

  ./target/release/nockchain-wallet import-keys --input "$keyfile" || { echo -e "${RED}[-] å¯†é’¥å¯¼å…¥å¤±è´¥${RESET}"; }

  echo -e "${GREEN}[+] å¯†é’¥å·²å¯¼å…¥${RESET}"
  pause_and_return
}

# 8) é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ (ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨)
function configure_miner_script() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨...${RESET}"
  cd_nck_dir

  MINER_SCRIPT="$NCK_DIR/scripts/run_nockchain_miner.sh"
  BACKUP_SCRIPT="$MINER_SCRIPT.bak_$(date +%Y%m%d%H%M%S)"

  if [ ! -f "$MINER_SCRIPT" ]; then
    echo -e "${RED}[-] æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä¸å­˜åœ¨: $MINER_SCRIPT${RESET}"
    echo "è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚"
    pause_and_return
    return
  fi

  echo -e "[*] å¤‡ä»½åŸæœ‰è„šæœ¬åˆ° $BACKUP_SCRIPT"
  cp "$MINER_SCRIPT" "$BACKUP_SCRIPT" || { echo -e "${RED}[-] å¤‡ä»½è„šæœ¬å¤±è´¥${RESET}"; pause_and_return; return; }

  # --- åˆ›å»ºæ–°çš„è„šæœ¬å†…å®¹ ---
  # å‡è®¾ nockchain å¯æ‰§è¡Œæ–‡ä»¶æ”¯æŒ --threads å‚æ•°ã€‚è¯·æ ¹æ®å®é™…æƒ…å†µéªŒè¯æˆ–ä¿®æ”¹ã€‚
  NUM_CORES=$(nproc) # è·å–CPUæ ¸å¿ƒæ•°
  # ä¹Ÿå¯ä»¥é€‰æ‹©ä¿ç•™ä¸€ä¸ªæ ¸å¿ƒç»™ç³»ç»Ÿï¼Œä¾‹å¦‚: NUM_CORES=$(( $(nproc) - 1 ))
  # ç¡®ä¿è‡³å°‘ä½¿ç”¨ä¸€ä¸ªæ ¸å¿ƒ
  if [ "$NUM_CORES" -le 0 ]; then
      NUM_CORES=1
  fi

  echo -e "[*] åˆ›å»ºæ–°çš„ $MINER_SCRIPT å†…å®¹ï¼Œå°†ä½¿ç”¨ ${NUM_CORES} ä¸ªçº¿ç¨‹..."
  # ä½¿ç”¨ heredoc æ¥æ–¹ä¾¿åœ°å†™å…¥å¤šè¡Œè„šæœ¬å†…å®¹
  # ä½¿ç”¨å•å¼•å·é˜»æ­¢heredocå†…çš„å˜é‡è¢«å½“å‰è„šæœ¬å±•å¼€
  cat << 'EOL' > "$MINER_SCRIPT"
#!/bin/bash
# This script was configured by the setup tool to use multiple CPU threads for mining.

# Define the NCK_DIR path explicitly as this script might be run by systemd
# and the user's HOME might not be the standard one.
# It's better to source the .env using its full path relative to NCK_DIR.
# Attempt to determine NCK_DIR based on the script's location
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
NCK_DIR="$(dirname "$SCRIPT_DIR")"
ENV_FILE="$NCK_DIR/.env"

# Source .env file if it exists, needed for MINING_PUBKEY and other potential env vars
if [ -f "$ENV_FILE" ]; then
  source "$ENV_FILE"
fi

# Check if MINING_PUBKEY is set and not empty
if [ -z "$MINING_PUBKEY" ]; then
  echo "é”™è¯¯: MINING_PUBKEY æœªåœ¨ $ENV_FILE ä¸­è®¾ç½®æˆ–ä¸ºç©ºã€‚"
  echo "è¯·ä½¿ç”¨ setup è„šæœ¬çš„é€‰é¡¹ 3 è®¾ç½®å…¬é’¥åå†å¯åŠ¨çŸ¿æœºã€‚"
  exit 1
fi

# Get number of CPU cores - This value is hardcoded during script creation by the setup tool
# Setup tool calculated: NUM_CORES_VALUE
NUM_CORES=NUM_CORES_PLACEHOLDER # Placeholder for the number of cores calculated by the setup script

# Check if the miner executable exists
MINER_EXEC="$NCK_DIR/target/release/nockchain"
if [ ! -f "$MINER_EXEC" ]; then
    echo "é”™è¯¯: çŸ¿æœºå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $MINER_EXEC"
    echo "è¯·å…ˆè¿è¡Œ setup è„šæœ¬çš„é€‰é¡¹ 1 è¿›è¡Œå®‰è£…å’Œæ„å»ºã€‚"
    exit 1
fi

echo "å¯åŠ¨ Nockchain Miner..."
echo "é¡¹ç›®ç›®å½•: $NCK_DIR"
echo "ä½¿ç”¨å…¬é’¥: $MINING_PUBKEY"
echo "ä½¿ç”¨çº¿ç¨‹æ•°: $NUM_CORES"
echo "æŒ–çŸ¿æ—¥å¿—å°†è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º/æ ‡å‡†é”™è¯¯ (å¦‚æœä½¿ç”¨ Systemd æˆ– Screen ç®¡ç†ï¼Œè¯·æŸ¥çœ‹å¯¹åº”æ—¥å¿—)."

# Execute the miner with optimized parameters
# IMPORTANT: Verify '$MINER_EXEC' supports --threads parameter!
# Use exec to replace the current shell process with the miner process
exec "$MINER_EXEC" \
    --chain nockchain_mainnet \
    --miner \
    --mining-pubkey "$MINING_PUBKEY" \
    --threads "$NUM_CORES" # <-- Pass the calculated threads argument

# Note: 'exec' replaces the current shell process. Commands after it are not run
# unless the executed program fails immediately.
EOL
          # --- æ›¿æ¢æ ¸å¿ƒæ•°å ä½ç¬¦ ---
          # Now we use sed to replace the placeholder with the actual calculated value.
          sed -i "s/NUM_CORES_PLACEHOLDER/$NUM_CORES/" "$MINER_SCRIPT"

          # --- ç»“æŸåˆ›å»ºæ–°çš„è„šæœ¬å†…å®¹ ---

          chmod +x "$MINER_SCRIPT" || { echo -e "${RED}[-] è®¾ç½®è„šæœ¬æ‰§è¡Œæƒé™å¤±è´¥${RESET}"; pause_and_return; return; }

          echo -e "${GREEN}[+] æŒ–çŸ¿å¯åŠ¨è„šæœ¬å·²é…ç½®å®Œæˆ ($MINER_SCRIPT)ã€‚${RESET}"
          echo -e "${YELLOW}[!] é‡è¦: æ­¤é…ç½®å‡è®¾ Nockchain èŠ‚ç‚¹ç¨‹åºæ”¯æŒ '--threads' å‚æ•°ã€‚è¯·éªŒè¯ï¼${RESET}"
          echo -e "${YELLOW}[!] æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨é€‰é¡¹ 6 (Screen) æˆ–é€‰é¡¹ 9 (Systemd) å¯åŠ¨çŸ¿æœºã€‚${RESET}"
          pause_and_return
        }


# 9) é…ç½® Systemd æœåŠ¡
function setup_systemd_miner() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] é…ç½® Systemd æœåŠ¡ (æ¨èç”¨äºè‡ªåŠ¨å¯åŠ¨å’Œé‡å¯)...${RESET}"
  cd_nck_dir # ç¡®ä¿åœ¨é¡¹ç›®ç›®å½•

  # æ£€æŸ¥ root æƒé™
  if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}[-] é”™è¯¯: é…ç½® Systemd æœåŠ¡éœ€è¦ root æƒé™ã€‚è¯·ä½¿ç”¨ ${BOLD}sudo $0${RESET}${RED} è¿è¡Œæ­¤è„šæœ¬æˆ–åˆ‡æ¢åˆ° root ç”¨æˆ·å†æ‰§è¡Œæ­¤é€‰é¡¹ã€‚${RESET}"
    pause_and_return
    return
  fi

  echo -e "${YELLOW}[!] å»ºè®®æ‚¨åœ¨é…ç½® Systemd æœåŠ¡å‰ï¼Œå…ˆä½¿ç”¨é€‰é¡¹ 8 é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨ã€‚${RESET}"
  echo -e "${YELLOW}[!] å¹¶ä¸”ç¡®ä¿å·²ä½¿ç”¨é€‰é¡¹ 3 è®¾ç½®äº† MINING_PUBKEYã€‚${RESET}"
  read -p "æ˜¯å¦ç»§ç»­é…ç½® Systemd æœåŠ¡? (y/n): " confirm_systemd
  if [[ ! "$confirm_systemd" =~ ^[Yy]$ ]]; then
     echo -e "${RED}[-] å·²å–æ¶ˆ Systemd é…ç½®ã€‚${RESET}"
     pause_and_return
     return
  fi

  SERVICE_FILE="/etc/systemd/system/nockchain-miner.service"
  USERNAME=$(whoami -u) # è·å–æ‰§è¡Œè„šæœ¬çš„ç”¨æˆ·çš„å®é™…ç”¨æˆ·å

  # --- åˆ›å»º Systemd æœåŠ¡æ–‡ä»¶å†…å®¹ ---
  echo -e "[*] åˆ›å»º Systemd æœåŠ¡æ–‡ä»¶: $SERVICE_FILE"
  # ä½¿ç”¨ heredoc å†™å…¥æœåŠ¡æ–‡ä»¶å†…å®¹
  cat <<EOL > "$SERVICE_FILE"
[Unit]
Description=Nockchain Miner Node
After=network.target

[Service]
User=$USERNAME # ä»¥å½“å‰ç”¨æˆ·èº«ä»½è¿è¡Œ
WorkingDirectory=$NCK_DIR # å·¥ä½œç›®å½•ä¸ºé¡¹ç›®æ ¹ç›®å½•
EnvironmentFile=$ENV_FILE # ä» .env æ–‡ä»¶åŠ è½½ç¯å¢ƒå˜é‡ (ä¾‹å¦‚ MINING_PUBKEY)
ExecStart=$NCK_DIR/scripts/run_nockchain_miner.sh # æ‰§è¡Œé…ç½®å¥½çš„æŒ–çŸ¿å¯åŠ¨è„šæœ¬
Restart=always # å…³é”®: ç¨‹åºé€€å‡ºæ—¶è‡ªåŠ¨é‡å¯
RestartSec=10 # 10ç§’åå°è¯•é‡å¯

# æ¨èçš„æ–‡ä»¶æè¿°ç¬¦å’Œè¿›ç¨‹æ•°é™åˆ¶ï¼Œé¿å…èµ„æºè€—å°½
LimitNOFILE=65536
LimitNPROC=65536

# å°†æ—¥å¿—è¾“å‡ºåˆ° journald
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOL
  # --- ç»“æŸæœåŠ¡æ–‡ä»¶å†…å®¹ ---

  echo -e "[*] é‡è½½ Systemd ç®¡ç†å™¨é…ç½®..."
  if ! systemctl daemon-reload; then
      echo -e "${RED}[-] é‡è½½ Systemd å¤±è´¥${RESET}"
      pause_and_return
      return
  fi

  echo -e "[*] å¯ç”¨ nockchain-miner æœåŠ¡ (è®¾ç½®å¼€æœºè‡ªå¯)..."
  if ! systemctl enable nockchain-miner.service; then
      echo -e "${RED}[-] å¯ç”¨ Systemd æœåŠ¡å¤±è´¥${RESET}"
      pause_and_return
      return
  fi

  echo -e "${GREEN}[+] Systemd æœåŠ¡å·²é…ç½® ($SERVICE_FILE) å¹¶è®¾ä¸ºå¼€æœºè‡ªå¯ã€‚${RESET}"
  echo -e "${YELLOW}[!] æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç®¡ç†æœåŠ¡:${RESET}"
  echo -e "${YELLOW}    å¯åŠ¨çŸ¿æœº: ${BOLD}sudo systemctl start nockchain-miner${RESET}"
  echo -e "${YELLOW}    æ£€æŸ¥çŠ¶æ€: ${BOLD}sudo systemctl status nockchain-miner${RESET}"
  echo -e "${YELLOW}    æŸ¥çœ‹æ—¥å¿—: ${BOLD}sudo journalctl -u nockchain-miner -f${RESET}"
  echo -e "${YELLOW}    åœæ­¢çŸ¿æœº: ${BOLD}sudo systemctl stop nockchain-miner${RESET}"
  echo -e "${YELLOW}    ç¦ç”¨å¼€æœºè‡ªå¯: ${BOLD}sudo systemctl disable nockchain-miner${RESET}"

  pause_and_return
}


# 6) å¯åŠ¨èŠ‚ç‚¹ (Screen åå°)
function start_node_screen() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯åŠ¨èŠ‚ç‚¹ (screen åå°è¿è¡Œ)...${RESET}"
  cd_nck_dir

  # æ£€æŸ¥ MINING_PUBKEY æ˜¯å¦å·²è®¾ç½®
  if ! check_pubkey; then
    pause_and_return
    return # å¦‚æœæ£€æŸ¥å¤±è´¥åˆ™é€€å‡ºå‡½æ•°
  fi

  # ç¡®ä¿å¯åŠ¨è„šæœ¬å­˜åœ¨å¹¶æœ‰æ‰§è¡Œæƒé™
  local MINER_SCRIPT="$NCK_DIR/scripts/run_nockchain_miner.sh"
  if [ ! -f "$MINER_SCRIPT" ]; then
      echo -e "${RED}[-] é”™è¯¯: æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä¸å­˜åœ¨: $MINER_SCRIPT${RESET}"
      echo "è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚"
      pause_and_return
      return
  fi
  # Ensure script is executable. Add a retry just in case of filesystem glitch, though rare.
  if ! run_with_retries "chmod +x \"$MINER_SCRIPT\"" 2 5; then
      echo -e "${RED}[-] è®¾ç½®è„šæœ¬æ‰§è¡Œæƒé™å¤±è´¥${RESET}"
      pause_and_return
      return
  fi


  # æ£€æŸ¥æ—§çš„ screen ä¼šè¯å¹¶å…³é—­
  if screen -list | grep -qw "nockchain"; then
    echo "[*] æ£€æµ‹åˆ°æ—§çš„ 'nockchain' screen ä¼šè¯ï¼Œæ­£åœ¨å…³é—­..."
    # Add a timeout to the screen quit command
    timeout 10s screen -S nockchain -X quit
    # Check if it still exists after timeout
    if screen -list | grep -qw "nockchain"; then
         echo -e "${YELLOW}[-] æ—§çš„ screen ä¼šè¯å¯èƒ½æœªå®Œå…¨å…³é—­ï¼Œå°è¯•å¼ºåˆ¶æ€æ‰...${RESET}"
         screen -wipe # Clean up dead sessions
         # Find the process and kill it if screen -wipe didn't work
         pkill -f "SCREEN -S nockchain"
         sleep 2
         if screen -list | grep -qw "nockchain"; then
             echo -e "${RED}[-] é”™è¯¯: æ— æ³•ç»ˆæ­¢æ—§çš„ screen ä¼šè¯ã€‚è¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit' æˆ– 'pkill -f \"SCREEN -S nockchain\"' å¹¶é‡è¯•ã€‚${RESET}"
             pause_and_return
             return
         fi
    fi
    sleep 2 # Wait for old session to terminate fully
  fi

  echo -e "[*] æ­£åœ¨å¯åŠ¨æ–°çš„ 'nockchain' screen ä¼šè¯..."
  # Use screen -dmS in the background to create a session and execute the command
  # The bash -c command will:
  # 1. cd into NCK_DIR
  # 2. Source the .env file
  # 3. Execute the miner script using 'exec'. 'exec' replaces the bash process
  #    with the miner process, which is good for signal handling (like Ctrl+C if you attach)
  #    and resource usage.
  # Use a retry for the screen command itself, although screen is generally robust.
  # The important script execution is handled within screen.
  if ! run_with_retries "screen -dmS nockchain bash -c \"cd '$NCK_DIR' && source '$ENV_FILE' && exec '$MINER_SCRIPT'\"" 2 5; then
      echo -e "${RED}[-] å¯åŠ¨ screen ä¼šè¯å¤±è´¥ã€‚${RESET}"
      echo "è¯·æ£€æŸ¥ $MINER_SCRIPT è„šæœ¬å†…å®¹æˆ–æƒé™ã€‚"
      pause_and_return
      return
  fi


  sleep 3 # Wait briefly for the session to start
  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] èŠ‚ç‚¹å·²æˆåŠŸå¯åŠ¨åœ¨ 'nockchain' screen ä¼šè¯ä¸­ã€‚${RESET}"
    echo -e "${YELLOW}[!] æ‚¨å¯ä»¥ä½¿ç”¨é€‰é¡¹ 7 æŸ¥çœ‹æ—¥å¿— (æŒ‰ Ctrl+A+D åˆ†ç¦»).${RESET}"
    echo -e "${YELLOW}[!] æ³¨æ„: Screen æ–¹å¼ä¸å¦‚ Systemd (é€‰é¡¹ 9) ç¨³å®šå’ŒæŒä¹…ï¼Œä¸å…·å¤‡è‡ªåŠ¨é‡å¯åŠŸèƒ½ã€‚${RESET}"
  else
    echo -e "${RED}[-] èŠ‚ç‚¹å¯åŠ¨å¤±è´¥ã€‚æœªæ‰¾åˆ°åä¸º 'nockchain' çš„ screen ä¼šè¯ã€‚${RESET}"
    echo "è¯·å°è¯•ä½¿ç”¨é€‰é¡¹ 7 æŸ¥çœ‹æ—¥å¿—ï¼ˆå¦‚æœ screen ä¼šè¯çŸ­æš‚å¯åŠ¨åé€€å‡ºï¼‰ã€‚"
    echo "æ£€æŸ¥ $MINER_SCRIPT è„šæœ¬å†…å®¹ã€æƒé™æˆ–ä¾èµ–æ˜¯å¦æ­£ç¡®ã€‚"
  fi
  pause_and_return
}

# 7) æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—
function view_logs_screen() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—...${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] è¿æ¥åˆ° 'nockchain' screen ä¼šè¯ã€‚æŒ‰ Ctrl+A+D ç»„åˆé”®å¯åˆ†ç¦»ä¼šè¯è¿”å›è„šæœ¬èœå•ï¼Œä¸ä¼šåœæ­¢çŸ¿æœºã€‚${RESET}"
    echo -e "${YELLOW}[!] æŒ‰ Ctrl+C å¯èƒ½ä¼šåœæ­¢çŸ¿æœºï¼è¯·è°¨æ…æ“ä½œã€‚${RESET}"
    # screen -r attempts to resume a session. -d -r can detach from elsewhere and resume here.
    # Add a check if the session is actually attached elsewhere
    if screen -list | grep -q "nockchain[[:space:]]"; then # Check for 'nockchain' followed by space (indicating attached)
        echo -e "${YELLOW}[*] 'nockchain' screen ä¼šè¯å½“å‰å·²è¿æ¥ã€‚å°è¯•é‡æ–°è¿æ¥...${RESET}"
        screen -x nockchain # Connect to already attached session
    else
        screen -r nockchain # Resume detached session
    fi
    # User will return here after detaching from screen session (Ctrl+A+D)
    echo -e "${GREEN}[+] å·²ä» screen ä¼šè¯åˆ†ç¦»ã€‚${RESET}"
  else
    echo -e "${RED}[-] æœªæ‰¾åˆ°åä¸º 'nockchain' çš„ screen ä¼šè¯ã€‚è¯·ç¡®è®¤èŠ‚ç‚¹å·²ä½¿ç”¨é€‰é¡¹ 6 å¯åŠ¨ã€‚${RESET}"
  fi
  pause_and_return
}


# ========= ä¸»èœå• =========
function main_menu() {
  show_banner
  echo "è¯·é€‰æ‹©æ“ä½œ:"
  echo "  1) ä¸€é”®å®‰è£…å¹¶æ„å»º (ç³»ç»Ÿä¾èµ–, Rust, ä»£ç , bin) - æ¨èé¦–å…ˆæ‰§è¡Œ"
  echo "-----------------------------------------------"
  echo "  2) ç”Ÿæˆé’±åŒ… (æŸ¥çœ‹è¾“å‡ºæ—¥å¿—)"
  echo "  3) è®¾ç½® MINING_PUBKEY åˆ° .env (æ‰‹åŠ¨è¾“å…¥) - å¿…é¡»è®¾ç½®!"
  echo "  4) å¯¼å‡ºé’±åŒ…å¯†é’¥"
  echo "  5) å¯¼å…¥é’±åŒ…å¯†é’¥"
  echo "-----------------------------------------------"
  echo "  8) é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ (ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨, æ¨è!)"
  echo "  9) é…ç½® Systemd æœåŠ¡ (æ¨è! å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯)"
  echo "-----------------------------------------------"
  echo "  6) å¯åŠ¨èŠ‚ç‚¹ (Screen åå°è¿è¡Œ, åŸºæœ¬æ–¹å¼)"
  echo "  7) æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—"
  echo "-----------------------------------------------"
  echo "  0) é€€å‡º"
  echo ""
  read -p "è¯·è¾“å…¥ç¼–å·: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node_screen ;; # Screen æ–¹å¼
    7) view_logs_screen ;;  # Screen æ—¥å¿—
    8) configure_miner_script ;; # é…ç½®å¯åŠ¨è„šæœ¬
    9) setup_systemd_miner ;; # Systemd æ–¹å¼
    0) echo -e "${GREEN}é€€å‡ºè„šæœ¬.${RESET}"; exit 0 ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

# ========= è„šæœ¬å…¥å£ =========
# åœ¨å¯åŠ¨ä¸»èœå•å‰åˆ·æ–°ä¸€æ¬¡æ¨ªå¹…
show_banner

# è¿è¡Œä¸»èœå•
main_menu
