#!/bin/bash

# Nockchain 节点管理脚本 - 修复 dpkg lock-frontend 错误版
# 版本：8.0 解决 dpkg 锁文件冲突专版
# 主要修复：dpkg lock-frontend 错误、包管理冲突、锁文件清理

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 配置常量
NOCKCHAIN_REPO="https://github.com/zorp-corp/nockchain.git"
ENV_FILE=".env"
ENV_EXAMPLE=".env_example"
LOG_FILE="nockchain.log"
BACKUP_DIR="backups"

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${CYAN}[DEBUG]${NC} $1"
}

log_success() {
    echo -e "${PURPLE}[SUCCESS]${NC} $1"
}

# 修复 dpkg 锁文件问题
fix_dpkg_lock_issues() {
    log_info "检查并修复 dpkg 锁文件问题..."
    
    # 检查是否存在锁文件冲突
    local lock_files=(
        "/var/lib/dpkg/lock"
        "/var/lib/dpkg/lock-frontend"
        "/var/lib/apt/lists/lock"
        "/var/cache/apt/archives/lock"
    )
    
    local has_lock_issue=false
    
    # 检查是否有正在运行的 apt 进程
    local apt_processes=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg_lock" | wc -l)
    
    if [ "$apt_processes" -gt 0 ]; then
        log_warn "检测到正在运行的包管理进程"
        ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg_lock"
        has_lock_issue=true
    fi
    
    # 检查锁文件是否存在
    for lock_file in "${lock_files[@]}"; do
        if [ -f "$lock_file" ]; then
            log_warn "发现锁文件: $lock_file"
            has_lock_issue=true
        fi
    done
    
    if [ "$has_lock_issue" = true ]; then
        log_warn "发现 dpkg 锁文件问题，开始修复..."
        
        # 尝试优雅地等待进程完成
        log_info "等待 30 秒让进程自然完成..."
        sleep 30
        
        # 再次检查进程
        apt_processes=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg_lock" | wc -l)
        
        if [ "$apt_processes" -gt 0 ]; then
            log_warn "进程仍在运行，准备强制终止..."
            
            # 获取进程 ID 并终止
            local pids=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg_lock" | awk '{print $2}')
            
            for pid in $pids; do
                if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                    log_info "终止进程 PID: $pid"
                    sudo kill -TERM "$pid" 2>/dev/null || true
                fi
            done
            
            # 等待优雅终止
            sleep 5
            
            # 强制终止仍在运行的进程
            pids=$(ps aux | grep -E '(apt|apt-get|dpkg|aptitude)' | grep -v grep | grep -v "fix_dpkg_lock" | awk '{print $2}')
            for pid in $pids; do
                if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                    log_warn "强制终止进程 PID: $pid"
                    sudo kill -9 "$pid" 2>/dev/null || true
                fi
            done
        fi
        
        # 删除锁文件
        log_info "清理锁文件..."
        for lock_file in "${lock_files[@]}"; do
            if [ -f "$lock_file" ]; then
                log_info "删除锁文件: $lock_file"
                sudo rm -f "$lock_file" 2>/dev/null || true
            fi
        done
        
        # 重新配置 dpkg
        log_info "重新配置 dpkg..."
        sudo dpkg --configure -a 2>/dev/null || true
        
        # 清理并更新包缓存
        log_info "清理包缓存..."
        sudo apt clean 2>/dev/null || true
        
        log_success "dpkg 锁文件问题修复完成"
    else
        log_success "没有发现 dpkg 锁文件问题"
    fi
}

# 安全的 apt 命令执行器
safe_apt_command() {
    local command="$1"
    local max_retries=3
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        log_info "执行: $command (尝试 $((retry_count + 1))/$max_retries)"
        
        # 设置非交互模式
        export DEBIAN_FRONTEND=noninteractive
        
        if eval "$command"; then
            log_success "命令执行成功: $command"
            return 0
        else
            log_warn "命令执行失败，检查 dpkg 锁文件..."
            retry_count=$((retry_count + 1))
            
            if [ $retry_count -lt $max_retries ]; then
                fix_dpkg_lock_issues
                sleep 5
            fi
        fi
    done
    
    log_error "命令执行失败，已达到最大重试次数: $command"
    return 1
}

# 检查系统资源 - 修复算术表达式错误
check_system_resources_enhanced() {
    log_info "执行增强系统资源检查..."
    
    # 使用传统方式初始化警告计数器
    local warnings=0
    
    # 检查内存 - 更严格的要求
    local total_mem=$(free -g | awk '/^Mem:/{print $2}')
    local available_mem=$(free -g | awk '/^Mem:/{print $7}')
    
    if [ "$total_mem" -lt 32 ]; then
        log_error "系统内存不足: ${total_mem}GB (最低要求32GB，推荐64GB+)"
        log_error "hoonc 编译需要大量内存，建议升级硬件或使用云服务器"
        warnings=$((warnings + 1))
    elif [ "$total_mem" -lt 64 ]; then
        log_warn "系统内存: ${total_mem}GB (推荐64GB+，可能影响编译速度)"
        warnings=$((warnings + 1))
    else
        log_success "系统内存: ${total_mem}GB ✓"
    fi
    
    if [ "$available_mem" -lt 16 ]; then
        log_warn "可用内存不足: ${available_mem}GB，建议释放内存或重启系统"
        warnings=$((warnings + 1))
    fi
    
    # 检查磁盘空间
    local disk_space=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
    if [ "$disk_space" -lt 50 ]; then
        log_error "可用磁盘空间不足: ${disk_space}GB (最低要求50GB)"
        warnings=$((warnings + 1))
    elif [ "$disk_space" -lt 100 ]; then
        log_warn "可用磁盘空间: ${disk_space}GB (推荐100GB+)"
        warnings=$((warnings + 1))
    else
        log_success "可用磁盘空间: ${disk_space}GB ✓"
    fi
    
    # 检查CPU和负载
    local cpu_cores=$(nproc)
    
    if [ "$cpu_cores" -lt 4 ]; then
        log_warn "CPU核心数: ${cpu_cores}核 (推荐6核+)"
        warnings=$((warnings + 1))
    else
        log_success "CPU核心数: ${cpu_cores}核 ✓"
    fi
    
    # 检查虚拟内存设置
    local swap_total=$(free -g | awk '/^Swap:/{print $2}')
    if [ "$swap_total" -lt 8 ]; then
        log_warn "Swap 空间: ${swap_total}GB (建议至少8GB)"
        warnings=$((warnings + 1))
    fi
    
    if [ $warnings -gt 0 ]; then
        log_warn "发现 $warnings 个资源警告，可能影响编译成功率"
        read -p "是否继续安装？建议在云服务器上运行 (y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "建议使用配置更高的服务器后重试"
            exit 1
        fi
    fi
}

# 优化系统设置
optimize_system_for_compilation() {
    log_info "优化系统设置以提高编译成功率..."
    
    # 启用内存过量分配
    log_info "启用内存过量分配..."
    sudo sysctl -w vm.overcommit_memory=1 2>/dev/null || true
    
    # 调整 OOM killer 设置
    echo 'vm.oom_kill_allocating_task=1' | sudo tee -a /etc/sysctl.conf >/dev/null 2>&1 || true
    
    # 增加文件描述符限制
    ulimit -n 65536 2>/dev/null || true
    
    # 设置更大的栈大小
    ulimit -s 16384 2>/dev/null || true
    
    # 清理系统缓存
    log_info "清理系统缓存..."
    sudo sync 2>/dev/null || true
    sudo echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null 2>&1 || true
    
    log_success "系统优化完成"
}

# 安装系统依赖 - 集成锁文件修复
install_system_dependencies_enhanced() {
    log_info "安装增强系统依赖..."
    
    # 首先修复可能的 dpkg 锁文件问题
    fix_dpkg_lock_issues
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # 更新包列表
        safe_apt_command "sudo apt update"
        safe_apt_command "sudo apt upgrade -y"
        
        # 核心编译工具
        local core_packages=(
            "build-essential" "cmake" "ninja-build"
            "pkg-config" "autoconf" "automake" "libtool"
            "git" "curl" "wget" "unzip" "lz4"
        )
        
        # LLVM 和 Clang 相关
        local llvm_packages=(
            "clang" "clang-tools" "clang-format"
            "llvm" "llvm-dev" "llvm-runtime"
            "libclang-dev" "libclang1" "libclang-common-dev"
            "lld" "libc++-dev" "libc++abi-dev"
        )
        
        # 系统库
        local system_packages=(
            "libssl-dev" "libffi-dev" "zlib1g-dev"
            "libbz2-dev" "libreadline-dev" "libsqlite3-dev"
            "libncursesw5-dev" "xz-utils" "tk-dev"
            "libxml2-dev" "libxmlsec1-dev" "libffi-dev"
            "liblzma-dev" "libleveldb-dev"
        )
        
        # 内存和性能相关
        local perf_packages=(
            "htop" "iotop" "sysstat" "psmisc"
            "linux-tools-common" "linux-tools-generic"
        )
        
        log_info "安装核心编译工具..."
        safe_apt_command "sudo apt install -y ${core_packages[*]}"
        
        log_info "安装 LLVM 和 Clang..."
        safe_apt_command "sudo apt install -y ${llvm_packages[*]}"
        
        log_info "安装系统库..."
        safe_apt_command "sudo apt install -y ${system_packages[*]}"
        
        log_info "安装性能监控工具..."
        safe_apt_command "sudo apt install -y ${perf_packages[*]}"
        
        log_success "系统依赖安装完成"
    fi
    
    # 安装 Rust - 最新稳定版
    if ! command -v rustc &> /dev/null || ! command -v cargo &> /dev/null; then
        log_info "安装 Rust 最新稳定版..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
        source $HOME/.cargo/env
        
        # 安装必要的 Rust 组件
        rustup component add rustfmt clippy
        
        log_success "Rust 安装完成: $(rustc --version)"
    else
        log_info "Rust 已安装: $(rustc --version)"
        
        # 更新到最新版本
        log_info "更新 Rust 到最新版本..."
        rustup update stable
        rustup default stable
    fi
}

# 检查项目根目录
check_project_root() {
    local current_dir=$(pwd)
    log_debug "当前目录: $current_dir"
    
    if [ -f "Cargo.toml" ] || [ -f "Makefile" ]; then
        if [ -f "Cargo.toml" ] && grep -q "nockchain" "Cargo.toml" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        elif [ -f "Makefile" ] && grep -q "nockchain\|hoonc" "Makefile" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        fi
    fi
    
    return 1
}

# 自动查找 nockchain 目录
find_nockchain_directory() {
    log_info "正在查找 nockchain 项目目录..."
    
    local found_dirs=($(find . -maxdepth 3 -name "nockchain*" -type d 2>/dev/null))
    
    if [ ${#found_dirs[@]} -gt 0 ]; then
        for dir in "${found_dirs[@]}"; do
            if [ -f "$dir/Cargo.toml" ] || [ -f "$dir/Makefile" ]; then
                log_success "找到 nockchain 项目目录: $dir"
                cd "$dir"
                return 0
            fi
        done
    fi
    
    local parent_dirs=("../nockchain" "../../nockchain" "~/nockchain")
    for dir in "${parent_dirs[@]}"; do
        if [ -d "$dir" ] && ([ -f "$dir/Cargo.toml" ] || [ -f "$dir/Makefile" ]); then
            log_success "找到 nockchain 项目目录: $dir"
            cd "$dir"
            return 0
        fi
    done
    
    return 1
}

# 自动初始化项目
auto_initialize_project() {
    log_warn "未找到 nockchain 项目，将自动初始化..."
    
    read -p "是否自动克隆 nockchain 项目？(y/n): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local target_dir="nockchain_$(date +%Y%m%d_%H%M%S)"
        
        log_info "正在克隆 nockchain 项目到: $target_dir"
        
        if git clone "$NOCKCHAIN_REPO" "$target_dir"; then
            cd "$target_dir"
            log_success "项目克隆成功，已切换到项目目录"
            return 0
        else
            log_error "项目克隆失败"
            return 1
        fi
    else
        log_error "请手动进入 nockchain 项目根目录后重新运行脚本"
        exit 1
    fi
}

# 智能目录检测和初始化
smart_directory_setup() {
    log_info "开始智能目录检测..."
    
    if check_project_root; then
        return 0
    fi
    
    log_warn "当前目录不是 nockchain 项目根目录"
    
    if find_nockchain_directory; then
        if check_project_root; then
            return 0
        fi
    fi
    
    auto_initialize_project
}

# 初始化环境配置
initialize_environment() {
    log_info "初始化环境配置..."
    
    # 设置 Rust 环境
    if [ -f "$HOME/.cargo/env" ]; then
        source "$HOME/.cargo/env"
    fi
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 设置编译优化环境变量
    export RUSTFLAGS="-C target-cpu=native -C opt-level=3"
    export CARGO_NET_RETRY=3
    export CARGO_NET_TIMEOUT=300
    export CARGO_HTTP_TIMEOUT=300
    
    # 设置 LLVM 环境变量
    export LLVM_CONFIG_PATH="/usr/bin/llvm-config"
    export LIBCLANG_PATH="/usr/lib/x86_64-linux-gnu"
    
    # 设置非交互模式
    export DEBIAN_FRONTEND=noninteractive
    
    # 创建环境文件
    if [ ! -f "$ENV_FILE" ]; then
        if [ -f "$ENV_EXAMPLE" ]; then
            cp "$ENV_EXAMPLE" "$ENV_FILE"
            log_success "已从 .env_example 创建 .env 文件"
        else
            log_info "创建默认 .env 文件"
            cat > "$ENV_FILE" << 'EOF'
RUST_LOG=info,nockchain=info,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info
MINIMAL_LOG_FORMAT=true
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
EOF
        fi
    fi
    
    # 创建备份目录
    [ ! -d "$BACKUP_DIR" ] && mkdir -p "$BACKUP_DIR"
    
    log_success "环境初始化完成"
}

# 验证128位16进制挖矿公钥格式
validate_mining_pubkey() {
    local pubkey="$1"
    
    # 检查是否为128个十六进制字符（128位16进制）
    if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
        log_error "无效的挖矿公钥格式"
        log_error "挖矿公钥必须是128位16进制格式（128个十六进制字符）"
        log_error "示例格式: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        return 1
    fi
    
    return 0
}

# 修复版 hoonc 安装
install_hoonc_fixed() {
    log_info "开始修复版 hoonc 编译器安装..."
    
    # 清理之前的构建产物
    if [ -d "target" ]; then
        log_info "清理之前的构建产物..."
        rm -rf target/
    fi
    
    # 清理 Cargo 缓存
    cargo clean 2>/dev/null || true
    
    # 设置编译环境
    local cpu_cores=$(nproc)
    export CARGO_BUILD_JOBS=$(( cpu_cores / 2 ))
    export CARGO_TARGET_DIR="$(pwd)/target"
    
    log_info "使用 $CARGO_BUILD_JOBS 个并行编译任务"
    log_info "目标目录: $CARGO_TARGET_DIR"
    
    # 尝试使用不同的方法安装 hoonc
    log_info "尝试方法1: 使用 make install-hoonc（超时 20 分钟）..."
    
    if timeout 1200 make install-hoonc; then
        log_success "hoonc 编译器安装成功（方法1）"
        return 0
    else
        log_warn "方法1失败，尝试方法2: 直接使用 cargo 安装..."
        
        # 方法2: 直接使用 cargo 安装
        if timeout 1800 cargo install --locked --force --path crates/hoonc --bin hoonc; then
            log_success "hoonc 编译器安装成功（方法2）"
            return 0
        else
            log_warn "方法2失败，尝试方法3: 降低优化级别..."
            
            # 方法3: 降低优化级别
            export RUSTFLAGS="-C opt-level=1"
            if timeout 2400 cargo install --locked --force --path crates/hoonc --bin hoonc; then
                log_success "hoonc 编译器安装成功（方法3）"
                return 0
            else
                log_error "所有方法都失败，hoonc 编译器安装失败"
                log_error "建议检查系统资源或在更高配置的服务器上重试"
                return 1
            fi
        fi
    fi
}

# 功能1：完整安装 Nockchain - 修复版
install_nockchain_complete_fixed() {
    log_info "开始修复版完整安装 Nockchain..."
    
    # 系统检查和优化
    check_system_resources_enhanced
    optimize_system_for_compilation
    install_system_dependencies_enhanced
    initialize_environment
    
    # 设置环境
    source $HOME/.cargo/env 2>/dev/null || true
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 显示系统信息
    log_info "系统信息："
    log_info "- Rust: $(rustc --version)"
    log_info "- Cargo: $(cargo --version)"
    log_info "- LLVM: $(llvm-config --version 2>/dev/null || echo 'N/A')"
    log_info "- Clang: $(clang --version | head -1 2>/dev/null || echo 'N/A')"
    
    # 安装 hoonc 编译器 - 使用修复版方法
    install_hoonc_fixed || return 1
    
    # 验证 hoonc 安装
    if command -v hoonc &> /dev/null; then
        log_success "hoonc 验证成功: $(command -v hoonc)"
    else
        log_error "hoonc 验证失败，未找到可执行文件"
        return 1
    fi
    
    # 构建项目
    log_info "构建 Nockchain 项目（这可能需要很长时间）..."
    local cpu_cores=$(nproc)
    export CARGO_BUILD_JOBS=$(( cpu_cores / 2 ))
    
    if timeout 3600 make build; then
        log_success "项目构建成功"
    else
        log_error "项目构建失败或超时"
        log_error "建议检查系统资源或延长超时时间"
        return 1
    fi
    
    # 安装组件
    log_info "安装 Nockchain 组件..."
    
    if make install-nockchain-wallet; then
        log_success "Nockchain 钱包安装成功"
    else
        log_error "Nockchain 钱包安装失败"
        return 1
    fi
    
    if make install-nockchain; then
        log_success "Nockchain 节点安装成功"
    else
        log_error "Nockchain 节点安装失败"
        return 1
    fi
    
    # 更新 PATH
    if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' ~/.bashrc; then
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
        log_success "已添加 Cargo bin 目录到 PATH"
    fi
    
    # 生成默认的128位挖矿公钥
    log_info "生成128位16进制挖矿公钥..."
    local hex_pubkey
    if command -v openssl &> /dev/null; then
        hex_pubkey=$(openssl rand -hex 64)
    else
        hex_pubkey=$(xxd -l 64 -p /dev/urandom | tr -d '\n')
    fi
    
    # 更新配置文件
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "${ENV_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$hex_pubkey/" "$ENV_FILE"
        log_success "已生成并设置128位挖矿公钥"
        log_info "挖矿公钥: $hex_pubkey"
    fi
    
    log_success "Nockchain 完整安装成功！"
    log_info "所有组件已安装完成，可以开始使用"
}

# 功能2：更改挖矿公钥（128位16进制格式）
change_mining_pubkey() {
    log_info "更改挖矿公钥（128位16进制格式）"
    echo
    log_info "请输入128位16进制格式的挖矿公钥（128个十六进制字符）"
    log_debug "格式示例: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    echo
    
    while true; do
        read -p "挖矿公钥 (128位16进制): " new_pubkey
        
        if [ -z "$new_pubkey" ]; then
            log_error "公钥不能为空"
            continue
        fi
        
        # 验证128位16进制格式
        if validate_mining_pubkey "$new_pubkey"; then
            if [ -f "$ENV_FILE" ]; then
                # 创建备份
                cp "$ENV_FILE" "$BACKUP_DIR/.env.backup.$(date +%Y%m%d_%H%M%S)"
                
                # 更新公钥
                if grep -q "MINING_PUBKEY=" "$ENV_FILE"; then
                    sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" "$ENV_FILE"
                else
                    echo "MINING_PUBKEY=$new_pubkey" >> "$ENV_FILE"
                fi
                
                log_success "挖矿公钥已更新"
                log_info "新公钥: $new_pubkey"
                log_info "配置已备份到 $BACKUP_DIR/"
                break
            else
                log_error ".env 文件不存在，请先运行安装选项"
                break
            fi
        else
            log_error "请输入正确格式的128位16进制公钥（128个十六进制字符）"
        fi
    done
}

# 功能3：启动节点
start_node() {
    log_info "启动 Nockchain 挖矿节点"
    
    # 检查必要条件
    if ! command -v nockchain &> /dev/null; then
        log_error "nockchain 未安装，请先运行安装选项"
        return 1
    fi
    
    if [ ! -f "$ENV_FILE" ]; then
        log_error ".env 文件不存在，请先运行安装选项"
        return 1
    fi
    
    # 加载环境变量
    source "$ENV_FILE"
    export RUST_LOG MINIMAL_LOG_FORMAT MINING_PUBKEY
    
    # 验证挖矿公钥格式
    if ! validate_mining_pubkey "$MINING_PUBKEY" 2>/dev/null; then
        log_error "当前配置的挖矿公钥格式不正确"
        log_error "请先使用 '更改挖矿公钥' 选项设置正确的128位16进制公钥"
        return 1
    fi
    
    # 检查现有进程
    if pgrep -f "nockchain" > /dev/null; then
        local existing_pids=$(pgrep -f nockchain | tr '\n' ' ')
        log_warn "检测到运行中的 Nockchain 进程: $existing_pids"
        
        read -p "是否停止现有进程并重新启动？(y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "停止现有进程..."
            pkill -TERM -f nockchain 2>/dev/null || true
            sleep 3
            if pgrep -f nockchain > /dev/null; then
                pkill -KILL -f nockchain 2>/dev/null || true
                sleep 2
            fi
            log_info "现有进程已停止"
        else
            log_info "保持现有进程运行"
            return 0
        fi
    fi
    
    log_info "配置信息："
    log_info "- 挖矿公钥: $MINING_PUBKEY"
    log_info "- 日志级别: $RUST_LOG"
    log_info "- 日志文件: $LOG_FILE"
    
    # 启动节点
    log_info "正在启动挖矿节点..."
    
    nohup nockchain --mining-pubkey "${MINING_PUBKEY}" --mine > "$LOG_FILE" 2>&1 &
    local node_pid=$!
    
    # 等待启动
    sleep 5
    
    # 验证启动状态
    if kill -0 $node_pid 2>/dev/null; then
        log_success "节点启动成功！"
        log_success "进程ID: $node_pid"
        log_info "日志文件: $LOG_FILE"
        
        # 显示初始日志
        if [ -f "$LOG_FILE" ]; then
            log_info "最近几行日志："
            tail -n 5 "$LOG_FILE" 2>/dev/null || true
        fi
        
        log_info "使用 '查看日志' 选项监控节点状态"
    else
        log_error "节点启动失败"
        if [ -f "$LOG_FILE" ]; then
            log_error "错误日志："
            tail -n 10 "$LOG_FILE"
        fi
        return 1
    fi
}

# 功能4：查看日志
view_logs() {
    log_info "查看 Nockchain 节点日志"
    
    if [ ! -f "$LOG_FILE" ]; then
        log_warn "日志文件不存在: $LOG_FILE"
        
        # 检查进程状态
        if pgrep -f "nockchain" > /dev/null; then
            log_info "节点正在运行，但日志文件不存在"
            log_info "建议重启节点以生成日志文件"
        else
            log_info "节点未运行"
        fi
        return 1
    fi
    
    echo
    log_info "=== 日志文件信息 ==="
    echo "文件位置: $(realpath $LOG_FILE)"
    echo "文件大小: $(du -h "$LOG_FILE" | cut -f1)"
    echo "最后修改: $(stat -c %y "$LOG_FILE" 2>/dev/null || date -r "$LOG_FILE" 2>/dev/null)"
    
    echo
    log_info "=== 最近50行日志 ==="
    echo
    tail -n 50 "$LOG_FILE"
    
    echo
    log_info "=== 实时日志监控 ==="
    log_info "按 Ctrl+C 退出监控"
    echo
    
    # 实时监控日志
    tail -f "$LOG_FILE"
}

# 主菜单显示
show_main_menu() {
    clear
    echo -e "${PURPLE}"
    echo "╔════════════════════════════════════════════════════════════════╗"
    echo "║                 Nockchain 节点管理工具                        ║"
    echo "║          （修复 dpkg lock-frontend 错误版 v8.0）              ║"
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    echo
    echo -e "${GREEN}🔧 核心功能菜单${NC}"
    echo "────────────────────────────────────────────────────────────────"
    echo "  1. 安装 Nockchain（修复 dpkg 锁文件问题版）"
    echo "  2. 更改挖矿公钥（128位16进制格式）"
    echo "  3. 启动挖矿节点"
    echo "  4. 查看节点日志"
    echo
    echo "  0. 退出"
    echo
    echo -e "${YELLOW}🔨 修复改进点：${NC}"
    echo -e "${YELLOW}• 修复 dpkg lock-frontend 锁文件冲突${NC}"
    echo -e "${YELLOW}• 智能检测和清理僵尸锁文件${NC}"
    echo -e "${YELLOW}• 安全的 apt 命令执行器和重试机制${NC}"
    echo -e "${YELLOW}• 进程冲突检测和自动处理${NC}"
    echo
    echo -e "${CYAN}📋 系统要求：${NC}"
    echo -e "${CYAN}• 最低: 32GB RAM, 4核 CPU, 50GB 磁盘${NC}"
    echo -e "${CYAN}• 推荐: 64GB+ RAM, 6核+ CPU, 100GB+ SSD${NC}"
    echo
    
    # 显示当前状态
    if [ -f "$ENV_FILE" ]; then
        local current_pubkey=$(grep "MINING_PUBKEY=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$current_pubkey" ] && [ "$current_pubkey" != "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" ]; then
            echo -e "${CYAN}📍 当前挖矿公钥: ${current_pubkey:0:20}...${current_pubkey: -20}${NC}"
        else
            echo -e "${CYAN}📍 当前挖矿公钥: 未设置或使用默认值${NC}"
        fi
    fi
    
    if pgrep -f "nockchain" > /dev/null; then
        echo -e "${CYAN}📍 节点状态: ✅ 运行中 (PID: $(pgrep -f nockchain | tr '\n' ' '))${NC}"
    else
        echo -e "${CYAN}📍 节点状态: ❌ 未运行${NC}"
    fi
    echo
}

# 主程序
main() {
    # 启动时进行智能目录检测
    log_info "Nockchain 节点管理工具启动中..."
    
    if ! smart_directory_setup; then
        log_error "无法初始化项目环境"
        exit 1
    fi
    
    # 主循环
    while true; do
        show_main_menu
        read -p "请选择操作 (0-4): " choice
        
        case $choice in
            1)
                install_nockchain_complete_fixed
                read -p "按回车键继续..."
                ;;
            2)
                change_mining_pubkey
                read -p "按回车键继续..."
                ;;
            3)
                start_node
                read -p "按回车键继续..."
                ;;
            4)
                view_logs
                ;;
            0)
                log_info "感谢使用 Nockchain 节点管理工具！"
                log_info "祝您挖矿愉快 🚀"
                exit 0
                ;;
            *)
                log_error "无效选择，请输入 0-4 之间的数字"
                sleep 2
                ;;
        esac
    done
}

# 脚本入口
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # 设置错误处理
    set -eE
    trap 'log_error "脚本在第 $LINENO 行出错"' ERR
    
    # 启动主程序
    main "$@"
fi
