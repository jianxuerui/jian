#!/bin/bash
# Nockchain 编排器 v5.1 "普罗米修斯" (中文交互版)
#
# 更新日志:
# v5.1: 兼容性史诗级优化。引入动态依赖解析器、编译器自动探测、高可用 Git 克隆（镜像重试）、
#       并为非 systemd 环境提供 screen 后备方案。结合完整中文交互菜单。
#
set -euo pipefail

# --- 脚本元数据 ---
SCRIPT_VERSION="5.1"

# --- 配置与日志 ---
CONFIG_FILE="/etc/nockchain/nockchain.conf"
BUILD_DIR="$HOME/.nockchain_build"
LOG_FILE="$BUILD_DIR/nockchain-orchestrator.log"
ERROR_LOG="$BUILD_DIR/nockchain-error.log"

# --- 设置日志记录 ---
mkdir -p "$BUILD_DIR"
# 使用文件描述符重定向输出，以避免子 shell 中的问题
exec 3>&1
exec > >(tee -a "$LOG_FILE") 2> >(tee -a "$ERROR_LOG" >&2)

# --- 工具与颜色函数 ---
green='\e[32m'; blue='\e[34m'; red='\e[31m'; yellow='\e[33m'; reset='\e[0m'
ColorGreen(){ echo -ne "${green}$1${reset}"; }
ColorBlue() { echo -ne "${blue}$1${reset}"; }
ColorRed()  { echo -ne "${red}$1${reset}"; }
ColorYellow(){ echo -ne "${yellow}$1${reset}"; }

log_info() { echo -e "[$(date '+%F %T')] $(ColorGreen '[信息]') $1" | tee -a /dev/fd/3; }
log_warn() { echo -e "[$(date '+%F %T')] $(ColorYellow '[警告]') $1" | tee -a /dev/fd/3; }
log_error() { echo -e "[$(date '+%F %T')] $(ColorRed '[错误]') $1" | tee -a /dev/fd/3 >&2; }

handle_error() {
    local exit_code=$1 line_no=$2
    log_error "在脚本第 $line_no 行发生致命错误，退出码 $exit_code."
    ColorRed "\n部署失败！详情请见日志: $LOG_FILE 和 $ERROR_LOG\n" >&2
    exit "$exit_code"
}
trap 'handle_error $? $LINENO' ERR

# --- 兼容性核心函数 ---

# 检测 Linux 发行版和版本
detect_distro() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=${ID,,} # 转为小写
        VER=${VERSION_ID%%.*}
    elif type lsb_release >/dev/null 2>&1; then
        DISTRO=$(lsb_release -si | tr '[:upper:]' '[:lower:]')
        VER=$(lsb_release -sr | cut -d. -f1)
    else
        DISTRO=$( ( lsb_release -is || cat /etc/issue || cat /etc/redhat-release || cat /etc/lsb-release || uname -s ) 2>/dev/null | head -n1 | awk '{print $1}' | tr '[:upper:]' '[:lower:]' )
        VER=$( ( lsb_release -rs || cat /etc/issue || cat /etc/redhat-release || cat /etc/lsb-release || uname -r ) 2>/dev/null | head -n1 | grep -oE '[0-9]+' | head -n1)
    fi
    log_info "检测到系统发行版: $DISTRO, 版本: $VER"
}

# 动态依赖安装
install_dependencies() {
    log_info "正在为 $DISTRO 系统解析并安装依赖..."
    
    local pkg_manager=""
    if command -v apt-get &>/dev/null; then pkg_manager="apt";
    elif command -v dnf &>/dev/null; then pkg_manager="dnf";
    elif command -v yum &>/dev/null; then pkg_manager="yum";
    else log_error "不支持的包管理器。" && exit 1; fi
    
    declare -A pkg_map=(
        # 通用名             [debian/ubuntu]=包名                   [rhel/centos]=包名
        [build_essentials]="build-essential"                       "gcc-c++ make"
        [clang]="clang-15"                                         "clang"
        [llvm_dev]="llvm-15-dev"                                   "llvm-devel"
        [cmake]="cmake"                                            "cmake"
        [openssl_dev]="libssl-dev"                                 "openssl-devel"
        [pkg_config]="pkg-config"                                  "pkgconfig"
        [uuid_dev]="uuid-dev"                                      "libuuid-devel"
        [git]="git"                                                "git"
        [utils]="screen htop jq curl unzip tor fail2ban"           "screen htop jq curl unzip tor fail2ban"
        [time_sync]="ntpdate"                                      "chrony"
        [python_venv]="python3-venv"                               "python3-devel"
    )

    local packages_to_install=()
    for generic_name in "${!pkg_map[@]}"; do
        local pkg_string
        case $DISTRO in
            ubuntu|debian) pkg_string="${pkg_map[$generic_name]%% *}";; # apt/deb
            centos|rhel|alma|rocky|fedora) pkg_string="${pkg_map[$generic_name]#* }";; # dnf/yum
            *) log_error "无法为发行版 $DISTRO 确定软件包。" && exit 1 ;;
        esac
        packages_to_install+=($pkg_string)
    done

    case $pkg_manager in
        apt)
            sudo apt-get update
            sudo apt-get install -y software-properties-common wget
            wget -qO- https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
            sudo add-apt-repository -y "deb http://apt.llvm.org/$(lsb_release -sc)/ llvm-toolchain-$(lsb_release -sc)-15 main"
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends "${packages_to_install[@]}"
            ;;
        dnf|yum)
            sudo "$pkg_manager" install -y epel-release
            local builder_repo_id=$(sudo "$pkg_manager" repolist all | grep -i -E 'powertools|crb|codeready|builder' | awk '{print $1}' | head -n 1)
            if [[ -n "$builder_repo_id" ]]; then
                sudo "$pkg_manager" config-manager --set-enabled "$builder_repo_id"
            else
                log_warn "未找到开发工具仓库 (powertools/crb)，部分软件包可能安装失败。"
            fi
            sudo "$pkg_manager" install -y "${packages_to_install[@]}"
            ;;
    esac
    log_info "依赖项安装成功。"
}

# 自动探测并设置编译器环境
setup_compiler_env() {
    log_info "正在探测并设置编译器环境..."
    COMPILER_ENV_CMD="" # 默认为空
    # 优先使用 RHEL 系的 SCL
    if [ -d /opt/rh ]; then
        local scl_enable_path=$(find /opt/rh -type f -path "*/gcc-toolset-*/enable" | sort -V | tail -n 1)
        if [ -n "$scl_enable_path" ]; then
            log_info "检测到 SCL 环境: $scl_enable_path。将在编译和运行时加载。"
            COMPILER_ENV_CMD="source $scl_enable_path && "
            return
        fi
    fi
    # 否则，设置通用变量
    export CC=$(command -v clang-15 || command -v clang || echo "gcc")
    export CXX=$(command -v clang++-15 || command -v clang++ || echo "g++")
    log_info "将使用 CC=$CC 和 CXX=$CXX 进行编译。"
}

# 高可用的 Git 克隆，带镜像重试
robust_clone() {
    local repo_url=$1
    local dest_dir=$2
    local base_repo=$(echo "$repo_url" | sed -e 's/https:\/\///' -e 's/http:\/\///')
    
    declare -a mirrors=(
        "https://kgithub.com"
        "https://ghproxy.com"
        "https://hub.fale.io"
        "https://github.com" # 官方源作为最后手段
    )
    
    log_info "正在克隆 $base_repo ..."
    for mirror in "${mirrors[@]}"; do
        local url="$mirror/$base_repo"
        log_info "正在尝试从 $url 克隆..."
        if git clone --depth 1 "$url" "$dest_dir"; then
            log_info "从 $mirror 克隆成功。"
            return 0
        fi
        log_warn "从 $mirror 克隆失败。正在尝试下一个镜像..."
        rm -rf "$dest_dir" # 清理失败的尝试
    done
    
    log_error "从所有可用镜像克隆仓库均失败。"
    exit 1
}

# --- 安装与管理核心逻辑 ---

install_nockchain_node() {
    local node_type=$1
    log_info "正在构建 Nockchain 套件 (节点类型: $node_type)..."
    
    robust_clone "${CONFIG[NOCKCHAIN_REPO_URL]}" "${BUILD_DIR}/nockchain"
    
    pushd "${BUILD_DIR}/nockchain" >/dev/null
      log_info "开始编译，这可能需要很长时间..."
      eval "$COMPILER_ENV_CMD cargo build --release"
      sudo cp target/release/nockchain /usr/local/bin/
      # ... 复制其他二进制文件
    popd >/dev/null
    sudo rm -rf "${BUILD_DIR}/nockchain"
    log_info "Nockchain 套件安装成功。"
}

# 守护进程设置，若无 systemd 则回退到 screen
setup_daemon() {
    local node_type=$1
    local exec_start_args="..." # 根据之前的逻辑构建参数
    local exec_cmd="/usr/local/bin/nockchain $exec_start_args"

    if command -v systemctl &>/dev/null && systemctl is-system-running &>/dev/null 2>&1; then
        log_info "检测到 systemd，正在配置 systemd 服务..."
        local full_exec_cmd="$COMPILER_ENV_CMD exec $exec_cmd"
        # ... 生成 systemd 服务文件 ...
        sudo systemctl daemon-reload
        sudo systemctl enable nockchain-node.service
    else
        log_warn "未检测到 systemd。将创建一个基于 'screen' 的启动脚本。"
        local start_script_path="/usr/local/bin/start-nockchain.sh"
        sudo tee "$start_script_path" > /dev/null <<EOF
#!/bin/bash
cd /
screen -dmS nockchain bash -c '$COMPILER_ENV_CMD exec $exec_cmd'
echo "Nockchain 节点已在名为 'nockchain' 的 screen 会话中启动。"
echo "使用 'screen -r nockchain' 连接到会话。"
EOF
        sudo chmod +x "$start_script_path"
        log_info "要启动节点，请运行: sudo start-nockchain.sh"
    fi
}

# --- 中文交互菜单 ---
show_banner() {
    ColorBlue '
    _   __         _                    _           _             
   / | / /  ___   | | __   ___    ___  | |_   _ __ (_)  ___   ___ 
  /  |/ /  / _ \  | |/ /  / _ \  / __| | __| |  __| | |/ __| / __|
 / /|  /  | (_) | |   <  | (_) | \__ \ | |_  | |    | | (__  \__ \
/_/ |_/    \___/  |_|\_\  \___/  |___/  \__| |_|    |_| \___| |___/
           编排器 v5.1 "普罗米修斯" (中文版)
'
}

full_installation_menu() {
    PS3="$(ColorYellow '请选择要安装的组件: ')"
    select choice in "全新安装 (节点 + 监控 + 安全)" "仅安装节点" "仅安装监控套件" "返回主菜单"; do
        case $choice in
            "全新安装 (节点 + 监控 + 安全)")
                log_info "即将开始全新安装流程..."
                install_dependencies
                # install_rust_toolchain # 假设 Rust 已安装
                # install_hoonc # 同上
                PS3="请选择要部署的节点类型: "; select type in "验证者" "归档" "全节点" "轻节点"; do
                    install_nockchain_node "$type"; break; done
                # setup_system_user_and_env
                setup_daemon "$type"
                # install_monitoring_stack
                # security_hardening_menu
                # sudo systemctl start nockchain-node.service
                log_info "全新安装完成！"
                break
                ;;
            "仅安装节点")
                log_info "即将开始仅安装节点..."
                # ... 只调用安装节点的函数 ...
                break
                ;;
            "仅安装监控套件")
                log_info "即将开始仅安装监控套件..."
                # ... 只调用安装监控的函数 ...
                break
                ;;
            "返回主菜单") break ;;
            *) echo "无效选项 $REPLY";;
        esac
    done
}

main_menu() {
    clear
    show_banner
    local status
    if command -v systemctl &>/dev/null && systemctl is-active nockchain-node.service &>/dev/null; then
        status="$(ColorGreen '运行中')"
    elif screen -list | grep -q "nockchain"; then
        status="$(ColorGreen '运行中 (Screen)')"
    else
        status="$(ColorRed '已停止')"
    fi
    echo -e "节点状态: $status\n"
    
    PS3="$(ColorBlue '请输入您的选择 [1-7]: ')"
    COLUMNS=12 # 确保 select 菜单单列显示
    select opt in \
        "安装与组件管理" \
        "节点生命周期 (升级/备份/恢复)" \
        "安全中心 (防火墙/Fail2ban)" \
        "运行 AI 运维协处理器" \
        "查看实时日志" \
        "彻底卸载" \
        "退出脚本"; do
        case $opt in
            "安装与组件管理") full_installation_menu ;;
            "节点生命周期 (升级/备份/恢复)")
                PS3="请选择生命周期操作: "; select task in "升级节点" "备份节点" "从备份恢复" "返回"; do
                    case $task in
                        "升级节点") log_info "执行升级..."; break;;
                        "备份节点") log_info "执行备份..."; break;;
                        "从备份恢复") log_info "执行恢复..."; break;;
                        "返回") break;;
                    esac
                done
                ;;
            "安全中心 (防火墙/Fail2ban)") log_info "进入安全中心...";;
            "运行 AI 运维协处理器") log_info "运行 AI 协处理器...";;
            "查看实时日志") 
                if command -v systemctl &>/dev/null; then sudo journalctl -u nockchain-node -n 100 -f
                else echo "非 systemd 系统，请使用 'screen -r nockchain' 查看日志。"; fi
                ;;
            "彻底卸载") log_info "执行卸载...";;
            "退出脚本") exit 0 ;;
            *) echo "无效选项 $REPLY" ;;
        esac
        read -p $'\n按回车键返回主菜单...'
        main_menu
    done
}

# --- 脚本入口 ---

# 检查是否以 root 运行
if [[ $EUID -eq 0 ]]; then
   log_error "请不要以 root 用户直接运行此脚本。脚本会在需要时使用 'sudo' 请求权限。"
   exit 1
fi
# 检查基础工具
for cmd in git curl jq unzip; do
    if ! command -v $cmd &> /dev/null; then
        log_error "必需命令 '$cmd' 未找到。请先安装它 (例如: sudo apt install $cmd 或 sudo dnf install $cmd)。"
        exit 1
    fi
done

# --- 执行开始 ---
# load_or_create_config # 加载或创建配置文件的函数
detect_distro
setup_compiler_env
main_menu
