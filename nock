#!/usr/bin/env bash
# nockchain_toolbox.sh 终极修复版 v10.0
# 新增特性：CUDA智能检测 + 路径自动修复 + 全发行版支持

set -euo pipefail
IFS=$'\n\t'

###############################
# 全局配置
###############################
SRC_DIR="${HOME}/build/ethminer"
INSTALL_PREFIX="/usr/local"
LOG_FILE="${HOME}/nockchain.log"
CONFIG_FILE="${HOME}/.nockchain.conf"

###############################
# 颜色输出函数
###############################
c_info() { printf "\033[32m[INFO]\033[0m %s\n" "$*"; }
c_warn() { printf "\033[33m[WARN]\033[0m %s\n" "$*"; }
c_err()  { printf "\033[31m[ERR]\033[0m %s\n" "$*"; exit 1; }

###############################
# CUDA智能检测系统
###############################
detect_cuda() {
    # 检测标准安装路径
    local cuda_paths=(
        "/usr/local/cuda"
        "/opt/cuda"
        "${HOME}/cuda"
    )
    
    for path in "${cuda_paths[@]}"; do
        if [[ -d "${path}/bin" && -x "${path}/bin/nvcc" ]]; then
            echo "${path}"
            return 0
        fi
    done

    # 检测环境变量
    if [[ -n "${CUDA_HOME}" && -d "${CUDA_HOME}/bin" ]]; then
        echo "${CUDA_HOME}"
        return 0
    fi

    # 检测PATH中的nvcc
    local nvcc_path=$(which nvcc 2>/dev/null)
    if [[ -n "${nvcc_path}" ]]; then
        echo "$(dirname $(dirname ${nvcc_path}))"
        return 0
    fi

    echo "not_found"
}

###############################
# 增强版系统修复
###############################
fix_system_deps() {
    # 安装基础依赖
    if [[ -f /etc/redhat-release ]]; then
        c_info "🐧 检测到 RHEL/CentOS 系统"
        sudo yum install -y epel-release
        sudo yum groupinstall -y "Development Tools"
        sudo yum install -y \
            gcc-c++ \
            libstdc++-devel \
            openssl-devel \
            ocl-icd-devel \
            opencl-headers
        
    elif [[ -f /etc/debian_version ]]; then
        c_info "🐧 检测到 Debian/Ubuntu 系统"
        sudo apt-get update
        sudo apt-get install -y \
            build-essential \
            libstdc++-dev \
            libssl-dev \
            ocl-icd-opencl-dev \
            opencl-headers
    else
        c_err "❌ 不支持的Linux发行版"
    fi

    # 特殊修复：libstdc++符号链接
    [[ ! -f /usr/lib64/libstdc++.so ]] && \
    sudo ln -svf /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so

    sudo ldconfig
}

###############################
# 智能编译配置
###############################
configure_cmake() {
    local build_dir=$1
    local cuda_path=$2

    c_info "🔧 配置编译参数..."
    cd "${build_dir}"
    
    local cmake_args=(
        "-DCMAKE_BUILD_TYPE=Release"
        "-DCMAKE_CXX_COMPILER=g++"
        "-DCMAKE_EXE_LINKER_FLAGS=-Wl,-rpath=/usr/lib64"
        "-DUSE_SYS_OPENCL=ON"
    )

    # CUDA特殊处理
    if [[ "${cuda_path}" != "not_found" ]]; then
        cmake_args+=(
            "-DETHASHCUDA=ON"
            "-DCUDA_TOOLKIT_ROOT_DIR=${cuda_path}"
        )
        c_info "✅ 检测到CUDA: ${cuda_path}"
    else
        cmake_args+=("-DETHASHCUDA=OFF")
        c_warn "⚠️  未检测到CUDA，禁用CUDA支持"
    fi

    cmake .. "${cmake_args[@]}"
}

###############################
# 全自动编译流程
###############################
rebuild_project() {
    local build_dir="${SRC_DIR}/build_release"
    
    # 清理环境
    c_info "🧹 清理构建目录..."
    rm -rf "${build_dir}"
    mkdir -p "${build_dir}"

    # 检测CUDA路径
    local cuda_path=$(detect_cuda)
    
    # 配置编译参数
    configure_cmake "${build_dir}" "${cuda_path}"

    # 开始编译
    c_info "🚀 开始编译（使用$(nproc)线程）..."
    if make -j$(nproc); then
        c_info "🎉 编译成功！"
        sudo make install
    else
        c_err "💥 编译失败，请检查日志"
        tail -n 50 CMakeFiles/CMakeError.log
        exit 1
    fi
}

###############################
# 增强菜单系统 (剩余功能保持不变)
###############################
show_menu() {
    clear
    echo -e "\n========== Nockchain 终极管理工具 =========="
    echo "1) 自动修复依赖环境"
    echo "2) 智能重新编译"
    echo "3) 配置钱包地址"
    echo "4) 启动挖矿节点"
    echo "5) 查看实时日志"
    echo "6) 显示系统信息"
    echo "7) 退出"
    echo -e "==========================================\n"
}

# ...（其余菜单功能保持不变）...

main() {
    trap 'c_err "用户中断操作，退出脚本"' INT TERM
    while true; do
        show_menu
        read -rp "请输入选项 [1-7]: " choice
        case $choice in
            1) fix_system_deps ;;
            2) rebuild_project ;;
            3) manage_wallet ;;
            4) start_mining ;;
            5) view_logs ;;
            6) validate_environment ;;
            7) c_info "感谢使用！"; exit 0 ;;
            *) c_warn "无效输入，请重新选择" ;;
        esac
        read -rp "按回车返回主菜单..."
    done
}

main "$@"
