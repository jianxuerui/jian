#!/bin/bash

# ===================================================
# Nockchain Setup and Management Script (Optimized)
# ===================================================

# ========= è‰²å½©å®šä¹‰ =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

# ========= é¡¹ç›®è·¯å¾„å’Œæ–‡ä»¶ =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$NCK_DIR/nockchain.log" # Log file for the miner output

# ========= å˜é‡ç”¨äºå­˜å‚¨å‘½ä»¤è¡Œå‚æ•° =========
THREADS_ARG=""
PUBKEY_ARG=""
RUN_ONE_LINER_MODE=false # æ ‡è®°æ˜¯å¦ä»¥ä¸€é”®æ¨¡å¼è¿è¡Œ

# ========= æ¨ªå¹… =========
function show_banner() {
  # æ¸…é™¤å±å¹•å¹¶æ˜¾ç¤ºæ¨ªå¹…
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain å®‰è£…åŠ©æ‰‹ / Setup Tool"
  echo "==============================================="
  echo -e "${RESET}"
  echo "ğŸ“Œ ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº«"
  echo "ğŸ”— Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "ğŸ¦ Twitter:  https://x.com/BtcK241918"
  echo "-----------------------------------------------"
  echo -e "${YELLOW}ğŸ”¥ ä¼˜åŒ–ç‰ˆæ”¯æŒå¤šçº¿ç¨‹æŒ–çŸ¿é…ç½® ğŸ”¥${RESET}"
  echo ""
}

# ========= å¸¸ç”¨å‡½æ•° =========

# è¿›å…¥é¡¹ç›®ç›®å½•ï¼Œå¤±è´¥åˆ™é€€å‡º
function cd_nck_dir() {
  if [[ -d "$NCK_DIR" ]]; then
    cd "$NCK_DIR" || { echo -e "${RED}[-] æ— æ³•è¿›å…¥é¡¹ç›®ç›®å½•: $NCK_DIR${RESET}"; exit 1; }
  else
    echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
    exit 1
  fi
}

# æ£€æŸ¥å‘½ä»¤æ˜¯å¦å­˜åœ¨
function command_exists() {
  command -v "$1" &>/dev/null
}

# æš‚åœå¹¶è¿”å›ä¸»èœå• (ä»…åœ¨éä¸€é”®æ¨¡å¼ä¸‹ä½¿ç”¨)
function pause_and_return() {
  if [ "$RUN_ONE_LINER_MODE" = false ]; then
    echo ""
    read -n1 -r -p "æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•..." key
    main_menu
  fi
}

# å†™å…¥æˆ–æ›´æ–° .env æ–‡ä»¶ä¸­çš„é”®å€¼å¯¹
# å‚æ•°1: key
# å‚æ•°2: value
function update_env() {
  local key="$1"
  local value="$2"
  if [[ -f "$ENV_FILE" ]]; then
    # ä½¿ç”¨awkæ›´æ–°æˆ–æ·»åŠ é”®å€¼å¯¹ï¼Œä¿ç•™åŸæœ‰æ³¨é‡Šå’Œæ ¼å¼
    awk -v key="$key" -v value="$value" '
    BEGIN { edited = 0 }
    $1 == key { $0 = key "=" value; edited = 1 }
    { print }
    END { if (!edited) print key "=" value }
    ' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
    #echo -e "${GREEN}[+] å·²å†™å…¥ ${key} åˆ° .env${RESET}" # é¿å…åœ¨ä¸€é”®æ¨¡å¼ä¸‹è¾“å‡ºè¿‡å¤š
  else
    echo -e "${RED}[-] .env æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œå®‰è£…é€‰é¡¹åˆ›å»º${RESET}"
  fi
}

# è¯»å– .env æ–‡ä»¶ä¸­çš„å€¼
# å‚æ•°1: key
# å‚æ•°2: default_value (å¯é€‰)
function get_env() {
  local key="$1"
  local default_value="$2"
  if [[ -f "$ENV_FILE" ]]; then
    # ä½¿ç”¨grepå’Œcut/sedæå–å€¼
    # grep "^${key}=" "$ENV_FILE" | cut -d'=' -f2- # è¿™ç§æ–¹æ³•é‡åˆ°ç©ºå€¼å¯èƒ½è¾“å‡ºæ¢è¡Œ
    awk -F= -v key="^${key}$" '$1 ~ key {print $2}' "$ENV_FILE"
  else
    echo "$default_value" # è¿”å›é»˜è®¤å€¼
  fi
}

# ========= å®‰è£…ä¸æ„å»ºå‡½æ•° =========

function setup_all() {
  echo -e "${CYAN}[*] å¼€å§‹æ‰§è¡Œå®‰è£…å’Œæ„å»º...${RESET}"

  echo -e "${CYAN}[*] å®‰è£…ç³»ç»Ÿä¾èµ–...${RESET}"
  sudo apt update || { echo -e "${RED}[-] apt update å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen || { echo -e "${RED}[-] å®‰è£…ç³»ç»Ÿä¾èµ–å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  echo -e "${GREEN}[+] ç³»ç»Ÿä¾èµ–å®‰è£…å®Œæˆ${RESET}"

  echo -e "${CYAN}[*] å®‰è£… Rust...${RESET}"
  if ! command_exists cargo; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    # shellcheck source=/dev/null
    source "$HOME/.cargo/env"
    echo -e "${GREEN}[+] Rust å®‰è£…å®Œæˆ${RESET}"
  else
    echo -e "${YELLOW}[*] Rust å·²å®‰è£…${RESET}"
  fi

  # ç¡®ä¿ cargo bin è·¯å¾„æ·»åŠ åˆ° PATH
  local rc_file="$HOME/.bashrc"
  [[ "$SHELL" == *"zsh"* ]] && rc_file="$HOME/.zshrc"
  if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$rc_file"; then
    echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    echo -e "${GREEN}[+] å·²æ·»åŠ  Cargo è·¯å¾„åˆ° $rc_file${RESET}"
  #else # é¿å…åœ¨ä¸€é”®æ¨¡å¼ä¸‹è¾“å‡º
     #echo -e "${YELLOW}[*] Cargo è·¯å¾„å·²å­˜åœ¨äº $rc_file${RESET}"
  fi
  # ç«‹å³æ›´æ–°å½“å‰ shell çš„ PATH
  export PATH="$HOME/.cargo/bin:$PATH"

  echo -e "${CYAN}[*] è·å–æˆ–æ›´æ–°ä»“åº“...${RESET}"
  if [[ -d "$NCK_DIR" ]]; then
    echo -e "${YELLOW}[*] é¡¹ç›®ç›®å½•å·²å­˜åœ¨ï¼Œå°è¯•æ›´æ–°...${RESET}"
    cd_nck_dir
    git pull || { echo -e "${RED}[-] git pull å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  else
    echo -e "${YELLOW}[*] å…‹éš†æ–°ä»“åº“...${RESET}"
    git clone https://github.com/zorp-corp/nockchain "$NCK_DIR" || { echo -e "${RED}[-] git clone å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
    cd_nck_dir
  fi
  echo -e "${GREEN}[+] ä»“åº“å‡†å¤‡å°±ç»ª${RESET}"

  echo -e "${CYAN}[*] è®¾ç½® .env æ–‡ä»¶...${RESET}"
  if [[ -f "$ENV_FILE" ]]; then
      echo -e "${YELLOW}[*] .env æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º${RESET}"
  else
      cp -n .env_example "$ENV_FILE" || { echo -e "${RED}[-] å¤åˆ¶ .env_example å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
      echo -e "${GREEN}[+] .env æ–‡ä»¶å·²åˆ›å»º${RESET}"
  fi

  # æ£€æŸ¥å¹¶è®¾ç½®é»˜è®¤æŒ–çŸ¿çº¿ç¨‹æ•° (å¦‚æœæœªè®¾ç½®ä¸”å‘½ä»¤è¡Œæœªæä¾›)
  local current_threads=$(get_env "MINING_THREADS")
  if [[ -z "$THREADS_ARG" && -z "$current_threads" ]]; then
      local num_cores=$(nproc 2>/dev/null || echo 1) # è·å–æ ¸å¿ƒæ•°ï¼Œå¤±è´¥é»˜è®¤1
      echo -e "${YELLOW}[*] MINING_THREADS æœªè®¾ç½®ä¸”æœªé€šè¿‡å‚æ•°æŒ‡å®šï¼Œè‡ªåŠ¨è®¾ç½®ä¸ºæ ¸å¿ƒæ•° ($num_cores)...${RESET}"
      update_env "MINING_THREADS" "$num_cores"
  elif [[ -z "$THREADS_ARG" ]]; then # å¦‚æœå‘½ä»¤è¡Œæœªæä¾›ï¼Œä½† .env å·²æœ‰
      echo -e "${YELLOW}[*] MINING_THREADS å·²è®¾ç½®ä¸º $current_threads${RESET}"
  fi
  # å¦‚æœé€šè¿‡å‘½ä»¤è¡Œæä¾›äº† THREADS_ARGï¼Œå°†åœ¨ä¸»é€»è¾‘ä¸­æ›´æ–° .env

  echo -e "${CYAN}[*] å®‰è£… hoonc...${RESET}"
  cd_nck_dir
  make install-hoonc || { echo -e "${RED}[-] make install-hoonc å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  echo -e "${GREEN}[+] hoonc å®‰è£…å®Œæˆ${RESET}"

  echo -e "${CYAN}[*] ç¼–è¯‘ Nockchain (ä½¿ç”¨å¤šæ ¸: make -j $(nproc 2>/dev/null || echo 1))...${RESET}"
  cd_nck_dir
  # Use make -j for faster compilation if supported by the system
  make build -j $(nproc 2>/dev/null || echo 1) || { echo -e "${RED}[-] make build å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  echo -e "${GREEN}[+] Nockchain ç¼–è¯‘å®Œæˆ${RESET}"

  echo -e "${CYAN}[*] å®‰è£…é’±åŒ…...${RESET}"
  cd_nck_dir
  make install-nockchain-wallet || { echo -e "${RED}[-] make install-nockchain-wallet å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  echo -e "${GREEN}[+] é’±åŒ…å®‰è£…å®Œæˆ${RESET}"

  echo -e "${CYAN}[*] å®‰è£…èŠ‚ç‚¹...${RESET}"
  cd_nck_dir
  make install-nockchain || { echo -e "${RED}[-] make install-nockchain å¤±è´¥${RESET}"; if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi }
  echo -e "${GREEN}[+] èŠ‚ç‚¹å®‰è£…å®Œæˆ${RESET}"

  echo -e "${GREEN}===============================================${RESET}"
  echo -e "${GREEN}         ğŸ‰ Nockchain å®‰è£…æ„å»ºæˆåŠŸ! ğŸ‰         ${RESET}"
  echo -e "${GREEN}===============================================${RESET}"

  if [ "$RUN_ONE_LINER_MODE" = false ]; then
      echo ""
      echo -e "${YELLOW}é‡è¦æç¤º:${RESET}"
      echo -e "1. è¯·è¿è¡Œ '2) ç”Ÿæˆé’±åŒ…' æ¥åˆ›å»ºä½ çš„é’±åŒ…å¯†é’¥ã€‚"
      echo -e "2. ç”Ÿæˆé’±åŒ…åï¼ŒåŠ¡å¿…å¤åˆ¶å…¬é’¥å¹¶è¿è¡Œ '3) è®¾ç½® MINING_PUBKEY' å°†å…¶å†™å…¥ .env æ–‡ä»¶ã€‚"
      echo -e "3. ä½ å¯ä»¥ä½¿ç”¨ '6) é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°' æ¥ä¼˜åŒ–æŒ–çŸ¿æ€§èƒ½ã€‚"
      echo -e "4. æœ€åä½¿ç”¨ '7) å¯åŠ¨èŠ‚ç‚¹' æ¥å¼€å§‹æŒ–çŸ¿ã€‚"
  fi
}

# ========= é’±åŒ…å‡½æ•° =========

function generate_wallet() {
  echo -e "${CYAN}[*] ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹...${RESET}"
  cd_nck_dir

  # æ£€æŸ¥é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨
  if [[ ! -x "./target/release/nockchain-wallet" ]]; then
    echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
    pause_and_return
    return 1
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹ï¼Œè¯·è®°ä¸‹å…¬é’¥ (pubkey)!${RESET}"
  echo "-----------------------------------------------"
  ./target/release/nockchain-wallet keygen
  local status=$?
  echo "-----------------------------------------------"

  if [[ $status -eq 0 ]]; then
    echo -e "${GREEN}[+] é’±åŒ…å¯†é’¥å¯¹ç”Ÿæˆå®Œæˆã€‚${RESET}"
    echo -e "${YELLOW}è¯·å°†ä¸Šé¢è¾“å‡ºçš„å…¬é’¥æ‰‹åŠ¨å¤åˆ¶ï¼Œå¹¶è¿è¡Œ '3) è®¾ç½® MINING_PUBKEY' æ¥é…ç½®æŒ–çŸ¿åœ°å€ã€‚${RESET}"
  else
    echo -e "${RED}[-] é’±åŒ…å¯†é’¥ç”Ÿæˆå¤±è´¥${RESET}"
  fi

  pause_and_return
}

function set_pubkey_env() {
  echo -e "${CYAN}[*] è®¾ç½® MINING_PUBKEY åˆ° .env...${RESET}"
  cd_nck_dir

  if [[ ! -f "$ENV_FILE" ]]; then
      echo -e "${RED}[-] .env æ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
      pause_and_return
      return 1
  fi

  read -p "è¯·è¾“å…¥ä½ çš„ Nockchain å…¬é’¥ (pubkey): " pubkey
  if [[ -z "$pubkey" ]]; then
    echo -e "${RED}[-] å…¬é’¥ä¸èƒ½ä¸ºç©º${RESET}"
    pause_and_return
    return
  fi

  update_env "MINING_PUBKEY" "$pubkey"
  pause_and_return
}

function export_keys() {
  echo -e "${CYAN}[*] å¯¼å‡ºé’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir

   if [[ ! -x "./target/release/nockchain-wallet" ]]; then
    echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
    pause_and_return
    return 1
  fi

  echo -e "${YELLOW}[!] å¯†é’¥å°†å¯¼å‡ºåˆ° ./keys.export æ–‡ä»¶ã€‚è¯·å¦¥å–„ä¿ç®¡ï¼${RESET}"
  ./target/release/nockchain-wallet export-keys
  local status=$?
  if [[ $status -eq 0 ]]; then
      echo -e "${GREEN}[+] å¯†é’¥å·²æˆåŠŸå¯¼å‡ºåˆ° $NCK_DIR/keys.export${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å‡ºå¤±è´¥${RESET}"
  fi

  pause_and_return
}

function import_keys() {
  echo -e "${CYAN}[*] å¯¼å…¥é’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir

   if [[ ! -x "./target/release/nockchain-wallet" ]]; then
    echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
    pause_and_return
    return 1
  fi

  read -p "[?] è¯·è¾“å…¥è¦å¯¼å…¥çš„å¯†é’¥æ–‡ä»¶è·¯å¾„ (é»˜è®¤: ./keys.export): " keyfile
  local keyfile=${keyfile:-"./keys.export"}

  if [[ ! -f "$keyfile" ]]; then
      echo -e "${RED}[-] å¯†é’¥æ–‡ä»¶ '$keyfile' ä¸å­˜åœ¨${RESET}"
      pause_and_return
      return 1
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨å¯¼å…¥å¯†é’¥...${RESET}"
  ./target/release/nockchain-wallet import-keys --input "$keyfile"
  local status=$?
  if [[ $status -eq 0 ]]; then
      echo -e "${GREEN}[+] å¯†é’¥å·²æˆåŠŸå¯¼å…¥${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å…¥å¤±è´¥${RESET}"
  fi

  pause_and_return
}

# ========= èŠ‚ç‚¹ç®¡ç†å‡½æ•° =========

# é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°
function configure_mining_threads() {
    echo -e "${CYAN}[*] é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°...${RESET}"
    local current_threads=$(get_env "MINING_THREADS")
    local num_cores=$(nproc 2>/dev/null || echo 1) # è·å–æ ¸å¿ƒæ•°ï¼Œå¤±è´¥é»˜è®¤1

    if [[ -z "$current_threads" ]]; then
        current_threads="$num_cores" # å¦‚æœ .env ä¸­æœªè®¾ç½®ï¼Œä½¿ç”¨æ ¸å¿ƒæ•°ä½œä¸ºé»˜è®¤
    fi

    echo -e "å½“å‰é…ç½®çš„æŒ–çŸ¿çº¿ç¨‹æ•°: ${YELLOW}$current_threads${RESET}"
    echo -e "ç³»ç»Ÿæ£€æµ‹åˆ°çš„æ ¸å¿ƒæ•°: ${GREEN}$num_cores${RESET}"
    read -p "è¯·è¾“å…¥æ–°çš„æŒ–çŸ¿çº¿ç¨‹æ•° (æ¨è $num_cores): " new_threads

    # æ ¡éªŒè¾“å…¥æ˜¯å¦ä¸ºæ­£æ•´æ•°
    if [[ "$new_threads" =~ ^[1-9][0-9]*$ ]]; then
        update_env "MINING_THREADS" "$new_threads"
        echo -e "${GREEN}[+] æŒ–çŸ¿çº¿ç¨‹æ•°å·²æ›´æ–°ä¸º $new_threads${RESET}"
    else
        echo -e "${RED}[-] è¾“å…¥æ— æ•ˆï¼Œçº¿ç¨‹æ•°å¿…é¡»æ˜¯æ­£æ•´æ•°${RESET}"
    fi
    pause_and_return
}


function start_node() {
  echo -e "${CYAN}[*] å¯åŠ¨èŠ‚ç‚¹ (screen)...${RESET}"
  cd_nck_dir

  # æ£€æŸ¥èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨
  if [[ ! -x "./target/release/nockchain" ]]; then
    echo -e "${RED}[-] èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
    if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi
  fi

  # æ£€æŸ¥ MINING_PUBKEY æ˜¯å¦å·²è®¾ç½® (ä¼˜å…ˆä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°ï¼Œç„¶åæ˜¯ .env)
  local mining_pubkey=""
  if [[ -n "$PUBKEY_ARG" ]]; then
      mining_pubkey="$PUBKEY_ARG"
      echo -e "${YELLOW}[*] ä½¿ç”¨å‘½ä»¤è¡Œæä¾›çš„ MINING_PUBKEY${RESET}"
  else
      mining_pubkey=$(get_env "MINING_PUBKEY")
      echo -e "${YELLOW}[*] ä½¿ç”¨ .env ä¸­é…ç½®çš„ MINING_PUBKEY${RESET}"
  fi

  if [[ -z "$mining_pubkey" ]]; then
    echo -e "${RED}[-] é”™è¯¯: MINING_PUBKEY æœªè®¾ç½®ã€‚è¯·é€šè¿‡ -p å‚æ•°æä¾›ï¼Œæˆ–åœ¨ .env æ–‡ä»¶ä¸­è®¾ç½®ã€‚${RESET}"
    if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi
  fi

  # è·å–é…ç½®çš„çº¿ç¨‹æ•° (ä¼˜å…ˆä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°ï¼Œç„¶åæ˜¯ .env ä¸­çš„ï¼Œæœ€åæ˜¯æ ¸å¿ƒæ•°)
  local mining_threads=""
  if [[ -n "$THREADS_ARG" ]]; then
      mining_threads="$THREADS_ARG"
      echo -e "${YELLOW}[*] ä½¿ç”¨å‘½ä»¤è¡Œæä¾›çš„æŒ–çŸ¿çº¿ç¨‹æ•°: $mining_threads${RESET}"
  else
      mining_threads=$(get_env "MINING_THREADS")
       if [[ -z "$mining_threads" || ! "$mining_threads" =~ ^[1-9][0-9]*$ ]]; then
            local num_cores=$(nproc 2>/dev/null || echo 1)
            echo -e "${YELLOW}[*] MINING_THREADS æœªåœ¨ .env ä¸­è®¾ç½®æˆ–æ— æ•ˆï¼Œä½¿ç”¨ç³»ç»Ÿæ ¸å¿ƒæ•° ($num_cores) ä½œä¸ºé»˜è®¤å€¼${RESET}"
            mining_threads="$num_cores"
       else
            echo -e "${YELLOW}[*] ä½¿ç”¨ .env ä¸­é…ç½®çš„æŒ–çŸ¿çº¿ç¨‹æ•°: $mining_threads${RESET}"
       fi
  fi

  if [[ ! "$mining_threads" =~ ^[1-9][0-9]*$ ]]; then
      echo -e "${RED}[-] é”™è¯¯: æ— æ•ˆçš„æŒ–çŸ¿çº¿ç¨‹æ•° '$mining_threads'${RESET}"
      if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi
  fi


  echo -e "${CYAN}[*] ä½¿ç”¨ä»¥ä¸‹å‚æ•°å¯åŠ¨èŠ‚ç‚¹:${RESET}"
  echo -e "  MINING_PUBKEY: ${YELLOW}$mining_pubkey${RESET}"
  echo -e "  THREADS:       ${YELLOW}$mining_threads${RESET}"
  echo -e "  Log File:      ${CYAN}$LOG_FILE${RESET}"

  # æ£€æŸ¥å¹¶ç»ˆæ­¢æ—§çš„ screen ä¼šè¯
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[*] æ£€æµ‹åˆ°æ—§çš„ screen ä¼šè¯ 'nockchain'ï¼Œæ­£åœ¨å…³é—­...${RESET}"
    screen -S nockchain -X quit
    # Give it a moment to terminate
    sleep 2
    if screen -list | grep -qw "nockchain"; then
        echo -e "${RED}[-] æ— æ³•ç»ˆæ­¢æ—§çš„ screen ä¼šè¯ï¼Œè¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit' æˆ– 'killall screen'${RESET}"
        if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi
    fi
    echo -e "${GREEN}[+] æ—§çš„ screen ä¼šè¯å·²å…³é—­${RESET}"
  fi

  # å¯åŠ¨æ–°çš„ screen ä¼šè¯ï¼Œåœ¨å…¶ä¸­æ‰§è¡ŒèŠ‚ç‚¹å‘½ä»¤
  # ä½¿ç”¨ bash -c æ¥ sourcing .env å¹¶æ‰§è¡Œå‘½ä»¤
  # å°†æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯éƒ½é‡å®šå‘åˆ° teeï¼Œä»¥ä¾¿åŒæ—¶åœ¨ screen å’Œ log æ–‡ä»¶ä¸­æŸ¥çœ‹
  echo -e "${CYAN}[*] å¯åŠ¨æ–°çš„ screen ä¼šè¯ 'nockchain'...${RESET}"

  # Construct the command to run inside screen
  # We need to ensure the env variables from .env are available, especially MINING_PUBKEY and MINING_THREADS if not passed via args
  # However, the parameters are passed directly to the executable via args here.
  # The primary use of sourcing .env inside screen is for other potential variables the miner might use.
  local screen_cmd="cd $NCK_DIR && \
source \"$ENV_FILE\" 2>/dev/null; \
export MINING_PUBKEY=\"$mining_pubkey\"; \
export MINING_THREADS=\"$mining_threads\"; \
echo -e \"${GREEN}>>> èŠ‚ç‚¹æ­£åœ¨å¯åŠ¨ï¼Œä½¿ç”¨å…¬é’¥: \${MINING_PUBKEY}, çº¿ç¨‹: \${MINING_THREADS}${RESET}\"; \
./target/release/nockchain --threads \"\$MINING_THREADS\" 2>&1 | tee \"$LOG_FILE\""


  screen -dmS nockchain bash -c "$screen_cmd"

  # ç»™ screen ä¸€ç‚¹æ—¶é—´å¯åŠ¨
  sleep 3

  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}===============================================${RESET}"
    echo -e "${GREEN}         âœ… èŠ‚ç‚¹å·²åœ¨ screen åå°å¯åŠ¨ âœ…         ${RESET}"
    echo -e "${GREEN}===============================================${RESET}"
    if [ "$RUN_ONE_LINER_MODE" = false ]; then # Only show screen commands in interactive mode
        echo -e "å¯ä»¥ä½¿ç”¨ '${YELLOW}screen -r nockchain${RESET}' è¿›å…¥ä¼šè¯æŸ¥çœ‹å®æ—¶è¾“å‡ºã€‚"
        echo -e "ä¼šè¯å†…æŒ‰ '${YELLOW}Ctrl+A ç„¶åæŒ‰ D${RESET}' å¯é€€å‡º screen ä¼šè¯å¹¶ä¿æŒèŠ‚ç‚¹è¿è¡Œã€‚"
    fi
    echo -e "æ—¥å¿—æ–‡ä»¶: ${CYAN}$LOG_FILE${RESET}"
  else
    echo -e "${RED}===============================================${RESET}"
    echo -e "${RED}         âŒ èŠ‚ç‚¹å¯åŠ¨å¤±è´¥ âŒ         ${RESET}"
    echo -e "${RED}===============================================${RESET}"
    echo -e "è¯·å°è¯•æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶ ${CYAN}$LOG_FILE${RESET} æˆ–æ‰‹åŠ¨è¿è¡Œå‘½ä»¤è¿›è¡Œè°ƒè¯•:"
    echo -e "${YELLOW}  cd $NCK_DIR && source \"$ENV_FILE\" && export MINING_PUBKEY=\"$mining_pubkey\" && export MINING_THREADS=\"$mining_threads\" && ./target/release/nockchain --threads \"\$MINING_THREADS\"${RESET}"
    if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; else pause_and_return; return 1; fi
  fi

  if [ "$RUN_ONE_LINER_MODE" = false ]; then
      pause_and_return
  fi
}

function view_screen_logs() {
  echo -e "${CYAN}[*] æŸ¥çœ‹ screen ä¼šè¯ 'nockchain' çš„å®æ—¶æ—¥å¿—...${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] æ­£åœ¨è¿›å…¥ screen ä¼šè¯ (Ctrl+A ç„¶åæŒ‰ D å¯é€€å‡º)...${RESET}"
    # å°è¯•é™„åŠ åˆ° screen ä¼šè¯
    screen -r nockchain || echo -e "${RED}[-] æ— æ³•é™„åŠ åˆ° screen ä¼šè¯ã€‚å¯èƒ½æ˜¯æƒé™é—®é¢˜æˆ–ä¼šè¯çŠ¶æ€å¼‚å¸¸ã€‚${RESET}"
  else
    echo -e "${RED}[-] èŠ‚ç‚¹æœªåœ¨ screen ä¼šè¯ 'nockchain' ä¸­è¿è¡Œã€‚è¯·å…ˆå¯åŠ¨èŠ‚ç‚¹ã€‚${RESET}"
  fi
  pause_and_return
}

function view_log_file() {
    echo -e "${CYAN}[*] æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶ $LOG_FILE ...${RESET}"
    if [[ -f "$LOG_FILE" ]]; then
        echo -e "${YELLOW}[!] æ­£åœ¨ tail æ—¥å¿—æ–‡ä»¶ (Ctrl+C é€€å‡º)...${RESET}"
        tail -f "$LOG_FILE"
    else
        echo -e "${RED}[-] æ—¥å¿—æ–‡ä»¶ '$LOG_FILE' ä¸å­˜åœ¨ã€‚è¯·ç¡®ä¿èŠ‚ç‚¹å·²ç»è¿è¡Œè¿‡ã€‚${RESET}"
    fi
    pause_and_return
}


function stop_node() {
    echo -e "${CYAN}[*] åœæ­¢èŠ‚ç‚¹ screen ä¼šè¯...${RESET}"
    if screen -list | grep -qw "nockchain"; then
        echo -e "${YELLOW}[*] æ­£åœ¨å‘é€åœæ­¢ä¿¡å·åˆ° screen ä¼šè¯ 'nockchain'...${RESET}"
        # Send Ctrl+C to the screen session
        screen -S nockchain -X stuff "^C"
        # Give it a moment to terminate gracefully
        sleep 5
        if screen -list | grep -qw "nockchain"; then
             echo -e "${YELLOW}[*] èŠ‚ç‚¹æœªä¼˜é›…é€€å‡ºï¼Œå°è¯•å¼ºåˆ¶ç»ˆæ­¢ screen ä¼šè¯...${RESET}"
            screen -S nockchain -X quit
             sleep 2 # Give it another moment
             if screen -list | grep -qw "nockchain"; then
                 echo -e "${RED}[-] æ— æ³•ç»ˆæ­¢ screen ä¼šè¯ 'nockchain'ã€‚è¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit' æˆ– 'killall screen'${RESET}"
                 if [ "$RUN_ONE_LINER_MODE" = true ]; then exit 1; fi # In one-liner mode, fail here
             else
                 echo -e "${GREEN}[+] screen ä¼šè¯ 'nockchain' å·²å¼ºåˆ¶åœæ­¢${RESET}"
             fi
        else
            echo -e "${GREEN}[+] screen ä¼šè¯ 'nockchain' å·²ä¼˜é›…åœæ­¢${RESET}"
        fi
    else
        echo -e "${YELLOW}[*] screen ä¼šè¯ 'nockchain' æœªè¿è¡Œ${RESET}"
    fi
    if [ "$RUN_ONE_LINER_MODE" = false ]; then
        pause_and_return
    fi
}


# ========= ä¸»èœå• =========
function main_menu() {
  show_banner
  echo -e "${BOLD}è¯·é€‰æ‹©æ“ä½œ:${RESET}"
  echo -e "  ${GREEN}1) ä¸€é”®å®‰è£…å¹¶æ„å»º${RESET}"
  echo -e "  ${BLUE}2) ç”Ÿæˆé’±åŒ… (æŸ¥çœ‹è¾“å‡ºæ—¥å¿—)${RESET}"
  echo -e "  ${BLUE}3) è®¾ç½® MINING_PUBKEY åˆ° .env (æ‰‹åŠ¨è¾“å…¥)${RESET}"
  echo -e "  ${BLUE}4) å¯¼å‡ºé’±åŒ…å¯†é’¥${RESET}"
  echo -e "  ${BLUE}5) å¯¼å…¥é’±åŒ…å¯†é’¥${RESET}"
  echo -e "  ${YELLOW}6) é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°${RESET}"
  echo -e "  ${CYAN}7) å¯åŠ¨èŠ‚ç‚¹ (screen åå°)${RESET}"
  echo -e "  ${CYAN}8) æŸ¥çœ‹èŠ‚ç‚¹å®æ—¶æ—¥å¿— (screen)${RESET}"
  echo -e "  ${CYAN}9) æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶ (tail -f)${RESET}"
  echo -e "  ${RED}10) åœæ­¢èŠ‚ç‚¹${RESET}"
  echo -e "  ${RED}0) é€€å‡º${RESET}"
  echo ""
  read -p "${BOLD}è¯·è¾“å…¥ç¼–å·: ${RESET}" choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) configure_mining_threads ;;
    7) start_node ;;
    8) view_screen_logs ;;
    9) view_log_file ;;
    10) stop_node ;;
    0) echo -e "${YELLOW}é€€å‡ºè„šæœ¬.${RESET}"; exit 0 ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

# ========= å‚æ•°è§£æ =========
# Parse command line arguments
while getopts "t:p:" opt; do
  case $opt in
    t)
      THREADS_ARG="$OPTARG"
      RUN_ONE_LINER_MODE=true
      ;;
    p)
      PUBKEY_ARG="$OPTARG"
      RUN_ONE_LINER_MODE=true
      ;;
    \?) # Invalid option
      echo -e "${RED}æ— æ•ˆé€‰é¡¹: -$OPTARG${RESET}" >&2
      echo -e "${YELLOW}ç”¨æ³•: $0 [-t çº¿ç¨‹æ•°] [-p ä½ çš„å…¬é’¥]${RESET}"
      exit 1
      ;;
    :) # Option requires an argument
      echo -e "${RED}é€‰é¡¹ -$OPTARG éœ€è¦ä¸€ä¸ªå‚æ•°${RESET}" >&2
      echo -e "${YELLOW}ç”¨æ³•: $0 [-t çº¿ç¨‹æ•°] [-p ä½ çš„å…¬é’¥]${RESET}"
      exit 1
      ;;
  esac
done
shift $((OPTIND-1)) # Remove the options from the positional parameters

# ========= è„šæœ¬å…¥å£ =========

# ç¡®ä¿ä¾èµ–å‘½ä»¤å¯ç”¨
if ! command_exists screen; then
    echo -e "${RED}é”™è¯¯: screen å‘½ä»¤æœªæ‰¾åˆ°ã€‚è¯·å…ˆå®‰è£…: sudo apt install screen${RESET}"
    exit 1
fi

if ! command_exists wget && ! command_exists curl; then
    echo -e "${RED}é”™è¯¯: wget æˆ– curl å‘½ä»¤æœªæ‰¾åˆ°ã€‚è¯·å…ˆå®‰è£…å…¶ä¸­ä¸€ä¸ªã€‚${RESET}"
    exit 1
fi

# ç¡®ä¿ nproc å‘½ä»¤å¯ç”¨ (ç”¨äºè·å–æ ¸å¿ƒæ•°)
if ! command_exists nproc; then
    echo -e "${YELLOW}è­¦å‘Š: nproc å‘½ä»¤æœªæ‰¾åˆ°ï¼Œæ— æ³•è‡ªåŠ¨æ£€æµ‹æ ¸å¿ƒæ•°ã€‚é»˜è®¤æŒ–çŸ¿çº¿ç¨‹æ•°å°†è®¾ç½®ä¸º 1ã€‚${RESET}"
    # Continue, but functions using nproc need a fallback
fi

# If running in one-liner mode (parameters were provided)
if [ "$RUN_ONE_LINER_MODE" = true ]; then
    show_banner # Still show banner for clarity in one-liner output
    echo -e "${CYAN}[*] æ£€æµ‹åˆ°å‘½ä»¤è¡Œå‚æ•°ï¼Œè¿›å…¥ä¸€é”®å®‰è£…å¹¶å¯åŠ¨æ¨¡å¼...${RESET}"

    # Execute setup
    setup_all

    # If parameters were provided, update .env *after* setup_all created it (if it didn't exist)
    if [[ -n "$THREADS_ARG" ]]; then
         echo -e "${CYAN}[*] æ ¹æ®å‚æ•°è®¾ç½® MINING_THREADS=${THREADS_ARG}...${RESET}"
        update_env "MINING_THREADS" "$THREADS_ARG"
    fi
    if [[ -n "$PUBKEY_ARG" ]]; then
        echo -e "${CYAN}[*] æ ¹æ®å‚æ•°è®¾ç½® MINING_PUBKEY=${PUBKEY_ARG}...${RESET}"
        update_env "MINING_PUBKEY" "$PUBKEY_ARG"
    fi

    # Start the node
    start_node

    echo -e "${GREEN}[+] ä¸€é”®å®‰è£…å’Œå¯åŠ¨æµç¨‹å®Œæˆã€‚${RESET}"
    exit 0 # Exit after completion in one-liner mode
else
    # If no parameters, show the main menu
    main_menu
fi
