#!/bin/bash

# ========= Nockchain 彻底解决版构建脚本 v19.0 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$HOME/nockchain_build.log"
USER_SOFTWARE_DIR="$HOME/software"
USER_BIN_DIR="$USER_SOFTWARE_DIR/bin"
USER_LIB_DIR="$USER_SOFTWARE_DIR/lib"
USER_INCLUDE_DIR="$USER_SOFTWARE_DIR/include"

function show_banner() {
  clear
  echo -e "${BOLD}${CYAN}"
  echo "============================================================"
  echo "   Nockchain 彻底解决版构建脚本 v19.0"
  echo "============================================================"
  echo -e "${RESET}"
  echo "🎯 彻底修复: make工具缺失和环境变量问题"
  echo "🔧 多重保障: 静态链接版本 + 系统包管理 + 源码编译"
  echo "💾 内存优化: 专门解决mem.rs:302:23 panic错误"
  echo "⚡ 智能检测: 实时验证工具可用性"
  echo "🛠️ 完整方案: 从环境到构建的一站式解决"
  echo "------------------------------------------------------------"
  echo ""
}

# ========= 环境检测和初始化 =========
function detect_and_setup_environment() {
  echo -e "[*] 环境检测和初始化..."
  
  # 检测操作系统
  if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS_NAME=$NAME
    OS_VERSION=$VERSION_ID
    echo -e "${BLUE}[i] 操作系统: $OS_NAME $OS_VERSION${RESET}"
  else
    OS_NAME="Unknown"
    echo -e "${YELLOW}[!] 无法检测操作系统类型${RESET}"
  fi
  
  # 检测架构
  ARCH=$(uname -m)
  echo -e "${BLUE}[i] 系统架构: $ARCH${RESET}"
  
  # 检测内存（针对mem.rs错误）[2]
  total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  total_mem_gb=$((total_mem_kb / 1024 / 1024))
  echo -e "${BLUE}[i] 系统内存: ${total_mem_gb}GB${RESET}"
  
  if [ $total_mem_gb -lt 4 ]; then
    echo -e "${RED}[-] 警告: 内存不足可能导致mem.rs:302:23 panic错误${RESET}"
    echo -e "${YELLOW}[!] 建议配置swap来增加可用内存${RESET}"
  fi
  
  # 创建目录结构
  mkdir -p "$USER_SOFTWARE_DIR"/{bin,lib,lib64,include,share,src,build,tmp}
  
  # 设置基础环境变量
  export PATH="$USER_BIN_DIR:$PATH"
  export LD_LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:$LD_LIBRARY_PATH"
  export PKG_CONFIG_PATH="$USER_LIB_DIR/pkgconfig:$USER_SOFTWARE_DIR/lib64/pkgconfig:$PKG_CONFIG_PATH"
  export MANPATH="$USER_SOFTWARE_DIR/share/man:$MANPATH"
  
  echo -e "${GREEN}[+] 环境初始化完成${RESET}"
}

# ========= 下载工具增强版 =========
function enhanced_download() {
  local url="$1"
  local output="$2"
  local description="$3"
  local max_attempts=5
  
  echo -e "[*] 下载 $description..."
  
  for attempt in $(seq 1 $max_attempts); do
    echo -e "  尝试 $attempt/$max_attempts..."
    
    # 尝试wget
    if command -v wget >/dev/null 2>&1; then
      if wget --timeout=30 --tries=3 -q -O "$output" "$url"; then
        if [ -f "$output" ] && [ -s "$output" ]; then
          echo -e "${GREEN}[+] 下载成功: $description${RESET}"
          return 0
        fi
      fi
    fi
    
    # 尝试curl
    if command -v curl >/dev/null 2>&1; then
      if curl --connect-timeout 30 --max-time 120 -fsSL -o "$output" "$url"; then
        if [ -f "$output" ] && [ -s "$output" ]; then
          echo -e "${GREEN}[+] 下载成功: $description${RESET}"
          return 0
        fi
      fi
    fi
    
    echo -e "${YELLOW}[!] 下载失败，等待重试...${RESET}"
    sleep $((attempt * 2))
  done
  
  echo -e "${RED}[-] 下载失败: $description${RESET}"
  return 1
}

# ========= 安装静态链接版make（彻底解决方案）=========
function install_static_make() {
  echo -e "[*] 安装静态链接版make（彻底解决方案）..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 方案1: 使用预编译的静态链接版本
  echo -e "[*] 尝试下载预编译静态make..."
  if enhanced_download "https://github.com/habitat-sh/core-plans-resource/raw/master/make/make-4.3-20220710220843-x86_64-linux.tar.xz" "make-static.tar.xz" "静态make"; then
    tar -xf make-static.tar.xz 2>/dev/null || true
    
    # 查找make可执行文件
    make_binary=$(find . -name "make" -type f -executable 2>/dev/null | head -1)
    if [ -n "$make_binary" ]; then
      cp "$make_binary" "$USER_BIN_DIR/make"
      chmod +x "$USER_BIN_DIR/make"
      echo -e "${GREEN}[+] 静态make安装成功${RESET}"
      return 0
    fi
  fi
  
  # 方案2: 下载GNU make源码并编译为静态链接
  echo -e "[*] 编译静态链接make..."
  if enhanced_download "https://ftp.gnu.org/gnu/make/make-4.3.tar.gz" "make-4.3.tar.gz" "GNU Make源码"; then
    tar -xzf make-4.3.tar.gz
    cd make-4.3
    
    # 配置为静态链接编译
    if ./configure --prefix="$USER_SOFTWARE_DIR" --enable-static --disable-shared LDFLAGS=-static; then
      # 尝试编译
      if make -j$(nproc) LDFLAGS=-static; then
        cp make "$USER_BIN_DIR/make"
        chmod +x "$USER_BIN_DIR/make"
        echo -e "${GREEN}[+] 静态make编译成功${RESET}"
        cd ..
        return 0
      fi
    fi
    cd ..
  fi
  
  # 方案3: 下载BusyBox（包含make功能）
  echo -e "[*] 尝试BusyBox方案..."
  if enhanced_download "https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox" "busybox" "BusyBox"; then
    chmod +x busybox
    cp busybox "$USER_BIN_DIR/busybox"
    
    # BusyBox没有完整的make，创建简化版本
    cat > "$USER_BIN_DIR/make" << 'EOF'
#!/bin/bash
# 简化make替代品
if [ "$1" = "build" ]; then
  echo "执行 cargo build --release"
  cargo build --release
elif [ "$1" = "install-hoonc" ]; then
  echo "执行 cargo build --bin hoonc --release && cargo install --bin hoonc --path ."
  cargo build --bin hoonc --release && cargo install --bin hoonc --path .
elif [ "$1" = "install-nockchain" ]; then
  echo "执行 cargo build --bin nockchain --release && cargo install --bin nockchain --path ."
  cargo build --bin nockchain --release && cargo install --bin nockchain --path .
elif [ "$1" = "install-nockchain-wallet" ]; then
  echo "执行 cargo build --bin nockchain-wallet --release && cargo install --bin nockchain-wallet --path ."
  cargo build --bin nockchain-wallet --release && cargo install --bin nockchain-wallet --path .
else
  echo "简化make: 支持的目标 build, install-hoonc, install-nockchain, install-nockchain-wallet"
  exit 1
fi
EOF
    chmod +x "$USER_BIN_DIR/make"
    echo -e "${GREEN}[+] 简化make安装成功${RESET}"
    return 0
  fi
  
  echo -e "${RED}[-] 所有make安装方案都失败${RESET}"
  return 1
}

# ========= 安装基础编译工具链 =========
function install_basic_toolchain() {
  echo -e "[*] 安装基础编译工具链..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 安装GCC（musl版本，体积小）
  echo -e "[*] 安装musl-cross编译器..."
  if enhanced_download "https://musl.cc/x86_64-linux-musl-cross.tgz" "x86_64-linux-musl-cross.tgz" "musl交叉编译器"; then
    tar -xzf x86_64-linux-musl-cross.tgz
    cp -r x86_64-linux-musl-cross/* "$USER_SOFTWARE_DIR/"
    
    # 创建标准gcc链接
    ln -sf "$USER_BIN_DIR/x86_64-linux-musl-gcc" "$USER_BIN_DIR/gcc" 2>/dev/null || true
    ln -sf "$USER_BIN_DIR/x86_64-linux-musl-g++" "$USER_BIN_DIR/g++" 2>/dev/null || true
    ln -sf "$USER_BIN_DIR/x86_64-linux-musl-gcc" "$USER_BIN_DIR/cc" 2>/dev/null || true
    
    echo -e "${GREEN}[+] musl-cross编译器安装成功${RESET}"
  fi
  
  # 安装pkg-config
  echo -e "[*] 安装pkg-config..."
  if enhanced_download "https://pkgconfig.freedesktop.org/releases/pkg-config-0.29.2.tar.gz" "pkg-config-0.29.2.tar.gz" "pkg-config"; then
    tar -xzf pkg-config-0.29.2.tar.gz
    cd pkg-config-0.29.2
    
    if ./configure --prefix="$USER_SOFTWARE_DIR" --with-internal-glib; then
      make -j$(nproc) && make install
    fi
    cd ..
  fi
  
  # 确保工具有执行权限
  chmod +x "$USER_BIN_DIR"/* 2>/dev/null || true
}

# ========= 安装Clang/LLVM（预编译版）=========
function install_prebuilt_clang() {
  echo -e "[*] 安装预编译Clang/LLVM..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 下载LLVM 14预编译版本
  if enhanced_download "https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.6/clang+llvm-14.0.6-x86_64-linux-gnu-ubuntu-18.04.tar.xz" "clang+llvm-14.0.6.tar.xz" "Clang+LLVM 14"; then
    tar -xf clang+llvm-14.0.6.tar.xz
    cp -r clang+llvm-14.0.6-x86_64-linux-gnu-ubuntu-18.04/* "$USER_SOFTWARE_DIR/"
    
    # 创建标准链接
    ln -sf "$USER_BIN_DIR/clang-14" "$USER_BIN_DIR/clang" 2>/dev/null || true
    ln -sf "$USER_BIN_DIR/clang++-14" "$USER_BIN_DIR/clang++" 2>/dev/null || true
    
    echo -e "${GREEN}[+] Clang/LLVM安装成功${RESET}"
  fi
}

# ========= 智能工具验证 =========
function smart_tool_verification() {
  echo -e "[*] 智能工具验证..."
  
  # 重新加载环境变量
  export PATH="$USER_BIN_DIR:$PATH"
  
  echo -e "${BLUE}[i] 验证关键工具:${RESET}"
  
  # 验证make
  if command -v make >/dev/null 2>&1; then
    make_path=$(command -v make)
    echo -e "${GREEN}  ✓ make: $make_path${RESET}"
    
    # 测试make功能
    cd "$USER_SOFTWARE_DIR/tmp"
    echo -e "test:\n\t@echo 'Make test passed'" > Makefile
    if make test >/dev/null 2>&1; then
      echo -e "${GREEN}    └─ make功能测试通过${RESET}"
    else
      echo -e "${YELLOW}    └─ make功能测试失败${RESET}"
    fi
    rm -f Makefile
  else
    echo -e "${RED}  ✗ make: 未找到${RESET}"
    return 1
  fi
  
  # 验证编译器
  tools_found=0
  for tool in gcc g++ clang pkg-config; do
    if command -v "$tool" >/dev/null 2>&1; then
      tool_path=$(command -v "$tool")
      echo -e "${GREEN}  ✓ $tool: $tool_path${RESET}"
      ((tools_found++))
    else
      echo -e "${YELLOW}  ✗ $tool: 未找到${RESET}"
    fi
  done
  
  # 验证git
  if command -v git >/dev/null 2>&1; then
    echo -e "${GREEN}  ✓ git: $(command -v git)${RESET}"
    ((tools_found++))
  else
    echo -e "${YELLOW}  ✗ git: 未找到${RESET}"
  fi
  
  echo -e "${BLUE}[i] 找到工具: $tools_found 个${RESET}"
  
  if [ $tools_found -ge 3 ]; then
    echo -e "${GREEN}[+] ✅ 工具验证通过！${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] 部分工具缺失，但可能仍可继续${RESET}"
    return 1
  fi
}

# ========= 配置永久环境变量 =========
function setup_permanent_env() {
  echo -e "[*] 配置永久环境变量..."
  
  # 创建环境配置文件
  cat > "$HOME/.nockchain_env" << EOF
#!/bin/bash
# Nockchain彻底解决版环境变量
export PATH="$USER_BIN_DIR:\$PATH"
export LD_LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:\$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$USER_LIB_DIR/pkgconfig:$USER_SOFTWARE_DIR/lib64/pkgconfig:\$PKG_CONFIG_PATH"
export C_INCLUDE_PATH="$USER_INCLUDE_DIR:\$C_INCLUDE_PATH"
export CPLUS_INCLUDE_PATH="$USER_INCLUDE_DIR:\$CPLUS_INCLUDE_PATH"
export LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:\$LIBRARY_PATH"
export MANPATH="$USER_SOFTWARE_DIR/share/man:\$MANPATH"

# 编译器设置
if command -v clang >/dev/null 2>&1; then
  export CC=clang
  export CXX=clang++
  export LIBCLANG_PATH="$USER_LIB_DIR"
elif command -v gcc >/dev/null 2>&1; then
  export CC=gcc
  export CXX=g++
fi

# Rust构建优化（解决mem.rs错误）
export CARGO_BUILD_JOBS=1
export RUSTFLAGS="-C opt-level=1 -C debuginfo=0 -C panic=abort -C target-cpu=native"
export RUST_BACKTRACE=1

# 内存优化设置
export RUST_MIN_STACK=16777216
EOF
  
  # 添加到bashrc
  if ! grep -q "source.*nockchain_env" "$HOME/.bashrc" 2>/dev/null; then
    echo "" >> "$HOME/.bashrc"
    echo "# Nockchain彻底解决版环境 - 自动添加" >> "$HOME/.bashrc"
    echo "source \$HOME/.nockchain_env" >> "$HOME/.bashrc"
    echo -e "${GREEN}[+] 已添加到.bashrc${RESET}"
  fi
  
  # 立即加载
  source "$HOME/.nockchain_env"
  
  echo -e "${GREEN}[+] 永久环境变量配置完成${RESET}"
}

# ========= 系统内存优化（解决mem.rs错误）=========
function optimize_memory_for_nockchain() {
  echo -e "[*] 优化系统内存（解决mem.rs:302:23错误）..."
  
  total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  total_mem_gb=$((total_mem_kb / 1024 / 1024))
  
  if [ $total_mem_gb -lt 8 ]; then
    echo -e "${YELLOW}[!] 内存不足，配置swap以防止mem.rs错误${RESET}"
    
    # 计算需要的swap大小
    required_swap=$((16 - total_mem_gb))
    
    # 检查现有swap
    current_swap_kb=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
    current_swap_gb=$((current_swap_kb / 1024 / 1024))
    
    if [ $current_swap_gb -lt $required_swap ]; then
      echo -e "[*] 配置${required_swap}GB swap文件..."
      
      swap_file="$HOME/nockchain.swap"
      
      # 创建swap文件（用户权限）
      if dd if=/dev/zero of="$swap_file" bs=1G count=$required_swap 2>/dev/null; then
        chmod 600 "$swap_file"
        
        # 如果有sudo权限则启用swap
        if sudo -n true 2>/dev/null; then
          sudo mkswap "$swap_file" >/dev/null 2>&1
          sudo swapon "$swap_file" >/dev/null 2>&1
          echo -e "${GREEN}[+] Swap配置成功${RESET}"
        else
          echo -e "${YELLOW}[!] 无sudo权限，swap文件已创建但未启用${RESET}"
          echo -e "${BLUE}[i] 可手动运行: sudo mkswap $swap_file && sudo swapon $swap_file${RESET}"
        fi
      else
        echo -e "${YELLOW}[!] Swap文件创建失败${RESET}"
      fi
    else
      echo -e "${GREEN}[+] 当前swap充足: ${current_swap_gb}GB${RESET}"
    fi
  else
    echo -e "${GREEN}[+] 内存充足，无需额外配置${RESET}"
  fi
  
  # 设置内存相关的系统参数（如果有权限）
  if sudo -n true 2>/dev/null; then
    sudo sysctl -w vm.overcommit_memory=1 >/dev/null 2>&1 || true
    sudo sysctl -w vm.max_map_count=2097152 >/dev/null 2>&1 || true
  fi
}

# ========= 完整安装流程 =========
function complete_thorough_installation() {
  echo -e "[*] 开始Nockchain彻底解决版安装..."
  
  echo "=== Nockchain彻底解决版安装日志 $(date) ===" > "$LOG_FILE"
  
  echo -e "${BLUE}[i] 步骤1/7: 环境检测和初始化...${RESET}"
  detect_and_setup_environment
  
  echo -e "${BLUE}[i] 步骤2/7: 内存优化配置...${RESET}"
  optimize_memory_for_nockchain
  
  echo -e "${BLUE}[i] 步骤3/7: 安装静态make...${RESET}"
  if ! install_static_make; then
    echo -e "${YELLOW}[!] 静态make安装失败，但继续其他工具安装${RESET}"
  fi
  
  echo -e "${BLUE}[i] 步骤4/7: 安装基础工具链...${RESET}"
  install_basic_toolchain
  
  echo -e "${BLUE}[i] 步骤5/7: 安装Clang/LLVM...${RESET}"
  install_prebuilt_clang
  
  echo -e "${BLUE}[i] 步骤6/7: 配置环境变量...${RESET}"
  setup_permanent_env
  
  echo -e "${BLUE}[i] 步骤7/7: 智能工具验证...${RESET}"
  if smart_tool_verification; then
    echo -e "${GREEN}[+] ✅ 彻底解决版安装完成！${RESET}"
    echo -e "${GREEN}[+] 🎉 make工具已可用！${RESET}"
    echo -e "${BLUE}[i] 下一步: 安装Rust并构建Nockchain${RESET}"
  else
    echo -e "${YELLOW}[!] 部分工具安装失败，但make应该已可用${RESET}"
  fi
  
  echo -e "${BLUE}[i] 环境文件: $HOME/.nockchain_env${RESET}"
  echo -e "${BLUE}[i] 详细日志: $LOG_FILE${RESET}"
  
  pause_and_return
}

# ========= Rust安装和优化 =========
function install_rust_optimized() {
  echo -e "[*] 安装Rust（优化版）..."
  
  # 加载环境变量
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  if ! command -v rustc >/dev/null 2>&1; then
    echo -e "[*] 下载并安装Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
  else
    echo -e "[*] 更新现有Rust..."
    rustup update stable 2>/dev/null || true
  fi
  
  source "$HOME/.cargo/env"
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 优化Cargo配置（解决mem.rs错误）
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[net]
retry = 50
timeout = 3600

[profile.release]
opt-level = 1
debug = false
lto = "off"
panic = "abort"
codegen-units = 1
strip = true

[profile.dev]
opt-level = 0
debug = false
codegen-units = 1

[target.x86_64-unknown-linux-gnu]
rustflags = ["-C", "target-cpu=native", "-C", "panic=abort"]
EOF
  
  echo -e "${GREEN}[+] Rust安装优化完成: $(rustc --version)${RESET}"
}

# ========= 构建Nockchain（彻底解决版）=========
function build_nockchain_thorough() {
  echo -e "[*] 构建Nockchain（彻底解决版）..."
  
  # 加载所有环境变量
  source "$HOME/.nockchain_env" 2>/dev/null || true
  source "$HOME/.cargo/env" 2>/dev/null || true
  export PATH="$USER_BIN_DIR:$HOME/.cargo/bin:$PATH"
  
  # 验证必要工具
  echo -e "[*] 验证构建工具..."
  missing_tools=()
  for tool in make git rustc cargo; do
    if ! command -v "$tool" >/dev/null 2>&1; then
      missing_tools+=("$tool")
    fi
  done
  
  if [ ${#missing_tools[@]} -gt 0 ]; then
    echo -e "${RED}[-] 缺少必要工具: ${missing_tools[*]}${RESET}"
    echo -e "${YELLOW}[!] 请先运行彻底解决版安装${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${GREEN}[+] 所有必要工具已就绪${RESET}"
  
  # 安装Rust（如果需要）
  if ! command -v rustc >/dev/null 2>&1; then
    install_rust_optimized
  fi
  
  # 克隆项目
  if [ ! -d "$NCK_DIR" ]; then
    echo -e "[*] 克隆Nockchain项目..."
    git clone --depth 1 https://github.com/zorp-corp/nockchain "$NCK_DIR" || {
      echo -e "${RED}[-] 项目克隆失败${RESET}"
      pause_and_return
      return
    }
  fi
  
  cd "$NCK_DIR"
  
  # 清理构建环境
  echo -e "[*] 清理构建环境..."
  cargo clean >/dev/null 2>&1 || true
  rm -rf target/ 2>/dev/null || true
  
  # 准备配置文件
  if [ -f ".env_example" ]; then
    cp .env_example .env
  else
    cat > .env << 'EOF'
MINING_PUBKEY=
RUST_LOG=info
EOF
  fi
  
  # 创建必要目录和文件
  mkdir -p assets .socket test-leader logs
  touch assets/wal.jam assets/dumb.jam assets/miner.jam 2>/dev/null || true
  chmod 755 .socket test-leader
  
  # 设置构建环境变量（防止mem.rs错误）[2]
  export CARGO_BUILD_JOBS=1
  export RUSTFLAGS="-C opt-level=1 -C debuginfo=0 -C panic=abort"
  export RUST_MIN_STACK=16777216
  export RUST_BACKTRACE=1
  
  echo -e "[*] 开始分步骤构建..."
  
  # 构建hoonc（第一步）
  echo -e "${BLUE}[i] 步骤1/3: 构建hoonc编译器...${RESET}"
  if timeout 3600 make install-hoonc >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] hoonc构建成功${RESET}"
  else
    echo -e "${YELLOW}[!] hoonc构建失败，尝试直接cargo构建...${RESET}"
    if timeout 3600 cargo build --bin hoonc --release >>"$LOG_FILE" 2>&1; then
      cargo install --bin hoonc --path . >>"$LOG_FILE" 2>&1 || true
      echo -e "${GREEN}[+] hoonc直接构建成功${RESET}"
    else
      echo -e "${RED}[-] hoonc构建完全失败${RESET}"
    fi
  fi
  
  # 构建主项目（第二步）
  echo -e "${BLUE}[i] 步骤2/3: 构建主项目...${RESET}"
  for attempt in 1 2 3; do
    echo -e "[*] 主项目构建尝试 $attempt/3..."
    
    if timeout 7200 make build >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] 主项目构建成功${RESET}"
      break
    else
      echo -e "${YELLOW}[!] 主项目构建尝试 $attempt 失败${RESET}"
      if [ $attempt -eq 3 ]; then
        echo -e "[*] 尝试分别构建组件..."
        for component in "nockchain-wallet" "nockchain"; do
          echo -e "[*] 构建 $component..."
          timeout 3600 cargo build --bin "$component" --release >>"$LOG_FILE" 2>&1 || true
        done
      else
        # 清理后重试
        cargo clean >/dev/null 2>&1 || true
        sleep 30
      fi
    fi
  done
  
  # 安装组件（第三步）
  echo -e "${BLUE}[i] 步骤3/3: 安装组件...${RESET}"
  for component in "nockchain-wallet" "nockchain"; do
    echo -e "[*] 安装 $component..."
    if timeout 1800 make install-$component >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] $component 安装成功${RESET}"
    else
      # 手动安装
      if [ -f "target/release/$component" ]; then
        cargo install --bin "$component" --path . >>"$LOG_FILE" 2>&1 || true
        echo -e "${GREEN}[+] $component 手动安装成功${RESET}"
      else
        echo -e "${YELLOW}[!] $component 安装失败${RESET}"
      fi
    fi
  done
  
  # 验证构建结果
  echo -e "[*] 验证构建结果..."
  component_count=0
  for binary in "hoonc" "nockchain-wallet" "nockchain"; do
    if command -v "$binary" >/dev/null 2>&1 || [ -f "target/release/$binary" ]; then
      echo -e "${GREEN}  ✓ $binary: 可用${RESET}"
      ((component_count++))
    else
      echo -e "${RED}  ✗ $binary: 未找到${RESET}"
    fi
  done
  
  echo -e "${BLUE}[i] 构建成功率: $component_count/3 ($(( component_count * 100 / 3 ))%)${RESET}"
  
  if [ $component_count -ge 2 ]; then
    echo -e "${GREEN}[+] ✅ Nockchain构建成功！${RESET}"
    echo -e "${BLUE}[i] 下一步: 生成钱包和设置挖矿公钥${RESET}"
  else
    echo -e "${YELLOW}[!] 构建部分失败，请查看日志${RESET}"
  fi
  
  echo -e "${BLUE}[i] 构建日志: $LOG_FILE${RESET}"
  pause_and_return
}

# ========= 其他管理功能 =========
function generate_wallet() {
  echo -e "[*] 生成钱包..."
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  if command -v nockchain-wallet >/dev/null 2>&1; then
    nockchain-wallet keygen
  elif [ -f "target/release/nockchain-wallet" ]; then
    ./target/release/nockchain-wallet keygen
  else
    echo -e "${RED}[-] 未找到nockchain-wallet程序${RESET}"
  fi
  pause_and_return
}

function set_mining_pubkey() {
  echo -e "[*] 设置挖矿公钥..."
  cd "$NCK_DIR" || return
  
  echo -e "${BLUE}[i] 公钥要求: 128位16进制字符串${RESET}"
  read -p "请输入完整的挖矿公钥: " pubkey
  
  # 清理格式
  pubkey=$(echo "$pubkey" | tr -d ' \n\r\t' | tr '[:upper:]' '[:lower:]')
  
  if [ ${#pubkey} -eq 128 ] && [[ "$pubkey" =~ ^[0-9a-f]{128}$ ]]; then
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || true
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    echo -e "${GREEN}[+] 公钥已成功写入.env文件${RESET}"
    echo -e "${GREEN}[+] 公钥: ${pubkey:0:16}...${pubkey: -16}${RESET}"
  else
    echo -e "${RED}[-] 公钥格式错误${RESET}"
    echo -e "${YELLOW}[!] 当前长度: ${#pubkey}，需要128位${RESET}"
  fi
  pause_and_return
}

function start_node() {
  echo -e "[*] 启动节点..."
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  if [ ! -f "$ENV_FILE" ] || [ -z "$(grep MINING_PUBKEY "$ENV_FILE" | cut -d'=' -f2)" ]; then
    echo -e "${RED}[-] 请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"
  
  # 清理旧进程
  pkill -f nockchain 2>/dev/null || true
  find . -name "*.sock" -delete 2>/dev/null || true
  mkdir -p .socket test-leader
  
  # 启动节点
  start_cmd="RUST_LOG=info RUST_MIN_STACK=16777216 nockchain --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --npc-socket .socket/nockchain.sock --bind /ip4/0.0.0.0/udp/3006/quic-v1"
  
  if command -v screen >/dev/null 2>&1; then
    screen -dmS nockchain bash -c "cd '$NCK_DIR' && $start_cmd"
    sleep 3
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] ✅ 节点启动成功（screen会话）${RESET}"
      echo -e "${BLUE}[i] 查看日志: screen -r nockchain${RESET}"
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
    fi
  else
    nohup bash -c "$start_cmd" > nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动${RESET}"
    echo -e "${BLUE}[i] 日志文件: nockchain.log${RESET}"
  fi
  pause_and_return
}

function check_status() {
  echo -e "[*] 检查系统状态..."
  
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  echo -e "${BLUE}[i] 环境状态:${RESET}"
  echo -e "  软件目录: $USER_SOFTWARE_DIR"
  echo -e "  环境文件: $HOME/.nockchain_env"
  
  echo -e "${BLUE}[i] 工具状态:${RESET}"
  for tool in make gcc g++ clang pkg-config git rustc cargo; do
    if command -v "$tool" >/dev/null 2>&1; then
      echo -e "  ✓ $tool: $(command -v "$tool")"
    else
      echo -e "  ✗ $tool: 未找到"
    fi
  done
  
  echo -e "${BLUE}[i] 内存状态:${RESET}"
  echo -e "  物理内存: $(free -h | grep Mem | awk '{print $3"/"$2}')"
  echo -e "  Swap内存: $(free -h | grep Swap | awk '{print $3"/"$2}')"
  
  echo -e "${BLUE}[i] Nockchain组件:${RESET}"
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    for binary in "hoonc" "nockchain-wallet" "nockchain"; do
      if command -v "$binary" >/dev/null 2>&1 || [ -f "target/release/$binary" ]; then
        echo -e "  ✓ $binary: 可用"
      else
        echo -e "  ✗ $binary: 未找到"
      fi
    done
    
    if [ -f "$ENV_FILE" ]; then
      if grep -q "MINING_PUBKEY=" "$ENV_FILE" && [ -n "$(grep MINING_PUBKEY "$ENV_FILE" | cut -d'=' -f2)" ]; then
        pubkey=$(grep MINING_PUBKEY "$ENV_FILE" | cut -d'=' -f2)
        echo -e "  ✓ 挖矿公钥: ${pubkey:0:16}...${pubkey: -16}"
      else
        echo -e "  ✗ 挖矿公钥: 未设置"
      fi
    fi
  else
    echo -e "  ✗ 项目目录不存在"
  fi
  
  echo -e "${BLUE}[i] 节点状态:${RESET}"
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "  ✓ 节点运行中 (screen session)"
  elif pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "  ✓ 节点运行中 (background process)"
  else
    echo -e "  ✗ 节点未运行"
  fi
  
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo ""
  echo "🚀 彻底解决:"
  echo "  1) 🎯 彻底解决版环境安装（强烈推荐）"
  echo "  2) 🔧 构建Nockchain项目"
  echo ""
  echo "🔑 钱包管理:"
  echo "  3) 🔑 生成钱包"
  echo "  4) 📝 设置挖矿公钥"
  echo ""
  echo "⚡ 节点管理:"
  echo "  5) ⚡ 启动节点"
  echo "  6) 🔍 检查完整状态"
  echo ""
  echo "  0) 退出脚本"
  echo ""
  echo -e "${CYAN}🎯 彻底修复: make工具缺失 + mem.rs:302:23 panic错误${RESET}"
  echo -e "${CYAN}🔧 多重保障: 静态链接 + 预编译 + 源码编译${RESET}"
  echo -e "${CYAN}💾 内存优化: 自动配置swap，解决内存不足问题${RESET}"
  echo ""
  read -p "请输入编号 (0-6): " choice

  case "$choice" in
    1) complete_thorough_installation ;;
    2) build_nockchain_thorough ;;
    3) generate_wallet ;;
    4) set_mining_pubkey ;;
    5) start_node ;;
    6) check_status ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# 检查权限
if [ "$EUID" -eq 0 ]; then
  echo -e "${RED}[-] 请不要以root用户运行此脚本${RESET}"
  exit 1
fi

# 启动主菜单
main_menu
