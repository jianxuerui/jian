#!/bin/bash

# ========= 色彩定义 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= 项目路径 =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= 工作目录修复 =========
function fix_working_directory() {
  if ! pwd >/dev/null 2>&1; then
    echo -e "${YELLOW}[!] 当前工作目录无法访问，切换到HOME目录...${RESET}"
    cd "$HOME" || cd / || {
      echo -e "${RED}[-] 无法访问任何有效目录${RESET}"
      exit 1
    }
  fi
  
  current_dir=$(pwd 2>/dev/null)
  if [ -z "$current_dir" ] || [ ! -d "$current_dir" ]; then
    echo -e "${YELLOW}[!] 工作目录异常，重置到HOME目录...${RESET}"
    cd "$HOME" || cd / || exit 1
  fi
  
  echo -e "${GREEN}[+] 工作目录检查完成: $(pwd)${RESET}"
}

# ========= 兼容性检测 =========
function check_system() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    OS="linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    OS="macos"
    echo -e "${YELLOW}[!] 检测到 macOS，某些优化功能可能不可用${RESET}"
  else
    OS="unknown"
    echo -e "${YELLOW}[!] 未知操作系统，请谨慎使用${RESET}"
  fi
  
  if ! sudo -n true 2>/dev/null; then
    echo -e "${YELLOW}[!] 需要sudo权限进行系统优化${RESET}"
  fi
}

# ========= 横幅 =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain 挖矿优化助手 v2.4"
  echo "==============================================="
  echo -e "${RESET}"
  echo "📌 作者: K2 节点教程分享"
  echo "🔗 Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "🐦 Twitter:  https://x.com/BtcK241918"
  echo "⚡ 优化版本: 修复构建问题 + Cargo缓存清理"
  echo "-----------------------------------------------"
  echo ""
}

function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || {
      echo -e "${RED}[-] 无法进入项目目录: $NCK_DIR${RESET}"
      exit 1
    }
  else
    echo -e "${RED}[-] 项目目录不存在: $NCK_DIR${RESET}"
    exit 1
  fi
}

function optimize_system() {
  echo -e "${YELLOW}[*] 应用系统级性能优化...${RESET}"
  
  check_system
  
  if [[ "$OS" == "linux" ]]; then
    cpu_gov_files=$(find /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor 2>/dev/null || true)
    
    if [ -n "$cpu_gov_files" ]; then
      echo "$cpu_gov_files" | while read -r gov; do
        if [ -w "$gov" ] && [ -f "$gov" ]; then
          echo performance | sudo tee "$gov" >/dev/null 2>&1 || true
        fi
      done
      echo -e "${GREEN}[+] CPU性能模式已设置${RESET}"
    else
      echo -e "${YELLOW}[!] 未找到CPU调速器文件，跳过CPU优化${RESET}"
    fi
    
    if command -v sysctl >/dev/null 2>&1; then
      sudo sysctl -w net.core.rmem_max=16777216 >/dev/null 2>&1 || true
      sudo sysctl -w net.core.wmem_max=16777216 >/dev/null 2>&1 || true
      echo -e "${GREEN}[+] 网络参数优化完成${RESET}"
    else
      echo -e "${YELLOW}[!] sysctl命令不可用，跳过网络优化${RESET}"
    fi
  else
    echo -e "${YELLOW}[!] 非Linux系统，跳过系统级优化${RESET}"
  fi
  
  echo -e "${GREEN}[+] 系统优化完成${RESET}"
}

function install_dependencies() {
  echo -e "[*] 安装系统依赖..."
  
  if [[ "$OS" == "linux" ]]; then
    if command -v apt >/dev/null 2>&1; then
      sudo apt update -qq
      sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen htop unzip
    elif command -v yum >/dev/null 2>&1; then
      sudo yum groupinstall -y "Development Tools"
      sudo yum install -y clang llvm-devel openssl-devel cmake curl git make screen htop unzip
    elif command -v pacman >/dev/null 2>&1; then
      sudo pacman -S --noconfirm clang llvm pkg-config openssl cmake curl git make screen htop unzip
    else
      echo -e "${RED}[-] 未识别的包管理器，请手动安装依赖${RESET}"
      return 1
    fi
  elif [[ "$OS" == "macos" ]]; then
    if command -v brew >/dev/null 2>&1; then
      brew install llvm openssl cmake curl git make screen htop unzip
    else
      echo -e "${RED}[-] 请先安装 Homebrew${RESET}"
      return 1
    fi
  fi
  
  echo -e "${GREEN}[+] 系统依赖安装完成${RESET}"
  return 0
}

function clean_cargo_cache() {
  echo -e "[*] 清理Cargo缓存..."
  
  # 清理registry缓存
  if [ -d "$HOME/.cargo/registry" ]; then
    echo -e "${YELLOW}[*] 清理registry缓存...${RESET}"
    rm -rf "$HOME/.cargo/registry/cache"
    rm -rf "$HOME/.cargo/registry/src"
  fi
  
  # 清理git缓存
  if [ -d "$HOME/.cargo/git" ]; then
    echo -e "${YELLOW}[*] 清理git缓存...${RESET}"
    rm -rf "$HOME/.cargo/git/db"
    rm -rf "$HOME/.cargo/git/checkouts"
  fi
  
  # 更新cargo index
  cargo search --limit 0 >/dev/null 2>&1 || true
  
  echo -e "${GREEN}[+] Cargo缓存清理完成${RESET}"
}

function setup_rust() {
  echo -e "[*] 安装 Rust 工具链..."
  
  if ! command -v cargo &>/dev/null; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source "$HOME/.cargo/env"
  fi

  # 更新Rust工具链
  rustup update stable >/dev/null 2>&1 || true
  
  # 配置环境变量
  for rc_file in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
    if [ -f "$rc_file" ] && ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$rc_file"; then
      echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    fi
  done
  
  # 确保当前会话可用
  export PATH="$HOME/.cargo/bin:$PATH"
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  # 清理缓存
  clean_cargo_cache
  
  echo -e "${GREEN}[+] Rust工具链安装完成${RESET}"
}

function safe_remove_directory() {
  local dir="$1"
  if [ -d "$dir" ]; then
    echo -e "${YELLOW}[*] 安全删除目录: $dir${RESET}"
    if [[ "$(pwd)" == "$dir"* ]]; then
      cd "$HOME" || cd /
    fi
    rm -rf "$dir"
  fi
}

function clone_repository() {
  echo -e "[*] 获取Nockchain仓库..."
  
  fix_working_directory
  cd "$HOME" || {
    echo -e "${RED}[-] 无法访问HOME目录${RESET}"
    return 1
  }
  
  if [ -d "$NCK_DIR" ]; then
    echo -e "${YELLOW}[*] 发现现有目录，检查git仓库状态...${RESET}"
    
    cd "$NCK_DIR" 2>/dev/null && {
      if git status >/dev/null 2>&1; then
        echo -e "${YELLOW}[*] 发现有效git仓库，尝试更新...${RESET}"
        if git pull origin main 2>/dev/null || git pull origin master 2>/dev/null; then
          echo -e "${GREEN}[+] 仓库更新成功${RESET}"
          return 0
        else
          echo -e "${YELLOW}[!] 更新失败，重新克隆...${RESET}"
        fi
      else
        echo -e "${YELLOW}[!] 目录存在但不是git仓库，重新克隆...${RESET}"
      fi
    } || {
      echo -e "${YELLOW}[!] 无法访问现有目录，重新克隆...${RESET}"
    }
    
    cd "$HOME"
    safe_remove_directory "$NCK_DIR"
  fi
  
  cd "$HOME" || {
    echo -e "${RED}[-] 无法访问HOME目录进行克隆${RESET}"
    return 1
  }
  
  echo -e "[*] 开始克隆仓库到: $NCK_DIR"
  
  clone_success=false
  
  if git clone https://github.com/zorp-corp/nockchain "$NCK_DIR" 2>/dev/null; then
    clone_success=true
  else
    echo -e "${YELLOW}[!] HTTPS克隆失败，尝试其他方法...${RESET}"
    
    mkdir -p "$NCK_DIR" 2>/dev/null
    if cd "$NCK_DIR" 2>/dev/null; then
      if git clone https://github.com/zorp-corp/nockchain . 2>/dev/null; then
        clone_success=true
      else
        cd "$HOME"
        safe_remove_directory "$NCK_DIR"
        
        echo -e "${YELLOW}[!] Git克隆失败，尝试下载zip包...${RESET}"
        if curl -L "https://github.com/zorp-corp/nockchain/archive/refs/heads/main.zip" -o nockchain.zip 2>/dev/null; then
          if command -v unzip >/dev/null 2>&1; then
            unzip -q nockchain.zip && mv nockchain-main "$NCK_DIR" 2>/dev/null && {
              rm -f nockchain.zip
              clone_success=true
            }
          else
            echo -e "${RED}[-] 需要unzip命令来解压文件${RESET}"
          fi
        fi
      fi
    fi
  fi
  
  if [ "$clone_success" = true ] && [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    echo -e "${GREEN}[+] 仓库获取成功${RESET}"
    return 0
  else
    echo -e "${RED}[-] 仓库获取失败${RESET}"
    return 1
  fi
}

function build_hoonc() {
  echo -e "[*] 构建hoonc工具..."
  
  cd_nck_dir
  
  # 检查hoonc目录
  if [ ! -d "crates/hoonc" ]; then
    echo -e "${YELLOW}[!] 未找到hoonc源码目录${RESET}"
    return 1
  fi
  
  # 尝试多种方式构建hoonc
  hoonc_success=false
  
  # 方法1: 直接cargo install
  echo -e "[*] 尝试直接安装hoonc..."
  if cargo install --path crates/hoonc --bin hoonc --force; then
    hoonc_success=true
    echo -e "${GREEN}[+] hoonc安装成功 (方法1)${RESET}"
  else
    echo -e "${YELLOW}[!] 方法1失败，尝试不使用锁定...${RESET}"
    
    # 方法2: 不使用locked参数
    if cargo install --path crates/hoonc --bin hoonc --force --no-default-features; then
      hoonc_success=true
      echo -e "${GREEN}[+] hoonc安装成功 (方法2)${RESET}"
    else
      echo -e "${YELLOW}[!] 方法2失败，尝试本地构建...${RESET}"
      
      # 方法3: 本地构建
      cd crates/hoonc
      if cargo build --release --bin hoonc; then
        # 手动复制到cargo bin目录
        mkdir -p "$HOME/.cargo/bin"
        cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null || {
          cp ../../target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null
        }
        hoonc_success=true
        echo -e "${GREEN}[+] hoonc构建成功 (方法3)${RESET}"
      fi
      cd "$NCK_DIR"
    fi
  fi
  
  # 验证hoonc是否可用
  if command -v hoonc >/dev/null 2>&1; then
    echo -e "${GREEN}[+] hoonc工具验证成功${RESET}"
    return 0
  elif [ -f "$HOME/.cargo/bin/hoonc" ]; then
    echo -e "${GREEN}[+] hoonc已安装到 $HOME/.cargo/bin/hoonc${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] hoonc构建可能失败，但继续尝试主项目构建${RESET}"
    return 1
  fi
}

function build_project() {
  echo -e "[*] 开始构建Nockchain项目..."
  
  cd_nck_dir
  
  # 设置优化编译参数
  export RUSTFLAGS="-C target-cpu=native -C opt-level=3 -C codegen-units=1"
  if rustc --print target-features 2>/dev/null | grep -q lto; then
    export RUSTFLAGS="$RUSTFLAGS -C lto=fat"
    export CARGO_PROFILE_RELEASE_LTO=true
  fi
  export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
  export CARGO_PROFILE_RELEASE_PANIC="abort"
  
  # 首先尝试构建hoonc
  build_hoonc
  
  echo -e "[*] 构建主项目..."
  
  # 清理之前的构建
  cargo clean >/dev/null 2>&1 || true
  
  # 更新依赖
  echo -e "[*] 更新项目依赖..."
  cargo update >/dev/null 2>&1 || true
  
  # 尝试Cargo构建
  if [ -f "Cargo.toml" ]; then
    echo -e "[*] 使用Cargo构建项目..."
    
    # 尝试完整构建
    if cargo build --release 2>/dev/null; then
      echo -e "${GREEN}[+] 项目构建成功${RESET}"
      
      # 检查生成的二进制文件
      if [ -f "target/release/nockchain-wallet" ]; then
        echo -e "${GREEN}[+] 钱包程序构建成功${RESET}"
      fi
      
      if [ -f "target/release/nockchain" ] || [ -f "target/release/nockchain-miner" ]; then
        echo -e "${GREEN}[+] 节点程序构建成功${RESET}"
      fi
      
      return 0
    else
      echo -e "${YELLOW}[!] 完整构建失败，尝试单独构建组件...${RESET}"
      
      # 尝试构建工作区中的所有包
      for package in $(cargo metadata --format-version 1 2>/dev/null | grep '"name"' | cut -d'"' -f4 | head -10); do
        echo -e "[*] 尝试构建包: $package"
        cargo build --release --package "$package" 2>/dev/null && {
          echo -e "${GREEN}[+] 包 $package 构建成功${RESET}"
        } || {
          echo -e "${YELLOW}[!] 包 $package 构建失败${RESET}"
        }
      done
    fi
  fi
  
  # 尝试Makefile构建
  if [ -f "Makefile" ]; then
    echo -e "[*] 尝试使用Makefile构建..."
    
    # 修复Makefile中的问题
    if grep -q "cargo install --locked" Makefile; then
      echo -e "[*] 修复Makefile中的锁定参数..."
      sed -i.bak 's/cargo install --locked/cargo install --force/g' Makefile 2>/dev/null || true
    fi
    
    for target in "build" "all" "release" "build-release" "install" "compile"; do
      if make -n "$target" >/dev/null 2>&1; then
        echo -e "[*] 尝试构建目标: $target"
        if make "$target" 2>/dev/null; then
          echo -e "${GREEN}[+] 构建成功 (目标: $target)${RESET}"
          return 0
        fi
      fi
    done
  fi
  
  # 检查是否有任何二进制文件生成
  if find . -name "nockchain*" -type f -executable 2>/dev/null | grep -q .; then
    echo -e "${GREEN}[+] 发现已构建的二进制文件${RESET}"
    return 0
  fi
  
  echo -e "${YELLOW}[!] 构建可能有问题，但可以继续配置${RESET}"
  return 1
}

function setup_environment() {
  echo -e "[*] 设置环境配置..."
  cd_nck_dir
  
  # 创建.env文件
  if [ -f ".env.example" ] || [ -f ".env_example" ]; then
    if [ -f ".env.example" ]; then
      cp -n .env.example "$ENV_FILE"
    else
      cp -n .env_example "$ENV_FILE"
    fi
    echo -e "${GREEN}[+] 从示例文件创建.env${RESET}"
  else
    echo -e "${YELLOW}[!] 未找到示例文件，创建基本.env文件${RESET}"
    cat > "$ENV_FILE" << 'EOF'
# Nockchain Configuration
MINING_PUBKEY=
RUST_LOG=info
EOF
  fi
  
  echo -e "${GREEN}[+] 环境配置完成${RESET}"
}

function setup_all() {
  echo -e "[*] 开始优化安装流程..."
  
  fix_working_directory
  optimize_system
  
  if ! install_dependencies; then
    echo -e "${RED}[-] 依赖安装失败${RESET}"
    pause_and_return
    return
  fi
  
  setup_rust
  
  if ! clone_repository; then
    echo -e "${RED}[-] 仓库获取失败${RESET}"
    echo -e "${YELLOW}[!] 请检查网络连接或手动下载项目${RESET}"
    pause_and_return
    return
  fi
  
  setup_environment
  
  if build_project; then
    echo -e "${GREEN}[+] 项目安装完成！${RESET}"
  else
    echo -e "${YELLOW}[!] 构建可能有问题，请手动检查${RESET}"
  fi
  
  pause_and_return
}

function generate_wallet() {
  echo -e "[*] 生成钱包..."
  cd_nck_dir
  
  # 查找钱包二进制文件
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    echo -e "${YELLOW}[!] 请先完成项目构建${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${GREEN}[+] 使用钱包: $wallet_bin${RESET}"
  "$wallet_bin" keygen
  
  echo -e "${YELLOW}[!] 钱包生成完成，请复制上方公钥到下一步设置中${RESET}"
  echo -e "${BLUE}[i] 公钥格式为128位16进制字符串${RESET}"
  pause_and_return
}

function validate_pubkey() {
  local pubkey="$1"
  
  if [ ${#pubkey} -ne 128 ]; then
    echo -e "${RED}[-] 公钥长度错误！应为128位，当前为${#pubkey}位${RESET}"
    return 1
  fi
  
  if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
    echo -e "${RED}[-] 公钥格式错误！只能包含0-9和a-f字符${RESET}"
    return 1
  fi
  
  return 0
}

function set_pubkey_env() {
  echo -e "[*] 设置 MINING_PUBKEY 到 .env..."
  cd_nck_dir

  echo -e "${BLUE}[i] 公钥格式要求：128位16进制字符串${RESET}"
  echo -e "${BLUE}[i] 示例格式：d24c0c53d1162325eba695f32b7194f4c9b2943441a3162837922d36f3325c341ce049e7b3992080a9603e91147e4529f79261a355e16570c975a6c0e81716e3${RESET}"
  echo ""
  
  while true; do
    read -p "请输入公钥 (MINING_PUBKEY): " pubkey
    
    if [ -z "$pubkey" ]; then
      echo -e "${RED}[-] 公钥不能为空${RESET}"
      continue
    fi
    
    pubkey=$(echo "$pubkey" | tr -d ' \n\r\t')
    
    if validate_pubkey "$pubkey"; then
      pubkey=$(echo "$pubkey" | tr '[:upper:]' '[:lower:]')
      
      if command -v sed >/dev/null 2>&1; then
        sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || {
          grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        }
      else
        grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
      fi
      echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
      
      echo -e "${GREEN}[+] 公钥格式验证通过，已写入 .env 文件${RESET}"
      echo -e "${GREEN}[+] 公钥: $pubkey${RESET}"
      break
    else
      echo -e "${YELLOW}[!] 请重新输入正确格式的公钥${RESET}"
    fi
  done
  
  pause_and_return
}

function export_keys() {
  echo -e "[*] 导出钱包密钥..."
  cd_nck_dir
  
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  "$wallet_bin" export-keys
  echo -e "${GREEN}[+] 密钥已导出到 keys.export${RESET}"
  pause_and_return
}

function import_keys() {
  echo -e "[*] 导入钱包密钥..."
  cd_nck_dir
  
  wallet_bin=""
  for path in "./target/release/nockchain-wallet" "./nockchain-wallet" "/usr/local/bin/nockchain-wallet" "$HOME/.cargo/bin/nockchain-wallet"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      wallet_bin="$path"
      break
    fi
  done
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  read -p "[?] 请输入密钥文件路径 (默认: ./keys.export): " keyfile
  keyfile=${keyfile:-"./keys.export"}
  
  if [ -f "$keyfile" ]; then
    "$wallet_bin" import-keys --input "$keyfile"
    echo -e "${GREEN}[+] 密钥已导入${RESET}"
  else
    echo -e "${RED}[-] 密钥文件不存在: $keyfile${RESET}"
  fi
  pause_and_return
}

function start_node() {
  echo -e "[*] 启动优化节点..."
  cd_nck_dir
  
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] .env文件不存在${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"

  if [ -z "$MINING_PUBKEY" ]; then
    echo -e "${RED}[-] 未设置 MINING_PUBKEY，请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi

  # 查找节点二进制文件
  node_bin=""
  for path in "./target/release/nockchain" "./target/release/nockchain-miner" "./nockchain" "./nockchain-miner" "/usr/local/bin/nockchain" "$HOME/.cargo/bin/nockchain"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
      node_bin="$path"
      break
    fi
  done
  
  if [ -z "$node_bin" ]; then
    echo -e "${RED}[-] 未找到节点二进制文件${RESET}"
    echo -e "${YELLOW}[!] 请先完成项目构建${RESET}"
    pause_and_return
    return
  fi

  echo -e "${GREEN}[+] 使用节点: $node_bin${RESET}"

  # 检查启动脚本或直接运行
  if [ -f "./scripts/run_nockchain_miner.sh" ]; then
    chmod +x ./scripts/run_nockchain_miner.sh
    start_script="./scripts/run_nockchain_miner.sh"
  else
    start_script="$node_bin"
  fi

  if ! command -v screen >/dev/null 2>&1; then
    echo -e "${YELLOW}[!] screen未安装，直接后台启动...${RESET}"
    nohup "$start_script" > nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动，日志文件: nockchain.log${RESET}"
  else
    if screen -list | grep -qw "nockchain"; then
      echo "[*] 关闭旧的 screen 会话..."
      screen -S nockchain -X quit >/dev/null 2>&1
      sleep 2
    fi

    screen -dmS nockchain bash -c "cd '$NCK_DIR' && '$start_script'"

    sleep 3
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] 节点已启动 (screen 会话名: nockchain)${RESET}"
      echo -e "${GREEN}[+] 使用公钥: $MINING_PUBKEY${RESET}"
      echo -e "${YELLOW}[!] 使用 'screen -r nockchain' 查看日志${RESET}"
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
      echo "请检查错误日志"
    fi
  fi
  
  pause_and_return
}

function view_logs() {
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] 进入日志查看 (Ctrl+A+D 可退出)...${RESET}"
    screen -r nockchain
  elif [ -f "$NCK_DIR/nockchain.log" ]; then
    echo -e "${YELLOW}[!] 显示最近日志 (按q退出):${RESET}"
    tail -f "$NCK_DIR/nockchain.log"
  else
    echo -e "${RED}[-] 节点未运行且无日志文件${RESET}"
  fi
  pause_and_return
}

function check_status() {
  echo -e "[*] 检查节点状态..."
  
  cd_nck_dir
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE" >/dev/null 2>&1
    if [ -n "$MINING_PUBKEY" ]; then
      echo -e "${GREEN}[+] 已配置公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}${RESET}"
    else
      echo -e "${YELLOW}[!] 未设置挖矿公钥${RESET}"
    fi
  fi
  
  running=false
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] 节点运行中 (screen模式)${RESET}"
    running=true
  elif pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "${GREEN}[+] 节点运行中 (后台模式)${RESET}"
    running=true
  else
    echo -e "${RED}[-] 节点未运行${RESET}"
  fi
  
  if [ "$running" = true ]; then
    echo -e "${YELLOW}[*] 系统资源使用情况:${RESET}"
    if command -v htop >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] 启动htop监控 (5秒后自动返回):${RESET}"
      timeout 5 htop -d 1 2>/dev/null || true
    elif command -v top >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] CPU和内存使用情况:${RESET}"
      top -b -n1 | head -20
    fi
  fi
  
  pause_and_return
}

function stop_node() {
  echo -e "[*] 停止节点..."
  stopped=false
  
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    screen -S nockchain -X quit >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if pgrep -f "nockchain" >/dev/null 2>&1; then
    pkill -f "nockchain" >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if [ "$stopped" = true ]; then
    echo -e "${GREEN}[+] 节点已停止${RESET}"
  else
    echo -e "${YELLOW}[!] 节点未运行${RESET}"
  fi
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

function main_menu() {
  show_banner
  echo "请选择操作:"
  echo "  1) 🚀 一键优化安装"
  echo "  2) 🔑 生成钱包"
  echo "  3) 📝 设置挖矿公钥 (128位16进制)"
  echo "  4) 💾 导出密钥"
  echo "  5) 📂 导入密钥"
  echo "  6) ⚡ 启动节点"
  echo "  7) 📊 查看日志"
  echo "  8) 🔍 检查状态"
  echo "  9) ⏹️  停止节点"
  echo "  0) 退出"
  echo ""
  read -p "请输入编号: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node ;;
    7) view_logs ;;
    8) check_status ;;
    9) stop_node ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

main_menu


