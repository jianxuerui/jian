#!/bin/bash

# ==============================================================================
# Nockchain 安装与挖矿助手
# ------------------------------------------------------------------------------
# 作者: K2 节点教程分享
# Telegram: https://t.me/+EaCiFDOghoM3Yzll
# Twitter:  https://x.com/BtcK241918
# ==============================================================================

# ========= 色彩定义 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= 项目路径 =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= 横幅 =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain 安装与挖矿助手"
  echo "==============================================="
  echo -e "${RESET}"
  echo "🔧 增强编译并行度，配置挖矿线程数"
  echo "📌 作者: K2 节点教程分享"
  echo "🔗 Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "🐦 Twitter:  https://x.com/BtcK241918"
  echo "-----------------------------------------------"
  echo ""
}

# ========= 常用函数 =========

# 检查命令是否存在
function check_command() {
    local cmd="$1"
    if ! command -v "$cmd" &>/dev/null; then
        echo -e "${RED}[-] 错误: 命令 '$cmd' 未找到。请确保已安装或在 PATH 中。${RESET}"
        return 1
    fi
    return 0
}

# 获取CPU核心数（兼容不同系统）
function get_num_cores() {
    local cores
    if check_command nproc; then
        cores=$(nproc)
    elif check_command sysctl; then # macOS/BSD
        cores=$(sysctl -n hw.ncpu)
    else
        echo -e "${YELLOW}[!] 警告: 无法自动检测CPU核心数，默认为 2。${RESET}"
        cores=2 # 默认值
    fi
    echo "$cores"
}

# 切换到项目目录
function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || { echo -e "${RED}[-] 无法进入项目目录: $NCK_DIR${RESET}"; return 1; }
  else
    echo -e "${RED}[-] 项目目录不存在: $NCK_DIR${RESET}"
    return 1
  fi
  return 0
}

# 暂停并返回主菜单
function pause_and_return() {
  echo ""
  # 使用 `-s` 隐藏按键输入，`-r` 防止反斜杠转义
  read -r -p "按任意键返回主菜单..." -s -n 1 # -n 1: 只读取一个字符
  echo # 换行，因为 -s 不会换行
  main_menu
}

# 检查最低磁盘空间 (例如，5GB)
function check_disk_space() {
    local required_gb=5
    local available_kb

    # 尝试使用 df -k 并解析，兼容性更好
    # awk '{print $4}' 获取第四列 (Available)
    # tail -n 1 确保只取最后一行 (通常是磁盘挂载点信息)
    available_kb=$(df -k "$HOME" 2>/dev/null | awk 'NR==2 {print $4}')

    if [ -z "$available_kb" ]; then
        echo -e "${YELLOW}[!] 警告: 无法检查磁盘空间，请手动确认您的磁盘空间是否充足。${RESET}"
        return 0 # 不阻止执行
    fi

    local available_gb=$((available_kb / 1024 / 1024))

    if [ "$available_gb" -lt "$required_gb" ]; then
        echo -e "${RED}[-] 错误: 磁盘空间不足! 至少需要 ${required_gb}GB，当前可用 ${available_gb}GB。${RESET}"
        echo -e "${RED}    请清理磁盘空间后再运行。${RESET}"
        return 1 # 阻止执行
    else
        echo -e "${GREEN}[+] 磁盘空间检查通过，可用 ${available_gb}GB。${RESET}"
        return 0 # 允许执行
    fi
}

# 查找并执行 Nockchain 二进制文件
# 参数: binary_name (例如: nockchain-wallet), ...args
function run_nockchain_binary() {
    local binary_name="$1"
    shift # 移除第一个参数 (binary_name)
    local args="$@"

    local binary_path=""

    # 1. 尝试从 PATH 中查找
    if command -v "$binary_name" &>/dev/null; then
        binary_path=$(command -v "$binary_name")
        echo -e "[*] 正在使用 PATH 中的 '$binary_path'${RESET}"
    # 2. 尝试从 NCK_DIR/target/release 中查找
    elif [ -x "$NCK_DIR/target/release/$binary_name" ]; then
        binary_path="$NCK_DIR/target/release/$binary_name"
        echo -e "[*] 正在使用项目目录中的 '$binary_path'${RESET}"
    else
        echo -e "${RED}[-] 错误: 找不到可执行文件 '$binary_name'。请确保已编译并安装 (运行选项 1)。${RESET}"
        return 1
    fi

    # 执行命令
    "$binary_path" $args || {
        echo -e "${RED}[-] 命令 '$binary_name $args' 执行失败${RESET}"
        return 1
    }
    return 0
}


# ========= 配置函数 =========

# 确保 .env 文件存在并包含必要的变量
function configure_mining_env() {
  echo -e "[*] 检查并设置 .env 文件中的挖矿相关配置..."
  local env_file="$1"
  local num_cores=$(get_num_cores)

  # 复制示例文件如果 .env 不存在
  if [ ! -f "$env_file" ]; then
    if [ -f "$NCK_DIR/.env_example" ]; then
      cp -n "$NCK_DIR/.env_example" "$env_file"
      echo -e "${GREEN}[+] 已从 .env_example 创建 $env_file${RESET}"
    else
      echo -e "${RED}[-] 错误: 找不到 .env_example 文件，无法创建 .env${RESET}"
      return 1
    fi
  fi

  # 确保 MINING_PUBKEY 存在 (仅检查，不自动设置，需要用户手动或通过菜单设置)
  if ! grep -q '^MINING_PUBKEY=' "$env_file"; then
    echo -e "${YELLOW}[!] 温馨提示: .env 文件中缺少 MINING_PUBKEY，请运行选项 2/3 生成/设置您的公钥!${RESET}"
  fi

  # 确保 MINER_THREADS 存在，如果不存在则添加，默认为核心数
  if ! grep -q '^MINER_THREADS=' "$env_file"; then
    echo -e "${YELLOW}[!] .env 文件中缺少 MINER_THREADS，将添加默认值 (CPU核心数: $num_cores)${RESET}"
    # 使用 sed 添加，确保不重复添加
    if ! grep -q '^# 挖矿线程数' "$env_file"; then
        echo "" >> "$env_file" # 添加一个空行确保格式
        echo "# 挖矿线程数，建议设置为您的CPU核心数" >> "$env_file"
    fi
    echo "MINER_THREADS=$num_cores" >> "$env_file"
    echo -e "${GREEN}[+] 已添加 MINER_THREADS=$num_cores 到 $env_file${RESET}"
  else
    local current_threads=$(grep '^MINER_THREADS=' "$env_file" | cut -d'=' -f2)
    echo -e "[*] .env 文件中已存在 MINER_THREADS=$current_threads"
  fi

  return 0
}

function set_pubkey_env() {
  echo -e "[*] 设置 MINING_PUBKEY 到 .env..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  read -r -p "请输入公钥 (MINING_PUBKEY): " pubkey
  if [ -z "$pubkey" ]; then
    echo -e "${RED}[-] 公钥不能为空${RESET}"
    pause_and_return
    return
  fi

  # 使用 sed 删除旧行并添加新行
  # 兼容 GNU/BSD sed，先尝试 GNU 语法，失败则尝试 BSD 语法
  if grep -q '^MINING_PUBKEY=' "$ENV_FILE"; then
    if sed -i "/^MINING_PUBKEY=/c\MINING_PUBKEY=$pubkey" "$ENV_FILE" 2>/dev/null; then
      echo -e "${GREEN}[+] 已更新 MINING_PUBKEY 到 $ENV_FILE${RESET}"
    elif sed -i "" "/^MINING_PUBKEY=/c\MINING_PUBKEY=$pubkey" "$ENV_FILE" 2>/dev/null; then
      echo -e "${GREEN}[+] 已更新 MINING_PUBKEY 到 $ENV_FILE (使用 BSD sed 兼容模式)${RESET}"
    else
      echo -e "${RED}[-] 警告: 无法更新 MINING_PUBKEY 到 $ENV_FILE，请手动编辑。${RESET}"
      pause_and_return
      return
    fi
  else
    # 如果不存在，则添加
    echo "" >> "$ENV_FILE" # 确保在末尾添加时格式正确
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    echo -e "${GREEN}[+] 已添加 MINING_PUBKEY=$pubkey 到 $ENV_FILE${RESET}"
  fi

  if grep -q "MINING_PUBKEY=$pubkey" "$ENV_FILE"; then
      echo -e "${GREEN}[+] MINING_PUBKEY=$pubkey 已成功写入/更新到 .env${RESET}"
      # 重新 .env 使配置生效 for this script run
      . "$ENV_FILE" # POSIX `.` 命令替代 `source`
  else
      echo -e "${RED}[-] 写入 MINING_PUBKEY 到 .env 失败${RESET}"
  fi

  pause_and_return
}

function set_miner_threads_env() {
  echo -e "[*] 设置 MINER_THREADS 到 .env..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  local max_cores=$(get_num_cores)
  echo "您的系统检测到有 ${max_cores} 个 CPU 核心。"
  read -r -p "请输入挖矿线程数 (MINER_THREADS，建议不超过核心数 $max_cores): " threads
  if [ -z "$threads" ]; then
    echo -e "${RED}[-] 线程数不能为空${RESET}"
    pause_and_return
    return
  fi

  # 验证输入是否为非负数字
  if ! echo "$threads" | grep -q '^[0-9]\+$'; then # POSIX 兼容的数字检查
    echo -e "${RED}[-] 输入无效，请输入一个非负数字${RESET}"
    pause_and_return
    return
  fi

   # 使用 sed 删除旧行并添加新行
  if grep -q '^MINER_THREADS=' "$ENV_FILE"; then
    if sed -i "/^MINER_THREADS=/c\MINER_THREADS=$threads" "$ENV_FILE" 2>/dev/null; then
      echo -e "${GREEN}[+] 已更新 MINER_THREADS=$threads 到 $ENV_FILE${RESET}"
    elif sed -i "" "/^MINER_THREADS=/c\MINER_THREADS=$threads" "$ENV_FILE" 2>/dev/null; then
      echo -e "${GREEN}[+] 已更新 MINER_THREADS=$threads 到 $ENV_FILE (使用 BSD sed 兼容模式)${RESET}"
    else
      echo -e "${RED}[-] 警告: 无法更新 MINER_THREADS 到 $ENV_FILE，请手动编辑。${RESET}"
      pause_and_return
      return
    fi
  else
    # 如果不存在，则添加
     if ! grep -q '^# 挖矿线程数' "$ENV_FILE"; then
        echo "" >> "$ENV_FILE" # 确保在末尾添加时格式正确
        echo "# 挖矿线程数，建议设置为您的CPU核心数" >> "$ENV_FILE"
    fi
    echo "MINER_THREADS=$threads" >> "$ENV_FILE"
    echo -e "${GREEN}[+] 已添加 MINER_THREADS=$threads 到 $ENV_FILE${RESET}"
  fi

  if grep -q "MINER_THREADS=$threads" "$ENV_FILE"; then
      echo -e "${GREEN}[+] MINER_THREADS=$threads 已成功写入/更新到 .env${RESET}"
      echo -e "${YELLOW}[!] 注意: 启动节点脚本 (run_nockchain_miner.sh) 需要读取并使用这个变量才能生效。${RESET}"
      # 重新 .env 使配置生效 for this script run
      . "$ENV_FILE" # POSIX `.` 命令替代 `source`
  else
      echo -e "${RED}[-] 写入 MINER_THREADS 到 .env 失败${RESET}"
  fi

  pause_and_return
}

# ========= 安装构建函数 =========
function setup_all() {
  show_banner # 在安装前再次显示横幅

  # 检查磁盘空间
  echo -e "[*] 检查磁盘空间..."
  if ! check_disk_space; then
      pause_and_return
      return
  fi

  echo -e "[*] 安装系统依赖 (build-essential, cmake, curl, git, make, screen)..."
  # 确保所有关键命令存在，如果不存在则尝试安装
  # 检查 screen 是否安装
  if ! check_command screen; then
      echo -e "${YELLOW}[!] 'screen' 命令未找到，将尝试安装。${RESET}"
  fi

  sudo apt update || { echo -e "${RED}[-] apt update 失败${RESET}"; pause_and_return; return; }
  sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen || { echo -e "${RED}[-] 系统依赖安装失败${RESET}"; pause_and_return; return; }
  echo -e "${GREEN}[+] 系统依赖安装完成${RESET}"

  echo -e "[*] 安装 Rust..."
  if ! check_command cargo; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y || { echo -e "${RED}[-] Rust 安装失败${RESET}"; pause_and_return; return; }
    # 立即使 cargo 在当前 shell session 可用
    export PATH="$HOME/.cargo/bin:$PATH"
    echo -e "${GREEN}[+] Rust 安装完成${RESET}"
  else
    echo -e "${YELLOW}[!] Rust 已安装，跳过安装步骤${RESET}"
    # 确保当前 shell session 有 cargo，即使已经安装
    export PATH="$HOME/.cargo/bin:$PATH"
  fi

  # 确保 cargo bin 目录在 PATH 中 (持久化)
  # 使用 $SHELL 变量判断用户当前使用的 shell
  local rc_file=""
  case "$(basename "$SHELL")" in
      "bash") rc_file="$HOME/.bashrc" ;;
      "zsh") rc_file="$HOME/.zshrc" ;;
      *) rc_file="$HOME/.profile" # Fallback for other shells or non-interactive sessions
  esac

  if ! grep -q 'export PATH=.*\$HOME/\.cargo/bin:\$PATH' "$rc_file" 2>/dev/null; then
    echo '# Add Rust cargo bin to PATH' >> "$rc_file"
    echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    echo -e "${GREEN}[+] 已将 Cargo 添加到 ${rc_file} 的 PATH (可能需要重新登录或 '. ${rc_file}' 生效)${RESET}"
  else
     echo -e "${YELLOW}[!] Cargo 已在 ${rc_file} 的 PATH 中${RESET}"
  fi


  echo -e "[*] 获取或更新仓库..."
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] 项目目录已存在，尝试拉取最新代码..."
    if ! cd_nck_dir; then pause_and_return; return; fi
    git pull || { echo -e "${RED}[-] Git pull 失败${RESET}"; pause_and_return; return; }
    echo -e "${GREEN}[+] 仓库已更新${RESET}"
  else
    echo -e "[*] 克隆仓库到 $NCK_DIR..."
    git clone https://github.com/zorp-corp/nockchain "$NCK_DIR" || { echo -e "${RED}[-] Git clone 失败${RESET}"; pause_and_return; return; }
    echo -e "${GREEN}[+] 仓库克隆完成${RESET}"
    if ! cd_nck_dir; then pause_and_return; return; fi
  fi

  # 配置 .env 文件，包括挖矿线程数
  configure_mining_env "$ENV_FILE" || { echo -e "${RED}[-] .env 配置失败${RESET}"; pause_and_return; return; }

  echo -e "[*] 清理旧的构建文件..."
  # 确保 make 和 cargo 命令存在
  if check_command make; then make clean || echo -e "${YELLOW}[!] make clean 可能失败，如果首次构建请忽略此警告。${RESET}"; fi
  if check_command cargo; then cargo clean || echo -e "${YELLOW}[!] cargo clean 可能失败，如果首次构建请忽略此警告。${RESET}"; fi
  echo -e "${GREEN}[+] 清理完成 (或已跳过)${RESET}"

  local num_j_cores=$(get_num_cores) # 使用兼容性函数获取核心数
  if [ "$num_j_cores" -eq 0 ]; then num_j_cores=1; fi # 避免 -j 0 导致的问题

  echo -e "[*] 安装 hoonc (使用多线程编译: make -j$num_j_cores)..."
  if ! cd_nck_dir; then pause_and_return; return; fi
  make -j"$num_j_cores" install-hoonc || { echo -e "${RED}[-] install-hoonc 失败${RESET}"; echo "请检查错误信息并尝试手动运行 'cd $NCK_DIR && make -j$num_j_cores install-hoonc'"; pause_and_return; return; }
  echo -e "${GREEN}[+] hoonc 安装完成${RESET}"

  echo -e "[*] 编译 Nockchain (使用多线程编译: make -j$num_j_cores)..."
  if ! cd_nck_dir; then pause_and_return; return; fi
  make -j"$num_j_cores" build || { echo -e "${RED}[-] build 失败${RESET}"; echo "请检查错误信息并尝试手动运行 'cd $NCK_DIR && make -j$num_j_cores build'"; pause_and_return; return; }
  echo -e "${GREEN}[+] Nockchain 编译完成${RESET}"

  echo -e "[*] 安装钱包 (使用多线程编译: make -j$num_j_cores)..."
  if ! cd_nck_dir; then pause_and_return; return; fi
  make -j"$num_j_cores" install-nockchain-wallet || { echo -e "${RED}[-] install-nockchain-wallet 失败${RESET}"; echo "请检查错误信息并尝试手动运行 'cd $NCK_DIR && make -j$num_j_cores install-nockchain-wallet'"; pause_and_return; return; }
  echo -e "${GREEN}[+] 钱包安装完成${RESET}"

  echo -e "[*] 安装节点 (使用多线程编译: make -j$num_j_cores)..."
  if ! cd_nck_dir; then pause_and_return; return; fi
  make -j"$num_j_cores" install-nockchain || { echo -e "${RED}[-] install-nockchain 失败${RESET}"; echo "请检查错误信息并尝试手动运行 'cd $NCK_DIR && make -j$num_j_cores install-nockchain'"; pause_and_return; return; }
  echo -e "${GREEN}[+] 节点程序安装完成${RESET}"

  echo -e "${GREEN}===============================================${RESET}"
  echo -e "${GREEN}[+] Nockchain 安装和构建已完成！${RESET}"
  echo -e "${GREEN}===============================================${RESET}"
  echo ""
  echo -e "${YELLOW}[!] 下一步重要事项: ${RESET}"
  echo -e "${YELLOW}  1. 生成您的钱包密钥对 (菜单选项 2)。${RESET}"
  echo -e "${YELLOW}  2. 将生成的公钥配置到 .env 文件中 (菜单选项 3)。${RESET}"
  echo -e "${YELLOW}  3. 检查 .env 中的 MINER_THREADS 配置 (菜单选项 8 可设置)。${RESET}"
  echo -e "${YELLOW}  4. 启动节点进行挖矿 (菜单选项 6)。${RESET}"
  echo ""

  pause_and_return
}

# ========= 钱包操作函数 =========
function generate_wallet() {
  echo -e "[*] 生成钱包密钥对..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  # 检查目标目录是否有写入权限
  if [ ! -w "$NCK_DIR" ]; then
      echo -e "${RED}[-] 错误: 无法在 $NCK_DIR 目录写入文件，请检查权限。${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] 生成密钥对的输出会包含您的私钥和公钥，请务必保存好！${RESET}"
  echo -e "${YELLOW}    特别是公钥，稍后需要配置到 .env 文件中 (MINING_PUBKEY)。${RESET}"
  echo -e "${YELLOW}    私钥保存在您运行命令的当前目录下的 wallet.keys 文件中。${RESET}"
  echo "-----------------------------------------------"

  # 在当前目录下生成 wallet.keys
  run_nockchain_binary "nockchain-wallet" keygen || {
    echo -e "${RED}[-] 钱包生成失败${RESET}"
    pause_and_return
    return
  }

  echo "-----------------------------------------------"
  echo -e "${GREEN}[+] 钱包密钥对生成完成${RESET}"
  echo -e "${YELLOW}[!] 再次提醒：请记录显示的公钥，并使用菜单选项 3 将其写入 .env 文件中的 MINING_PUBKEY。${RESET}"
  echo -e "${YELLOW}[!] 私钥已保存到 $NCK_DIR/wallet.keys (请妥善保管此文件！)。${RESET}"

  pause_and_return
}

function export_keys() {
  echo -e "[*] 导出钱包密钥到文件..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  echo -e "${YELLOW}[!] 密钥文件包含您的私钥，请妥善保管导出文件！${RESET}"
  echo -e "${YELLOW}    默认导出到 $NCK_DIR/keys.export${RESET}"

  run_nockchain_binary "nockchain-wallet" export-keys || {
    echo -e "${RED}[-] 导出密钥失败${RESET}"
    pause_and_return
    return
  }

  echo -e "${GREEN}[+] 密钥已导出到 $NCK_DIR/keys.export${RESET}"
  pause_and_return
}

function import_keys() {
  echo -e "[*] 导入钱包密钥文件..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  read -r -p "[?] 请输入要导入的密钥文件路径 (默认: $NCK_DIR/keys.export): " keyfile_input
  keyfile=${keyfile_input:-"$NCK_DIR/keys.export"}

  if [ ! -f "$keyfile" ]; then
    echo -e "${RED}[-] 错误: 密钥文件 '$keyfile' 不存在${RESET}"
    pause_and_return
    return
  fi

  echo -e "[*] 尝试导入 '$keyfile'..."
  run_nockchain_binary "nockchain-wallet" import-keys --input "$keyfile" || {
    echo -e "${RED}[-] 导入密钥失败${RESET}"
    pause_and_return
    return
  }

  echo -e "${GREEN}[+] 密钥已成功导入${RESET}"
  pause_and_return
}

# ========= 节点操作函数 =========
function start_node() {
  echo -e "[*] 启动节点 (screen 后台会话: nockchain)..."
  if ! cd_nck_dir; then pause_and_return; return; fi

  # 检查启动脚本是否存在并赋予执行权限
  local run_script="./scripts/run_nockchain_miner.sh"
  if [ ! -f "$run_script" ]; then
    echo -e "${RED}[-] 错误: 找不到启动脚本 $run_script${RESET}"
    echo "请先运行选项 1 完成安装构建。"
    pause_and_return
    return
  fi
  chmod +x "$run_script"

  # 检查节点程序是否存在 (使用 run_nockchain_binary 的检查逻辑)
  if ! run_nockchain_binary "nockchain" --version &>/dev/null; then # 简单检查是否存在
      echo -e "${RED}[-] 错误: 节点程序 'nockchain' 不存在或不可执行。请先运行选项 1 完成安装构建。${RESET}"
      pause_and_return
      return
  fi

  # 重新 .env 确保最新的配置被读取
  if [ -f "$ENV_FILE" ]; then
      . "$ENV_FILE" # POSIX `.` 命令替代 `source`
      echo -e "${GREEN}[+] 已加载 .env 配置文件${RESET}"
  else
      echo -e "${RED}[-] 警告: .env 文件不存在，部分配置可能缺失。请先运行选项 1 或手动创建 .env${RESET}"
      pause_and_return # 如果 .env 都不存在，大概率无法启动
      return
  fi

  # 检查 MINING_PUBKEY 是否已设置 (非空)
  if [ -z "$MINING_PUBKEY" ]; then
      echo -e "${RED}[-] 错误: MINING_PUBKEY 未在 .env 文件中设置!${RESET}"
      echo "请先运行菜单选项 2 (生成钱包) 和 3 (设置公钥) 完成配置。"
      pause_and_return
      return
  fi
  echo -e "[*] MINING_PUBKEY 已配置: ${GREEN}$MINING_PUBKEY${RESET}"

  # 检查 MINER_THREADS 是否已设置 (非空)，并提示
  if [ -z "$MINER_THREADS" ]; then
      echo -e "${YELLOW}[!] 警告: MINER_THREADS 未在 .env 文件中设置。${RESET}"
      echo "    矿工可能会以默认线程数运行 (通常为单线程)。建议通过选项 8 设置。"
  else
      echo -e "[*] MINER_THREADS 已配置: ${GREEN}$MINER_THREADS${RESET}"
  fi

  # 检查并关闭旧的 screen 会话
  if screen -list | grep -q "nockchain"; then # 使用 grep -q 检查存在性，避免输出
    echo "[*] 检测到旧的 'nockchain' screen 会话，尝试关闭..."
    screen -S nockchain -X quit || {
      echo -e "${RED}[-] 无法关闭旧的 screen 会话，可能需要手动操作: screen -S nockchain -X quit${RESET}"
    }
    sleep 2 # 等待旧会话完全退出
    if ! screen -list | grep -q "nockchain"; then
        echo -e "${GREEN}[+] 旧的 screen 会话已关闭${RESET}"
    else
        echo -e "${YELLOW}[!] 警告: 旧的 screen 会话可能未能完全关闭。请手动检查。${RESET}"
    fi
  fi

  # 启动新的 screen 会话并运行脚本
  echo -e "[*] 在 screen 会话 'nockchain' 中启动挖矿脚本..."
  # 注意这里的命令：cd 到目录，然后 . .env，最后执行脚本。
  screen -dmS nockchain sh -c "cd '$NCK_DIR' && . '$ENV_FILE' && './scripts/run_nockchain_miner.sh'"

  sleep 3 # 等待 screen 会话启动并执行命令

  if screen -list | grep -q "nockchain"; then
    echo -e "${GREEN}===============================================${RESET}"
    echo -e "${GREEN}[+] 节点已成功在 screen 会话 'nockchain' 后台启动${RESET}"
    echo -e "${GREEN}===============================================${RESET}"
    echo -e "${YELLOW}[!] 使用 'screen -r nockchain' 命令查看日志。${RESET}"
    echo -e "${YELLOW}[!] 在 screen 会话中，按 Ctrl+A 然后按 D 键可以退出会话并让其在后台运行。${RESET}"
  else
    echo -e "${RED}===============================================${RESET}"
    echo -e "${RED}[-] 节点启动失败!${RESET}"
    echo -e "${RED}    请尝试手动运行: cd '$NCK_DIR' && . '$ENV_FILE' && './scripts/run_nockchain_miner.sh'${RESET}"
    echo -e "${RED}    检查错误输出。${RESET}"
    echo -e "${RED}===============================================${RESET}"
  fi

  pause_and_return
}

function view_logs() {
  if screen -list | grep -q "nockchain"; then
    echo -e "${YELLOW}[!] 连接到 screen 会话 'nockchain' 查看日志。${RESET}"
    echo -e "${YELLOW}[!] 在 screen 中按 Ctrl+A 然后按 D 键可以退出会话并让其在后台运行。${RESET}"
    echo -e "${YELLOW}[!] 按 Ctrl+C 可能终止节点进程，请谨慎操作。${RESET}"
    echo "-----------------------------------------------"
    screen -r nockchain
  else
    echo -e "${RED}[-] 节点 screen 会话 'nockchain' 未运行。${RESET}"
    echo "请使用菜单选项 6 启动节点。"
  fi
  pause_and_return
}

function stop_node() {
    echo -e "[*] 停止节点 screen 会话..."
    if screen -list | grep -q "nockchain"; then
        echo "[*] 检测到 'nockchain' screen 会话，尝试停止..."
        screen -S nockchain -X quit || {
            echo -e "${RED}[-] 无法停止 screen 会话，可能需要手动操作: screen -S nockchain -X quit${RESET}"
            pause_and_return
            return
        }
        sleep 2 # 等待会话完全退出
        if ! screen -list | grep -q "nockchain"; then
             echo -e "${GREEN}[+] 节点 screen 会话已停止${RESET}"
        else
             echo -e "${YELLOW}[!] 警告: 节点 screen 会话可能未能完全停止。请手动检查。${RESET}"
        fi
    else
        echo -e "${YELLOW}[!] 节点 screen 会话 'nockchain' 未运行，无需停止。${RESET}"
    fi
    pause_and_return
}


# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo "  ${GREEN}1) 一键安装、构建并初始化 .env (推荐首次运行)${RESET}"
  echo "  ${BLUE}--- 钱包操作 ---${RESET}"
  echo "  2) 生成钱包密钥对 (显示公钥，私钥保存到 wallet.keys)"
  echo "  3) 设置 MINING_PUBKEY 到 .env (根据公钥设置挖矿地址)"
  echo "  4) 导出钱包密钥到文件 (keys.export)"
  echo "  5) 导入钱包密钥文件"
  echo "  ${BLUE}--- 节点操作 ---${RESET}"
  echo "  6) 启动节点 (screen 后台运行)"
  echo "  7) 查看节点日志 (连接到 screen 会话)"
  echo "  8) 设置挖矿线程数 (MINER_THREADS) 到 .env"
  echo "  9) 停止节点 (screen 会话)"
  echo "  ${RED}0) 退出${RESET}"
  echo ""
  read -r -p "请输入编号: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node ;;
    7) view_logs ;;
    8) set_miner_threads_env ;;
    9) stop_node ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# ========= 脚本入口 =========
# 确保在脚本开始时就加载 .env，以便后续函数可以使用其中的变量（如果文件已存在）
# 注意：这里使用 POSIX `.` 命令替代 `source`
if [ -f "$ENV_FILE" ]; then
    . "$ENV_FILE"
fi

# 启动主菜单循环
while true; do
    main_menu
done

exit 0 # 正常退出
