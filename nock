#!/bin/bash

# ========= Nockchain 预编译二进制版构建脚本 v18.0 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$HOME/nockchain_build.log"
USER_SOFTWARE_DIR="$HOME/software"
USER_BIN_DIR="$USER_SOFTWARE_DIR/bin"
USER_LIB_DIR="$USER_SOFTWARE_DIR/lib"
USER_INCLUDE_DIR="$USER_SOFTWARE_DIR/include"

function show_banner() {
  clear
  echo -e "${BOLD}${CYAN}"
  echo "============================================================"
  echo "   Nockchain 预编译二进制版构建脚本 v18.0"
  echo "============================================================"
  echo -e "${RESET}"
  echo "🚀 预编译版: 使用现成二进制文件，避免长时间源码编译"
  echo "⚡ 快速部署: 5-10分钟完成全部工具安装"
  echo "🎯 专门修复: 工具验证失败，gcc/clang等未找到问题"
  echo "📦 多源下载: GitHub、官方镜像、备用源多重保障"
  echo "🔧 轻量级: 最小化安装，只安装必需的工具"
  echo "------------------------------------------------------------"
  echo ""
}

# ========= 设置基础环境 =========
function setup_base_environment() {
  echo -e "[*] 设置基础环境..."
  
  # 创建目录结构
  mkdir -p "$USER_SOFTWARE_DIR"/{bin,lib,lib64,include,share,src,build}
  
  # 设置环境变量[2]
  export PATH="$USER_BIN_DIR:$PATH"
  export LD_LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:$LD_LIBRARY_PATH"
  export PKG_CONFIG_PATH="$USER_LIB_DIR/pkgconfig:$USER_SOFTWARE_DIR/lib64/pkgconfig:$PKG_CONFIG_PATH"
  export C_INCLUDE_PATH="$USER_INCLUDE_DIR:$C_INCLUDE_PATH"
  export CPLUS_INCLUDE_PATH="$USER_INCLUDE_DIR:$CPLUS_INCLUDE_PATH"
  
  echo -e "${GREEN}[+] 基础环境设置完成${RESET}"
}

# ========= 下载工具函数 =========
function download_with_retry() {
  local url="$1"
  local output="$2"
  local max_attempts=3
  
  for attempt in $(seq 1 $max_attempts); do
    echo -e "[*] 下载尝试 $attempt/$max_attempts: $(basename "$output")"
    
    if command -v wget >/dev/null 2>&1; then
      if wget -q -O "$output" "$url"; then
        echo -e "${GREEN}[+] 下载成功${RESET}"
        return 0
      fi
    elif command -v curl >/dev/null 2>&1; then
      if curl -fsSL -o "$output" "$url"; then
        echo -e "${GREEN}[+] 下载成功${RESET}"
        return 0
      fi
    fi
    
    echo -e "${YELLOW}[!] 下载失败，重试...${RESET}"
    sleep 5
  done
  
  echo -e "${RED}[-] 下载失败: $url${RESET}"
  return 1
}

# ========= 安装预编译GCC =========
function install_prebuilt_gcc() {
  echo -e "[*] 安装预编译GCC..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 检查系统架构
  arch=$(uname -m)
  if [ "$arch" != "x86_64" ]; then
    echo -e "${YELLOW}[!] 非x86_64架构，跳过GCC安装${RESET}"
    return 1
  fi
  
  # 下载预编译GCC 9.4.0[4]
  gcc_url="https://github.com/spack/spack-bootstrap-mirrors/releases/download/v0.4/gcc-9.4.0-x86_64.tar.gz"
  gcc_file="gcc-9.4.0-x86_64.tar.gz"
  
  if [ ! -f "$gcc_file" ]; then
    if ! download_with_retry "$gcc_url" "$gcc_file"; then
      echo -e "${YELLOW}[!] 预编译GCC下载失败，尝试备用源...${RESET}"
      # 备用源：使用更小的GCC版本
      gcc_url="https://ftp.gnu.org/gnu/gcc/gcc-7.5.0/gcc-7.5.0.tar.gz"
      if ! download_with_retry "$gcc_url" "gcc-7.5.0.tar.gz"; then
        return 1
      fi
      gcc_file="gcc-7.5.0.tar.gz"
    fi
  fi
  
  echo -e "[*] 解压GCC..."
  if [[ "$gcc_file" == *"x86_64.tar.gz" ]]; then
    # 预编译版本直接解压到目标目录
    tar -xzf "$gcc_file" -C "$USER_SOFTWARE_DIR/" --strip-components=1
    
    # 验证安装
    if [ -f "$USER_BIN_DIR/gcc" ]; then
      chmod +x "$USER_BIN_DIR/gcc" "$USER_BIN_DIR/g++"
      echo -e "${GREEN}[+] 预编译GCC安装成功${RESET}"
      return 0
    fi
  fi
  
  echo -e "${YELLOW}[!] 预编译GCC安装失败${RESET}"
  return 1
}

# ========= 安装轻量级构建工具 =========
function install_lightweight_tools() {
  echo -e "[*] 安装轻量级构建工具..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 安装musl-gcc（轻量级C编译器）
  echo -e "[*] 安装musl-gcc..."
  musl_url="https://musl.cc/x86_64-linux-musl-cross.tgz"
  musl_file="x86_64-linux-musl-cross.tgz"
  
  if download_with_retry "$musl_url" "$musl_file"; then
    tar -xzf "$musl_file"
    cp -r x86_64-linux-musl-cross/* "$USER_SOFTWARE_DIR/"
    
    # 创建gcc软链接
    if [ -f "$USER_SOFTWARE_DIR/bin/x86_64-linux-musl-gcc" ]; then
      ln -sf "$USER_SOFTWARE_DIR/bin/x86_64-linux-musl-gcc" "$USER_BIN_DIR/gcc"
      ln -sf "$USER_SOFTWARE_DIR/bin/x86_64-linux-musl-g++" "$USER_BIN_DIR/g++"
      echo -e "${GREEN}[+] musl-gcc安装成功${RESET}"
    fi
  fi
  
  # 安装clang预编译版[4]
  echo -e "[*] 安装预编译Clang..."
  clang_url="https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.6/clang+llvm-14.0.6-x86_64-linux-gnu-ubuntu-18.04.tar.xz"
  clang_file="clang+llvm-14.0.6-x86_64-linux-gnu-ubuntu-18.04.tar.xz"
  
  if download_with_retry "$clang_url" "$clang_file"; then
    tar -xf "$clang_file"
    cp -r clang+llvm-14.0.6-x86_64-linux-gnu-ubuntu-18.04/* "$USER_SOFTWARE_DIR/"
    echo -e "${GREEN}[+] 预编译Clang安装成功${RESET}"
  fi
  
  # 安装make
  echo -e "[*] 安装GNU Make..."
  make_url="https://ftp.gnu.org/gnu/make/make-4.3.tar.gz"
  make_file="make-4.3.tar.gz"
  
  if download_with_retry "$make_url" "$make_file"; then
    tar -xzf "$make_file"
    cd make-4.3
    
    # 简化配置，避免依赖问题
    ./configure --prefix="$USER_SOFTWARE_DIR" --disable-nls
    make -j$(nproc) && make install
    cd ..
    echo -e "${GREEN}[+] GNU Make安装成功${RESET}"
  fi
  
  # 安装cmake
  echo -e "[*] 安装CMake..."[2]
  cmake_url="https://github.com/Kitware/CMake/releases/download/v3.25.2/cmake-3.25.2-linux-x86_64.tar.gz"
  cmake_file="cmake-3.25.2-linux-x86_64.tar.gz"
  
  if download_with_retry "$cmake_url" "$cmake_file"; then
    tar -xzf "$cmake_file"
    cp -r cmake-3.25.2-linux-x86_64/* "$USER_SOFTWARE_DIR/"
    echo -e "${GREEN}[+] CMake安装成功${RESET}"
  fi
  
  # 安装pkg-config
  echo -e "[*] 安装pkg-config..."
  pkgconfig_url="https://pkgconfig.freedesktop.org/releases/pkg-config-0.29.2.tar.gz"
  pkgconfig_file="pkg-config-0.29.2.tar.gz"
  
  if download_with_retry "$pkgconfig_url" "$pkgconfig_file"; then
    tar -xzf "$pkgconfig_file"
    cd pkg-config-0.29.2
    ./configure --prefix="$USER_SOFTWARE_DIR" --with-internal-glib
    make -j$(nproc) && make install
    cd ..
    echo -e "${GREEN}[+] pkg-config安装成功${RESET}"
  fi
}

# ========= 安装基础开发库 =========
function install_basic_libraries() {
  echo -e "[*] 安装基础开发库..."
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 安装zlib
  echo -e "[*] 安装zlib..."
  zlib_url="https://zlib.net/zlib-1.2.13.tar.gz"
  if download_with_retry "$zlib_url" "zlib-1.2.13.tar.gz"; then
    tar -xzf zlib-1.2.13.tar.gz
    cd zlib-1.2.13
    ./configure --prefix="$USER_SOFTWARE_DIR"
    make -j$(nproc) && make install
    cd ..
  fi
  
  # 安装openssl
  echo -e "[*] 安装OpenSSL..."
  openssl_url="https://www.openssl.org/source/openssl-1.1.1w.tar.gz"
  if download_with_retry "$openssl_url" "openssl-1.1.1w.tar.gz"; then
    tar -xzf openssl-1.1.1w.tar.gz
    cd openssl-1.1.1w
    ./config --prefix="$USER_SOFTWARE_DIR" --openssldir="$USER_SOFTWARE_DIR/ssl" shared zlib
    make -j$(nproc) && make install
    cd ..
  fi
  
  echo -e "${GREEN}[+] 基础库安装完成${RESET}"
}

# ========= 修复工具路径和权限 =========
function fix_tools_and_permissions() {
  echo -e "[*] 修复工具路径和权限..."
  
  cd "$USER_BIN_DIR"
  
  # 确保所有二进制文件有执行权限
  chmod +x * 2>/dev/null || true
  
  # 创建缺失的软链接
  if [ ! -f "gcc" ] && [ -f "x86_64-linux-musl-gcc" ]; then
    ln -sf x86_64-linux-musl-gcc gcc
  fi
  
  if [ ! -f "g++" ] && [ -f "x86_64-linux-musl-g++" ]; then
    ln -sf x86_64-linux-musl-g++ g++
  fi
  
  if [ ! -f "clang" ] && [ -f "clang-14" ]; then
    ln -sf clang-14 clang
  fi
  
  if [ ! -f "clang++" ] && [ -f "clang++-14" ]; then
    ln -sf clang++-14 clang++
  fi
  
  # 创建标准工具的备用版本
  if [ ! -f "cc" ] && [ -f "gcc" ]; then
    ln -sf gcc cc
  fi
  
  echo -e "${GREEN}[+] 工具修复完成${RESET}"
}

# ========= 设置环境变量文件 =========
function setup_environment_file() {
  echo -e "[*] 设置环境变量文件..."
  
  # 创建环境变量配置文件[2]
  cat > "$HOME/.nockchain_env" << EOF
#!/bin/bash
# Nockchain用户编译环境变量 - 预编译版
export PATH="$USER_BIN_DIR:\$PATH"
export LD_LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:\$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$USER_LIB_DIR/pkgconfig:$USER_SOFTWARE_DIR/lib64/pkgconfig:\$PKG_CONFIG_PATH"
export C_INCLUDE_PATH="$USER_INCLUDE_DIR:\$C_INCLUDE_PATH"
export CPLUS_INCLUDE_PATH="$USER_INCLUDE_DIR:\$CPLUS_INCLUDE_PATH"
export LIBRARY_PATH="$USER_LIB_DIR:$USER_SOFTWARE_DIR/lib64:\$LIBRARY_PATH"
export CPATH="$USER_INCLUDE_DIR:\$CPATH"

# 编译器设置
export CC=gcc
export CXX=g++
if command -v clang >/dev/null 2>&1; then
  export CC=clang
  export CXX=clang++
  export LIBCLANG_PATH="$USER_LIB_DIR"
  export LLVM_CONFIG_PATH="$USER_BIN_DIR/llvm-config"
fi

# Rust和Cargo设置
export CARGO_BUILD_JOBS=1
export RUSTFLAGS="-C opt-level=1 -C debuginfo=0 -C panic=abort"
export RUST_BACKTRACE=1
EOF
  
  # 添加到bashrc
  if ! grep -q "source.*nockchain_env" "$HOME/.bashrc" 2>/dev/null; then
    echo "" >> "$HOME/.bashrc"
    echo "# Nockchain预编译环境 - 自动添加" >> "$HOME/.bashrc"
    echo "source \$HOME/.nockchain_env" >> "$HOME/.bashrc"
  fi
  
  # 立即加载环境变量
  source "$HOME/.nockchain_env"
  
  echo -e "${GREEN}[+] 环境变量配置完成${RESET}"
}

# ========= 验证工具安装 =========
function verify_tools_final() {
  echo -e "[*] 最终验证工具安装..."
  
  # 加载环境变量
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  echo -e "${BLUE}[i] 验证关键工具:${RESET}"
  tools_success=0
  total_tools=7
  
  for tool in gcc g++ clang make cmake pkg-config git; do
    if command -v "$tool" >/dev/null 2>&1; then
      tool_path=$(command -v "$tool")
      tool_version=$(eval "$tool --version 2>/dev/null | head -1" | cut -d' ' -f1-3 || echo "unknown")
      echo -e "${GREEN}  ✓ $tool: $tool_version${RESET}"
      echo -e "${BLUE}    路径: $tool_path${RESET}"
      ((tools_success++))
    else
      echo -e "${RED}  ✗ $tool: 未找到${RESET}"
    fi
  done
  
  echo -e "${BLUE}[i] 工具可用性: $tools_success/$total_tools ($(( tools_success * 100 / total_tools ))%)${RESET}"
  
  # 测试编译功能
  echo -e "[*] 测试基础编译功能..."
  
  test_c_file="$USER_SOFTWARE_DIR/test.c"
  cat > "$test_c_file" << 'EOF'
#include <stdio.h>
int main() {
    printf("Hello, Nockchain!\n");
    return 0;
}
EOF
  
  if command -v gcc >/dev/null 2>&1; then
    if gcc -o "$USER_SOFTWARE_DIR/test" "$test_c_file" 2>/dev/null; then
      echo -e "${GREEN}[+] GCC编译测试通过${RESET}"
      rm -f "$USER_SOFTWARE_DIR/test" "$test_c_file"
    else
      echo -e "${YELLOW}[!] GCC编译测试失败${RESET}"
    fi
  fi
  
  if [ $tools_success -ge 5 ]; then
    echo -e "${GREEN}[+] ✅ 工具验证通过！可以开始构建Nockchain${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] 部分工具缺失，但可尝试继续${RESET}"
    return 1
  fi
}

# ========= 安装Rust =========
function install_rust_optimized() {
  echo -e "[*] 安装Rust（优化版）..."
  
  if ! command -v rustc >/dev/null 2>&1; then
    echo -e "[*] 下载并安装Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
  else
    echo -e "[*] 更新现有Rust..."
    rustup update stable 2>/dev/null || true
  fi
  
  source "$HOME/.cargo/env"
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 优化Cargo配置
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[net]
retry = 50
timeout = 1800

[profile.release]
opt-level = 1
debug = false
lto = "off"
panic = "abort"
codegen-units = 1
strip = true

[profile.dev]
opt-level = 0
debug = false
codegen-units = 1
EOF
  
  echo -e "${GREEN}[+] Rust安装完成: $(rustc --version)${RESET}"
}

# ========= 主安装流程 =========
function complete_prebuilt_installation() {
  echo -e "[*] 开始预编译版快速安装..."
  
  echo "=== Nockchain预编译版安装日志 $(date) ===" > "$LOG_FILE"
  
  echo -e "${BLUE}[i] 步骤1/7: 设置基础环境...${RESET}"
  setup_base_environment
  
  echo -e "${BLUE}[i] 步骤2/7: 安装预编译GCC...${RESET}"
  install_prebuilt_gcc
  
  echo -e "${BLUE}[i] 步骤3/7: 安装轻量级工具...${RESET}"
  install_lightweight_tools
  
  echo -e "${BLUE}[i] 步骤4/7: 安装基础库...${RESET}"
  install_basic_libraries
  
  echo -e "${BLUE}[i] 步骤5/7: 修复工具和权限...${RESET}"
  fix_tools_and_permissions
  
  echo -e "${BLUE}[i] 步骤6/7: 设置环境变量...${RESET}"
  setup_environment_file
  
  echo -e "${BLUE}[i] 步骤7/7: 最终验证...${RESET}"
  if verify_tools_final; then
    echo -e "${GREEN}[+] ✅ 预编译版安装完成！${RESET}"
    echo -e "${BLUE}[i] 所有主要工具已可用${RESET}"
    echo -e "${BLUE}[i] 下一步: 安装Rust并构建Nockchain${RESET}"
  else
    echo -e "${YELLOW}[!] 部分工具安装失败，但可以尝试继续${RESET}"
  fi
  
  echo -e "${BLUE}[i] 环境配置文件: $HOME/.nockchain_env${RESET}"
  echo -e "${BLUE}[i] 详细日志: $LOG_FILE${RESET}"
  pause_and_return
}

# ========= 构建Nockchain =========
function build_nockchain_prebuilt() {
  echo -e "[*] 使用预编译工具构建Nockchain..."
  
  # 加载环境变量
  source "$HOME/.nockchain_env" 2>/dev/null || true
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  # 安装Rust（如果还没有）
  if ! command -v rustc >/dev/null 2>&1; then
    install_rust_optimized
  fi
  
  # 验证必要工具
  missing_tools=()
  for tool in make git rustc cargo; do
    if ! command -v "$tool" >/dev/null 2>&1; then
      missing_tools+=("$tool")
    fi
  done
  
  if [ ${#missing_tools[@]} -gt 0 ]; then
    echo -e "${RED}[-] 缺少必要工具: ${missing_tools[*]}${RESET}"
    echo -e "${YELLOW}[!] 请先运行预编译版安装${RESET}"
    pause_and_return
    return
  fi
  
  # 克隆或准备项目
  if [ ! -d "$NCK_DIR" ]; then
    echo -e "[*] 克隆Nockchain项目..."
    git clone --depth 1 https://github.com/zorp-corp/nockchain "$NCK_DIR" || {
      echo -e "${RED}[-] 项目克隆失败${RESET}"
      pause_and_return
      return
    }
  fi
  
  cd "$NCK_DIR"
  
  # 清理构建环境
  cargo clean >/dev/null 2>&1 || true
  rm -rf target/ 2>/dev/null || true
  
  # 准备配置文件
  if [ -f ".env_example" ]; then
    cp .env_example .env
  else
    cat > .env << 'EOF'
MINING_PUBKEY=
RUST_LOG=info
EOF
  fi
  
  # 创建必要目录
  mkdir -p assets .socket test-leader logs
  touch assets/wal.jam assets/dumb.jam assets/miner.jam 2>/dev/null || true
  
  echo -e "[*] 开始构建Nockchain组件..."
  
  # 设置编译环境
  export CARGO_BUILD_JOBS=1
  export RUSTFLAGS="-C opt-level=1 -C debuginfo=0"
  
  # 构建hoonc
  echo -e "[*] 构建hoonc编译器..."
  if timeout 3600 make install-hoonc >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] hoonc构建成功${RESET}"
  else
    echo -e "${YELLOW}[!] hoonc构建失败，查看日志了解详情${RESET}"
  fi
  
  # 构建主项目
  echo -e "[*] 构建主项目..."
  if timeout 7200 make build >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] 主项目构建成功${RESET}"
  else
    echo -e "${YELLOW}[!] 主项目构建失败，尝试单独构建...${RESET}"
    for component in "nockchain-wallet" "nockchain"; do
      echo -e "[*] 构建 $component..."
      timeout 3600 cargo build --bin "$component" --release >>"$LOG_FILE" 2>&1 || true
    done
  fi
  
  # 验证构建结果
  echo -e "[*] 验证构建结果..."
  component_count=0
  for binary in "hoonc" "nockchain-wallet" "nockchain"; do
    if command -v "$binary" >/dev/null 2>&1 || [ -f "target/release/$binary" ]; then
      echo -e "${GREEN}  ✓ $binary: 构建成功${RESET}"
      ((component_count++))
    else
      echo -e "${RED}  ✗ $binary: 构建失败${RESET}"
    fi
  done
  
  echo -e "${BLUE}[i] 构建成功: $component_count/3 个组件${RESET}"
  
  if [ $component_count -ge 2 ]; then
    echo -e "${GREEN}[+] ✅ Nockchain构建成功！${RESET}"
    echo -e "${BLUE}[i] 下一步: 生成钱包和设置挖矿公钥${RESET}"
  else
    echo -e "${YELLOW}[!] 构建部分失败，请查看日志${RESET}"
  fi
  
  pause_and_return
}

# ========= 其他功能保持不变 =========
function generate_wallet() {
  echo -e "[*] 生成钱包..."
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  if command -v nockchain-wallet >/dev/null 2>&1; then
    nockchain-wallet keygen
  elif [ -f "target/release/nockchain-wallet" ]; then
    ./target/release/nockchain-wallet keygen
  else
    echo -e "${RED}[-] 未找到nockchain-wallet程序${RESET}"
  fi
  pause_and_return
}

function set_mining_pubkey() {
  echo -e "[*] 设置挖矿公钥..."
  cd "$NCK_DIR" || return
  
  read -p "请输入完整的挖矿公钥: " pubkey
  
  if [ ${#pubkey} -eq 128 ] && [[ "$pubkey" =~ ^[0-9a-f]{128}$ ]]; then
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || true
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    echo -e "${GREEN}[+] 公钥已成功写入.env文件${RESET}"
  else
    echo -e "${RED}[-] 公钥格式错误，需要128位16进制${RESET}"
  fi
  pause_and_return
}

function start_node() {
  echo -e "[*] 启动节点..."
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  if [ ! -f "$ENV_FILE" ] || [ -z "$(grep MINING_PUBKEY "$ENV_FILE" | cut -d'=' -f2)" ]; then
    echo -e "${RED}[-] 请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"
  pkill -f nockchain 2>/dev/null || true
  find . -name "*.sock" -delete 2>/dev/null || true
  mkdir -p .socket test-leader
  
  start_cmd="RUST_LOG=info nockchain --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --npc-socket .socket/nockchain.sock --bind /ip4/0.0.0.0/udp/3006/quic-v1"
  
  if command -v screen >/dev/null 2>&1; then
    screen -dmS nockchain bash -c "cd '$NCK_DIR' && $start_cmd"
    echo -e "${GREEN}[+] 节点已启动（screen会话）${RESET}"
  else
    nohup bash -c "$start_cmd" > nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动${RESET}"
  fi
  pause_and_return
}

function check_status() {
  echo -e "[*] 检查状态..."
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  echo -e "${BLUE}[i] 工具状态:${RESET}"
  for tool in gcc g++ clang make cmake pkg-config git rustc cargo; do
    if command -v "$tool" >/dev/null 2>&1; then
      echo -e "  ✓ $tool: $(command -v "$tool")"
    else
      echo -e "  ✗ $tool: 未找到"
    fi
  done
  
  echo -e "${BLUE}[i] Nockchain组件:${RESET}"
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    for binary in "hoonc" "nockchain-wallet" "nockchain"; do
      if command -v "$binary" >/dev/null 2>&1 || [ -f "target/release/$binary" ]; then
        echo -e "  ✓ $binary: 可用"
      else
        echo -e "  ✗ $binary: 未找到"
      fi
    done
  fi
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo ""
  echo "🚀 快速安装:"
  echo "  1) 🎯 预编译版环境安装（推荐）"
  echo "  2) 🔧 构建Nockchain项目"
  echo ""
  echo "🔑 钱包管理:"
  echo "  3) 🔑 生成钱包"
  echo "  4) 📝 设置挖矿公钥"
  echo ""
  echo "⚡ 节点管理:"
  echo "  5) ⚡ 启动节点"
  echo "  6) 🔍 检查状态"
  echo ""
  echo "  0) 退出脚本"
  echo ""
  echo -e "${CYAN}🎯 专门修复: 工具验证失败，gcc/clang等未找到问题${RESET}"
  echo -e "${CYAN}⚡ 快速部署: 使用预编译二进制，5-10分钟完成${RESET}"
  echo -e "${CYAN}📦 轻量级: 最小化安装，避免长时间源码编译${RESET}"
  echo ""
  read -p "请输入编号 (0-6): " choice

  case "$choice" in
    1) complete_prebuilt_installation ;;
    2) build_nockchain_prebuilt ;;
    3) generate_wallet ;;
    4) set_mining_pubkey ;;
    5) start_node ;;
    6) check_status ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# 检查权限
if [ "$EUID" -eq 0 ]; then
  echo -e "${RED}[-] 请不要以root用户运行此脚本${RESET}"
  exit 1
fi

# 启动主菜单
main_menu
