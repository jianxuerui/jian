#!/bin/bash

# ========= Nockchain 集成修复版安装脚本 v31.0 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$HOME/nockchain_build.log"
NODE_LOG="$NCK_DIR/logs/nockchain.log"

# ---------- 辅助函数 ----------
log() { echo -e "${BLUE}[*] $*${RESET}"; }
ok()  { echo -e "${GREEN}[✓] $*${RESET}"; }
warn(){ echo -e "${YELLOW}[!] $*${RESET}"; }
err() { echo -e "${RED}[✗] $*${RESET}"; }
pause() { echo; read -n1 -r -p "按任意键返回菜单..." _; }

# ---------- 集成的完整安装流程 ----------
complete_installation_with_fixes() {
  log "开始集成修复版安装 Nockchain"
  echo "=== Nockchain集成修复版安装日志 $(date) ===" > "$LOG_FILE"
  
  # 步骤1: 系统依赖安装
  log "步骤1/8: 安装系统依赖"
  if command -v apt >/dev/null; then
    sudo apt update -y
    sudo apt install -y build-essential git curl pkg-config libssl-dev clang cmake screen netstat-nat
    ok "系统依赖安装完成"
  else
    warn "非Ubuntu/Debian系统，请手动安装依赖"
  fi
  
  # 步骤2: 安装 Rust
  log "步骤2/8: 安装 Rust"
  if ! command -v rustc >/dev/null; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source "$HOME/.cargo/env"
    ok "Rust 安装完成"
  else
    ok "Rust 已安装: $(rustc --version)"
  fi
  
  # 步骤3: 修复编译器问题（AWS-LC-SYS bug）
  log "步骤3/8: 修复编译器问题"
  export CC=clang
  export CXX=clang++
  ok "已设置使用 Clang 编译器避免 GCC bug"
  
  # 步骤4: 克隆/更新项目
  log "步骤4/8: 克隆/更新项目"
  if [ ! -d "$NCK_DIR" ]; then
    git clone --depth 1 https://github.com/zorp-corp/nockchain "$NCK_DIR"
    ok "项目克隆完成"
  else
    cd "$NCK_DIR"
    git pull
    ok "项目更新完成"
  fi
  
  # 步骤5: 优化 Cargo 配置
  log "步骤5/8: 优化编译配置"
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[net]
retry = 50
timeout = 3600
git-fetch-with-cli = true

[profile.release]
opt-level = 1
debug = false
panic = "abort"
codegen-units = 1
strip = true
EOF
  
  # 设置环境变量防止 mem.rs 错误
  export RUST_MIN_STACK=33554432
  export CARGO_BUILD_JOBS=1
  export RUSTFLAGS="-C opt-level=1 -C debuginfo=0 -C panic=abort"
  ok "编译配置优化完成"
  
  # 步骤6: 预修复端口和Socket问题
  log "步骤6/8: 预修复端口和Socket问题"
  pkill -f nockchain 2>/dev/null || true
  if command -v netstat >/dev/null 2>&1; then
    pid=$(netstat -tulpn 2>/dev/null | grep ":3006" | awk '{print $7}' | cut -d'/' -f1 | head -1)
    if [ -n "$pid" ] && [ "$pid" != "-" ]; then
      kill -9 "$pid" 2>/dev/null || true
      ok "已释放端口 3006"
    fi
  fi
  
  # 创建目录并设置权限
  mkdir -p "$NCK_DIR"/{logs,.socket}
  chmod -R 777 "$NCK_DIR"/{logs,.socket}
  ok "Socket 和日志目录预配置完成"
  
  # 步骤7: 编译项目
  log "步骤7/8: 编译项目（这可能需要较长时间）"
  cd "$NCK_DIR"
  cargo clean
  cargo build --release 2>&1 | tee "$LOG_FILE"
  
  if [ -f "target/release/nockchain" ]; then
    chmod +x target/release/{nockchain,nockchain-wallet,hoonc}
    ok "编译成功并修复权限"
  else
    err "编译失败，请查看日志: $LOG_FILE"
    return 1
  fi
  
  # 步骤8: 创建配置文件
  log "步骤8/8: 创建配置文件"
  if [ ! -f "$ENV_FILE" ]; then
    cat > "$ENV_FILE" <<EOF
MINING_PUBKEY=
RUST_LOG=info
EOF
    ok "配置文件创建完成"
  fi
  
  ok "🎉 集成修复版安装完成！"
  pause
}

# ---------- 设置挖矿公钥 ----------
set_mining_pubkey() {
  log "设置挖矿公钥"
  
  if [ ! -f "$ENV_FILE" ]; then
    mkdir -p "$NCK_DIR"
    echo "MINING_PUBKEY=" > "$ENV_FILE"
    echo "RUST_LOG=info" >> "$ENV_FILE"
  fi
  
  # 显示当前公钥
  current_key=$(grep "MINING_PUBKEY=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2)
  if [ -n "$current_key" ]; then
    echo "当前公钥: ${current_key:0:16}...${current_key: -16}"
  fi
  
  read -rp "输入新的 128 位公钥（留空保持不变）: " key
  
  if [ -z "$key" ]; then
    warn "公钥未更改"
    pause
    return
  fi
  
  key=$(echo "$key" | tr -d '[:space:]' | tr A-F a-f)
  
  if [ ${#key} -eq 128 ] && [[ "$key" =~ ^[0-9a-f]+$ ]]; then
    sed -i "/^MINING_PUBKEY=/d" "$ENV_FILE"
    echo "MINING_PUBKEY=$key" >> "$ENV_FILE"
    ok "公钥已写入 .env"
  else
    err "公钥格式不正确"
  fi
  
  pause
}

# ---------- 智能启动节点（集成修复）----------
start_node_with_integrated_fixes() {
  log "智能启动节点（集成修复）"
  
  # 加载环境变量
  source "$ENV_FILE" 2>/dev/null || true
  
  # 检查公钥
  if [ -z "$MINING_PUBKEY" ]; then
    err "未设置挖矿公钥，请先设置"
    pause
    return 1
  fi
  
  # 自动修复流程
  log "执行启动前自动修复..."
  
  # 1. 停止现有进程
  pkill -f nockchain 2>/dev/null || true
  pkill -9 -f nockchain 2>/dev/null || true
  screen -wipe 2>/dev/null || true
  
  # 2. 释放端口
  if command -v netstat >/dev/null 2>&1; then
    pid=$(netstat -tulpn 2>/dev/null | grep ":3006" | awk '{print $7}' | cut -d'/' -f1)
    if [ -n "$pid" ] && [ "$pid" != "-" ]; then
      kill -9 "$pid" 2>/dev/null || true
      ok "已释放端口 3006"
    fi
  fi
  
  # 3. 清理socket文件
  find / -name "nockchain*.sock" -delete 2>/dev/null || true
  find "$HOME" -name "*.sock" -delete 2>/dev/null || true
  rm -rf "$NCK_DIR/.socket"/*
  mkdir -p "$NCK_DIR/.socket"
  chmod -R 777 "$NCK_DIR/.socket"
  
  # 4. 修复可执行文件权限
  if [ -f "$NCK_DIR/target/release/nockchain" ]; then
    chmod +x "$NCK_DIR/target/release/nockchain"
    NOCKCHAIN_BIN="$NCK_DIR/target/release/nockchain"
  else
    err "未找到 nockchain 可执行文件"
    return 1
  fi
  
  ok "自动修复完成"
  
  # 5. 启动节点
  cd "$NCK_DIR"
  log "启动节点..."
  
  export RUST_MIN_STACK=33554432
  export RUST_LOG=info
  
  # 使用nohup启动（避免screen问题）
  nohup "$NOCKCHAIN_BIN" \
    --mining-pubkey "$MINING_PUBKEY" \
    --mine \
    --peer /ip4/95.216.102.60/udp/3006/quic-v1 \
    --peer /ip4/65.109.156.108/udp/3006/quic-v1 \
    --peer /ip4/65.21.67.175/udp/3006/quic-v1 \
    --peer /ip4/65.109.156.172/udp/3006/quic-v1 \
    --peer /ip4/34.174.22.166/udp/3006/quic-v1 \
    --npc-socket "$NCK_DIR/.socket/nockchain.sock" \
    --bind /ip4/0.0.0.0/udp/3006/quic-v1 > "$NODE_LOG" 2>&1 &
  
  NODE_PID=$!
  sleep 5
  
  # 6. 验证启动状态
  if kill -0 $NODE_PID 2>/dev/null; then
    ok "节点已成功启动 (PID: $NODE_PID)"
    ok "日志文件: $NODE_LOG"
  else
    err "节点启动失败"
    warn "请检查日志: $NODE_LOG"
  fi
  
  pause
}

# ---------- 查看日志 ----------
view_logs() {
  if [ -f "$NODE_LOG" ]; then
    tail -n 100 -f "$NODE_LOG"
  else
    err "日志文件不存在: $NODE_LOG"
  fi
  pause
}

# ---------- 检查状态 ----------
check_status() {
  log "检查系统状态"
  
  echo -e "${BLUE}=== 节点状态 ===${RESET}"
  if pgrep -f "nockchain.*--mine" >/dev/null; then
    ok "节点进程正在运行"
    ps -ef | grep "nockchain" | grep -v grep
  else
    err "节点进程未运行"
  fi
  
  echo -e "\n${BLUE}=== 端口状态 ===${RESET}"
  if command -v netstat >/dev/null 2>&1; then
    if netstat -tulpn 2>/dev/null | grep -q ":3006"; then
      ok "端口 3006 已绑定"
    else
      warn "端口 3006 未绑定"
    fi
  fi
  
  echo -e "\n${BLUE}=== 配置状态 ===${RESET}"
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE"
    if [ -n "$MINING_PUBKEY" ]; then
      ok "挖矿公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}"
    else
      warn "挖矿公钥: 未设置"
    fi
  else
    warn "配置文件不存在"
  fi
  
  pause
}

# ---------- 主菜单 ----------
while true; do
  clear
  echo -e "${CYAN}${BOLD}"
  echo "================================================"
  echo "        Nockchain 集成修复版脚本 v31.0"
  echo "================================================"
  echo -e "${RESET}"
  echo ""
  echo -e "${GREEN}🔧 安装选项（集成修复）:${RESET}"
  echo "  1) 完整安装 Nockchain（自动修复所有问题）"
  echo ""
  echo -e "${GREEN}🔑 节点管理:${RESET}"
  echo "  2) 设置/更改挖矿公钥"
  echo "  3) 智能启动节点（自动修复）"
  echo "  4) 查看节点日志"
  echo "  5) 检查系统状态"
  echo ""
  echo "  0) 退出脚本"
  echo ""
  echo -e "${YELLOW}✨ 新功能: 所有修复选项已集成到安装和启动流程中${RESET}"
  echo ""
  read -rp "请选择操作 (0-5): " choice
  
  case $choice in
    1) complete_installation_with_fixes ;;
    2) set_mining_pubkey ;;
    3) start_node_with_integrated_fixes ;;
    4) view_logs ;;
    5) check_status ;;
    0) echo -e "${GREEN}感谢使用！${RESET}"; exit 0 ;;
    *) warn "无效选项，请重新选择"; sleep 1 ;;
  esac
done
