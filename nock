#!/bin/bash

# ========= 色彩定义 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= 项目路径 =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"

# ========= 环境变量设置 =========
export RUST_BACKTRACE=full
export CARGO_NET_RETRY=10
export CARGO_NET_TIMEOUT=120

# ========= 横幅 =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain 社区验证安装脚本 v4.0"
  echo "==============================================="
  echo -e "${RESET}"
  echo "📌 作者: K2 节点教程分享"
  echo "🔗 Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "🐦 Twitter:  https://x.com/BtcK241918"
  echo "⚡ 基于社区成功案例: Ubuntu 22.04 + 18GB RAM"
  echo "-----------------------------------------------"
  echo ""
}

# ========= 系统检查 =========
function check_system_requirements() {
  echo -e "[*] 检查系统要求..."
  
  # 检查内存（根据搜索结果[2]，成功案例使用18GB RAM）
  total_mem_kb=$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || echo "0")
  total_mem_gb=$((total_mem_kb / 1024 / 1024))
  
  echo -e "${BLUE}[i] 当前系统内存: ${total_mem_gb}GB${RESET}"
  echo -e "${BLUE}[i] 社区成功案例配置: 1CPU/18GB RAM${RESET}"[2]
  
  if [ $total_mem_gb -lt 4 ]; then
    echo -e "${RED}[-] 严重警告: 内存严重不足 (${total_mem_gb}GB < 4GB)${RESET}"
    echo -e "${RED}    根据社区反馈，内存不足会导致panic错误${RESET}"[4]
    read -p "是否继续? (y/N): " continue_choice
    if [[ ! "$continue_choice" =~ ^[Yy]$ ]]; then
      exit 1
    fi
  elif [ $total_mem_gb -lt 8 ]; then
    echo -e "${YELLOW}[!] 警告: 内存偏低，建议至少8GB${RESET}"
  else
    echo -e "${GREEN}[+] 内存检查通过: ${total_mem_gb}GB${RESET}"
  fi
  
  # 检查磁盘空间
  free_space=$(df -BG "$HOME" | tail -1 | awk '{print $4}' | sed 's/G//')
  if [ "$free_space" -lt 20 ]; then
    echo -e "${RED}[-] 警告: 磁盘空间不足，建议至少20GB可用空间${RESET}"
  else
    echo -e "${GREEN}[+] 磁盘空间检查通过: ${free_space}GB可用${RESET}"
  fi
  
  # 检查操作系统
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    OS="linux"
    if grep -q "Ubuntu" /etc/os-release 2>/dev/null; then
      ubuntu_version=$(grep VERSION_ID /etc/os-release | cut -d'"' -f2)
      echo -e "${GREEN}[+] 检测到Ubuntu ${ubuntu_version}${RESET}"
    fi
  else
    OS="unknown"
    echo -e "${YELLOW}[!] 注意: 社区成功案例基于Ubuntu 22.04${RESET}"[2]
  fi
}

# ========= 社区验证的依赖安装 =========
function install_dependencies_community() {
  echo -e "[*] 安装社区验证的依赖包..."[2]
  
  # 根据搜索结果[2]中成功案例的依赖列表
  sudo apt-get update && sudo apt-get upgrade -y
  
  sudo apt install \
    curl iptables build-essential git wget lz4 jq make gcc nano \
    automake autoconf tmux htop nvme-cli libgbm1 pkg-config \
    libssl-dev libleveldb-dev tar clang bsdmainutils ncdu unzip \
    libleveldb-dev libclang-dev llvm-dev -y
  
  # 根据搜索结果[4]中Bruce的解决方案，确保build-essential
  sudo apt install build-essential -y
  
  echo -e "${GREEN}[+] 社区验证依赖安装完成${RESET}"
}

# ========= 内存优化和swap配置 =========
function setup_memory_optimization() {
  echo -e "[*] 配置内存优化..."
  
  # 如果内存不足16GB，增加swap
  if [ $total_mem_gb -lt 16 ]; then
    echo -e "${YELLOW}[*] 内存不足16GB，配置swap空间...${RESET}"
    
    # 检查现有swap
    current_swap=$(free -g | grep Swap | awk '{print $2}')
    if [ "$current_swap" -lt 8 ]; then
      echo -e "[*] 创建8GB swap文件..."
      sudo fallocate -l 8G /swapfile 2>/dev/null || sudo dd if=/dev/zero of=/swapfile bs=1M count=8192 2>/dev/null
      sudo chmod 600 /swapfile
      sudo mkswap /swapfile >/dev/null 2>&1
      sudo swapon /swapfile >/dev/null 2>&1
      
      # 添加到fstab
      if ! grep -q '/swapfile' /etc/fstab; then
        echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab >/dev/null
      fi
      
      echo -e "${GREEN}[+] Swap空间已配置${RESET}"
    fi
  fi
  
  # 内存管理优化
  sudo sysctl -w vm.overcommit_memory=1 >/dev/null 2>&1 || true
  sudo sysctl -w vm.max_map_count=655360 >/dev/null 2>&1 || true
  
  echo -e "${GREEN}[+] 内存优化完成${RESET}"
}

# ========= Rust环境设置 =========
function setup_rust_community() {
  echo -e "[*] 设置Rust环境（社区方案）..."[2][4]
  
  # 删除旧的Rust安装
  if [ -d "$HOME/.cargo" ]; then
    echo -e "${YELLOW}[*] 清理旧的Rust安装...${RESET}"
    rm -rf "$HOME/.cargo"
  fi
  if [ -d "$HOME/.rustup" ]; then
    rm -rf "$HOME/.rustup"
  fi
  
  # 根据搜索结果[2][4]的方法安装Rust
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
  
  # 立即加载环境
  source $HOME/.cargo/env
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 配置环境变量到shell
  for rc_file in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
    if [ -f "$rc_file" ]; then
      if ! grep -q 'source $HOME/.cargo/env' "$rc_file"; then
        echo 'source $HOME/.cargo/env' >> "$rc_file"
      fi
      if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$rc_file"; then
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
      fi
    fi
  done
  
  # 验证安装
  if command -v cargo >/dev/null 2>&1; then
    echo -e "${GREEN}[+] Rust安装成功${RESET}"
    rustc --version
    cargo --version
  else
    echo -e "${RED}[-] Rust安装失败${RESET}"
    return 1
  fi
}

# ========= 清理和克隆仓库 =========
function clean_and_clone_community() {
  echo -e "[*] 清理旧数据并克隆仓库..."[2]
  
  cd "$HOME" || exit 1
  
  # 根据搜索结果[2]的清理步骤
  echo -e "[*] 清理旧数据..."
  # kill miner screen
  screen -XS miner quit 2>/dev/null || true
  screen -XS nockchain quit 2>/dev/null || true
  
  # remove nockchain
  rm -rf nockchain
  rm -rf .nockapp
  
  echo -e "[*] 克隆Nockchain仓库..."
  # 根据搜索结果[4]使用官方仓库地址
  if ! git clone https://github.com/zorp-corp/nockchain; then
    echo -e "${RED}[-] 仓库克隆失败${RESET}"
    return 1
  fi
  
  cd nockchain || return 1
  echo -e "${GREEN}[+] 仓库克隆成功${RESET}"
}

# ========= 社区验证的构建流程 =========
function build_community_method() {
  echo -e "[*] 使用社区验证的构建方法..."[2]
  
  cd "$NCK_DIR" || return 1
  
  # 确保环境变量正确设置
  source $HOME/.cargo/env
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # Step 4: Build (根据搜索结果[2])
  echo -e "[*] 第1步: 设置环境文件..."
  cp .env_example .env
  echo -e "${GREEN}[+] .env文件创建成功${RESET}"
  
  # 设置内存友好的构建参数
  export CARGO_BUILD_JOBS=1
  export RUSTFLAGS="-C opt-level=1 -C debuginfo=0"
  
  echo -e "[*] 第2步: 构建hoonc..."
  if timeout 1800 make install-hoonc; then
    echo -e "${GREEN}[+] hoonc构建成功${RESET}"
  else
    echo -e "${YELLOW}[!] hoonc构建失败，但继续...${RESET}"
  fi
  
  # 确保PATH包含cargo bin
  export PATH="$HOME/.cargo/bin:$PATH"
  
  echo -e "[*] 第3步: 构建主项目..."
  if timeout 2400 make build; then
    echo -e "${GREEN}[+] 主项目构建成功${RESET}"
  else
    echo -e "${YELLOW}[!] 主项目构建可能有问题，继续...${RESET}"
  fi
  
  echo -e "[*] 第4步: 安装钱包..."
  if timeout 1200 make install-nockchain-wallet; then
    echo -e "${GREEN}[+] 钱包安装成功${RESET}"
  else
    echo -e "${YELLOW}[!] 钱包安装失败${RESET}"
  fi
  
  export PATH="$HOME/.cargo/bin:$PATH"
  
  echo -e "[*] 第5步: 安装节点..."
  if timeout 1200 make install-nockchain; then
    echo -e "${GREEN}[+] 节点安装成功${RESET}"
  else
    echo -e "${YELLOW}[!] 节点安装失败${RESET}"
  fi
  
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 检查构建结果
  echo -e "[*] 检查构建结果..."
  binary_count=0
  
  # 检查钱包
  if command -v nockchain-wallet >/dev/null 2>&1; then
    echo -e "${GREEN}  ✓ nockchain-wallet (已安装到PATH)${RESET}"
    ((binary_count++))
  elif [ -f "target/release/nockchain-wallet" ]; then
    echo -e "${GREEN}  ✓ target/release/nockchain-wallet${RESET}"
    ((binary_count++))
  fi
  
  # 检查节点
  if command -v nockchain >/dev/null 2>&1; then
    echo -e "${GREEN}  ✓ nockchain (已安装到PATH)${RESET}"
    ((binary_count++))
  elif [ -f "target/release/nockchain" ]; then
    echo -e "${GREEN}  ✓ target/release/nockchain${RESET}"
    ((binary_count++))
  fi
  
  if [ $binary_count -gt 0 ]; then
    echo -e "${GREEN}[+] 构建成功！发现 $binary_count 个可执行文件${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] 未发现可执行文件，但构建可能部分成功${RESET}"
    return 1
  fi
}

# ========= 主安装流程 =========
function setup_all() {
  echo -e "[*] 开始社区验证的安装流程..."[2]
  
  check_system_requirements
  install_dependencies_community
  setup_memory_optimization
  setup_rust_community
  
  if ! clean_and_clone_community; then
    echo -e "${RED}[-] 仓库准备失败${RESET}"
    pause_and_return
    return
  fi
  
  if build_community_method; then
    echo -e "${GREEN}[+] ✅ Nockchain安装成功！${RESET}"
    echo -e "${BLUE}[i] 基于社区成功案例 (Ubuntu 22.04 + 18GB RAM)${RESET}"[2]
    echo -e "${BLUE}[i] 如果区块高度停留在0，这是正常现象${RESET}"[4]
  else
    echo -e "${YELLOW}[!] 安装可能有部分问题${RESET}"
    echo -e "${BLUE}[i] 根据社区反馈，这种情况下仍可能可以运行${RESET}"
  fi
  
  pause_and_return
}

# ========= 钱包生成 =========
function generate_wallet() {
  echo -e "[*] 生成钱包..."[2]
  cd "$NCK_DIR" || return 1
  
  # 确保环境变量
  source $HOME/.cargo/env 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 查找钱包二进制文件
  wallet_bin=""
  if command -v nockchain-wallet >/dev/null 2>&1; then
    wallet_bin="nockchain-wallet"
  elif [ -f "target/release/nockchain-wallet" ]; then
    wallet_bin="./target/release/nockchain-wallet"
  elif [ -f "target/debug/nockchain-wallet" ]; then
    wallet_bin="./target/debug/nockchain-wallet"
  fi
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    echo -e "${YELLOW}[!] 请先完成项目构建${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${GREEN}[+] 使用钱包: $wallet_bin${RESET}"
  echo -e "${BLUE}[i] 根据社区指南，请保存memo、private key和public key${RESET}"[2]
  
  # 生成钱包
  if ! "$wallet_bin" keygen; then
    echo -e "${YELLOW}[!] 钱包生成可能遇到问题，请检查输出${RESET}"
  fi
  
  echo -e "${YELLOW}[!] 钱包生成完成，请复制上方公钥到下一步设置中${RESET}"
  echo -e "${BLUE}[i] 公钥格式为128位16进制字符串${RESET}"
  echo -e "${BLUE}[i] 请将公钥替换到.env文件的MINING_PUBKEY=处${RESET}"[2]
  pause_and_return
}

function validate_pubkey() {
  local pubkey="$1"
  
  if [ ${#pubkey} -ne 128 ]; then
    echo -e "${RED}[-] 公钥长度错误！应为128位，当前为${#pubkey}位${RESET}"
    return 1
  fi
  
  if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
    echo -e "${RED}[-] 公钥格式错误！只能包含0-9和a-f字符${RESET}"
    return 1
  fi
  
  return 0
}

function set_pubkey_env() {
  echo -e "[*] 设置 MINING_PUBKEY 到 .env..."[2]
  cd "$NCK_DIR" || return 1

  echo -e "${BLUE}[i] 公钥格式要求：128位16进制字符串${RESET}"
  echo -e "${BLUE}[i] 根据社区指南，替换.env文件中的MINING_PUBKEY=值${RESET}"[2]
  echo ""
  
  while true; do
    read -p "请输入公钥 (MINING_PUBKEY): " pubkey
    
    if [ -z "$pubkey" ]; then
      echo -e "${RED}[-] 公钥不能为空${RESET}"
      continue
    fi
    
    pubkey=$(echo "$pubkey" | tr -d ' \n\r\t')
    
    if validate_pubkey "$pubkey"; then
      pubkey=$(echo "$pubkey" | tr '[:upper:]' '[:lower:]')
      
      # 更新.env文件
      if command -v sed >/dev/null 2>&1; then
        sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || {
          grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        }
      else
        grep -v '^MINING_PUBKEY=' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
      fi
      echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
      
      echo -e "${GREEN}[+] 公钥格式验证通过，已写入 .env 文件${RESET}"
      echo -e "${GREEN}[+] 公钥: $pubkey${RESET}"
      break
    else
      echo -e "${YELLOW}[!] 请重新输入正确格式的公钥${RESET}"
    fi
  done
  
  pause_and_return
}

function export_keys() {
  echo -e "[*] 导出钱包密钥..."[2]
  cd "$NCK_DIR" || return 1
  
  # 确保环境变量
  source $HOME/.cargo/env 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"
  
  wallet_bin=""
  if command -v nockchain-wallet >/dev/null 2>&1; then
    wallet_bin="nockchain-wallet"
  elif [ -f "target/release/nockchain-wallet" ]; then
    wallet_bin="./target/release/nockchain-wallet"
  elif [ -f "target/debug/nockchain-wallet" ]; then
    wallet_bin="./target/debug/nockchain-wallet"
  fi
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  "$wallet_bin" export-keys
  echo -e "${GREEN}[+] 密钥已导出到 keys.export${RESET}"
  echo -e "${BLUE}[i] 确保keys.export文件在nockchain目录中${RESET}"[2]
  pause_and_return
}

function import_keys() {
  echo -e "[*] 导入钱包密钥..."[2]
  cd "$NCK_DIR" || return 1
  
  # 确保环境变量
  source $HOME/.cargo/env 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"
  
  wallet_bin=""
  if command -v nockchain-wallet >/dev/null 2>&1; then
    wallet_bin="nockchain-wallet"
  elif [ -f "target/release/nockchain-wallet" ]; then
    wallet_bin="./target/release/nockchain-wallet"
  elif [ -f "target/debug/nockchain-wallet" ]; then
    wallet_bin="./target/debug/nockchain-wallet"
  fi
  
  if [ -z "$wallet_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain-wallet二进制文件${RESET}"
    pause_and_return
    return
  fi
  
  read -p "[?] 请输入密钥文件路径 (默认: ./keys.export): " keyfile
  keyfile=${keyfile:-"./keys.export"}
  
  if [ -f "$keyfile" ]; then
    "$wallet_bin" import-keys --input "$keyfile"
    echo -e "${GREEN}[+] 密钥已导入${RESET}"
  else
    echo -e "${RED}[-] 密钥文件不存在: $keyfile${RESET}"
  fi
  pause_and_return
}

# ========= 启动节点（社区命令）=========
function start_node_community() {
  echo -e "[*] 启动Nockchain节点（社区方法）..."[2]
  cd "$NCK_DIR" || return 1
  
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] .env文件不存在${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"

  if [ -z "$MINING_PUBKEY" ]; then
    echo -e "${RED}[-] 未设置 MINING_PUBKEY，请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi

  # 确保环境变量
  source $HOME/.cargo/env 2>/dev/null || true
  export PATH="$HOME/.cargo/bin:$PATH"

  # 查找节点二进制文件
  node_bin=""
  if command -v nockchain >/dev/null 2>&1; then
    node_bin="nockchain"
  elif [ -f "target/release/nockchain" ]; then
    node_bin="./target/release/nockchain"
  elif [ -f "target/debug/nockchain" ]; then
    node_bin="./target/debug/nockchain"
  fi
  
  if [ -z "$node_bin" ]; then
    echo -e "${RED}[-] 未找到nockchain二进制文件${RESET}"
    pause_and_return
    return
  fi

  echo -e "${GREEN}[+] 使用节点: $node_bin${RESET}"
  echo -e "${BLUE}[i] 根据社区反馈，如果区块高度停留在0是正常现象${RESET}"[4]
  echo -e "${BLUE}[i] 使用社区验证的启动命令${RESET}"[2]

  # 清理旧数据（根据搜索结果[2]）
  rm -rf ./.data.nockchain .socket/nockchain_npc.sock 2>/dev/null || true
  mkdir -p .socket

  # 构建社区验证的启动命令[2]
  start_cmd="RUST_LOG=info $node_bin --mining-pubkey $MINING_PUBKEY \
--mine \
--peer /ip4/95.216.102.60/udp/3006/quic-v1 \
--peer /ip4/65.109.156.108/udp/3006/quic-v1 \
--peer /ip4/65.21.67.175/udp/3006/quic-v1 \
--peer /ip4/65.109.156.172/udp/3006/quic-v1 \
--peer /ip4/34.174.22.166/udp/3006/quic-v1 \
--peer /ip4/34.95.155.151/udp/30000/quic-v1 \
--peer /ip4/34.18.98.38/udp/30000/quic-v1 \
--npc-socket .socket/nockchain.sock \
--bind /ip4/0.0.0.0/udp/3006/quic-v1 \
--max-established-incoming 1000 \
--max-established-outgoing 1000 \
--max-established 2000 \
--max-established-per-peer 10"

  if ! command -v screen >/dev/null 2>&1; then
    echo -e "${YELLOW}[!] screen未安装，直接后台启动...${RESET}"
    nohup bash -c "$start_cmd" > nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动，日志文件: nockchain.log${RESET}"
  else
    if screen -list | grep -qw "nockchain"; then
      echo "[*] 关闭旧的 screen 会话..."
      screen -S nockchain -X quit >/dev/null 2>&1
      sleep 2
    fi

    screen -dmS nockchain bash -c "cd '$NCK_DIR' && $start_cmd"

    sleep 3
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] 节点已启动 (screen 会话名: nockchain)${RESET}"
      echo -e "${GREEN}[+] 使用公钥: $MINING_PUBKEY${RESET}"
      echo -e "${YELLOW}[!] 使用 'screen -r nockchain' 查看日志${RESET}"
      echo -e "${BLUE}[i] 端口 3006/udp 用于P2P通信${RESET}"[2]
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
      echo "请检查错误日志"
    fi
  fi
  
  pause_and_return
}

function view_logs() {
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] 进入日志查看 (Ctrl+A+D 可退出)...${RESET}"
    screen -r nockchain
  elif [ -f "$NCK_DIR/nockchain.log" ]; then
    echo -e "${YELLOW}[!] 显示最近日志 (按Ctrl+C退出):${RESET}"
    tail -f "$NCK_DIR/nockchain.log"
  else
    echo -e "${RED}[-] 节点未运行且无日志文件${RESET}"
  fi
  pause_and_return
}

function check_status() {
  echo -e "[*] 检查节点状态..."
  
  cd "$NCK_DIR" || return 1
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE" >/dev/null 2>&1
    if [ -n "$MINING_PUBKEY" ]; then
      echo -e "${GREEN}[+] 已配置公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}${RESET}"
    else
      echo -e "${YELLOW}[!] 未设置挖矿公钥${RESET}"
    fi
  fi
  
  running=false
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] 节点运行中 (screen模式)${RESET}"
    running=true
  elif pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "${GREEN}[+] 节点运行中 (后台模式)${RESET}"
    running=true
  else
    echo -e "${RED}[-] 节点未运行${RESET}"
  fi
  
  if [ "$running" = true ]; then
    echo -e "${BLUE}[i] 社区提醒: 区块高度停留在0是正常现象${RESET}"[4]
    echo -e "${YELLOW}[*] 系统资源使用情况:${RESET}"
    if command -v htop >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] 启动htop监控 (5秒后自动返回):${RESET}"
      timeout 5 htop -d 1 2>/dev/null || true
    elif command -v top >/dev/null 2>&1; then
      echo -e "${YELLOW}[*] CPU和内存使用情况:${RESET}"
      top -b -n1 | head -20
    fi
  fi
  
  # 显示钱包状态检查命令[2]
  if [ "$running" = true ] && [ -n "$MINING_PUBKEY" ]; then
    echo -e "${BLUE}[i] 检查钱包状态命令:${RESET}"
    echo -e "${BLUE}    nockchain-wallet --nockchain-socket \$HOME/nockchain/.socket/nockchain.sock list-notes-by-pubkey -p $MINING_PUBKEY${RESET}"[2]
  fi
  
  pause_and_return
}

function stop_node() {
  echo -e "[*] 停止节点..."
  stopped=false
  
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    screen -S nockchain -X quit >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if pgrep -f "nockchain" >/dev/null 2>&1; then
    pkill -f "nockchain" >/dev/null 2>&1
    sleep 2
    stopped=true
  fi
  
  if [ "$stopped" = true ]; then
    echo -e "${GREEN}[+] 节点已停止${RESET}"
  else
    echo -e "${YELLOW}[!] 节点未运行${RESET}"
  fi
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

function main_menu() {
  show_banner
  echo "请选择操作:"
  echo "  1) 🚀 社区验证安装 (基于Ubuntu 22.04成功案例)"
  echo "  2) 🔑 生成钱包"
  echo "  3) 📝 设置挖矿公钥 (128位16进制)"
  echo "  4) 💾 导出密钥"
  echo "  5) 📂 导入密钥"
  echo "  6) ⚡ 启动节点 (社区命令)"
  echo "  7) 📊 查看日志"
  echo "  8) 🔍 检查状态"
  echo "  9) ⏹️  停止节点"
  echo "  0) 退出"
  echo ""
  echo -e "${BLUE}💡 本版本基于社区成功案例: 1CPU/18GB RAM + Ubuntu 22.04${RESET}"[2]
  echo -e "${BLUE}💡 解决了内存panic和构建顺序问题${RESET}"[4]
  echo ""
  read -p "请输入编号: " choice

  case "$choice" in
    1) setup_all ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    6) start_node_community ;;
    7) view_logs ;;
    8) check_status ;;
    9) stop_node ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

main_menu
