#!/bin/bash

# ==============================================================================
# Nockchain å®‰è£…/ç®¡ç†åŠ©æ‰‹
# è„šæœ¬ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº« (@BtcK241918)
# Telegram: https://t.me/+EaCiFDOghoM3Yzll
# Twitter:  https://x.com/BtcK241918
# ==============================================================================
# åŠŸèƒ½:
# - è‡ªåŠ¨åŒ– Nockchain èŠ‚ç‚¹åŠçŸ¿æœºçš„å®‰è£…ã€æ„å»ºã€æ›´æ–°ã€‚
# - é’±åŒ…å¯†é’¥ç”Ÿæˆã€å¯¼å…¥ã€å¯¼å‡ºã€‚
# - é…ç½®ä¼˜åŒ–æŒ–çŸ¿å¯åŠ¨è„šæœ¬ (å¤šçº¿ç¨‹åˆ©ç”¨)ã€‚
# - é…ç½® Systemd æœåŠ¡å®ç°çŸ¿æœºè‡ªåŠ¨å¯åŠ¨/é‡å¯ (æ¨è)ã€‚
# - å®‰è£…å’Œé…ç½® sccache åŠ é€Ÿç¼–è¯‘ (æ¨è)ã€‚
# ==============================================================================

# ========= è‰²å½©å®šä¹‰ =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
TERMINAL_BLUE='\033[0;36m' # Teal/Cyan for sccache
YELLOW='\033[1;33m'
RED='\033[0;31m'

# ========= é¡¹ç›®è·¯å¾„ =========
# å°è¯•æ ¹æ®è„šæœ¬ä½ç½®ç¡®å®š NCK_DIRï¼Œå¦‚æœè„šæœ¬è¢«ç§»åŠ¨ï¼Œä»ç„¶æŒ‡å‘ HOME ä¸‹çš„æ ‡å‡†ä½ç½®
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
# Fallback to standard location if script is not within the expected structure or doesn't exist
if [[ "$SCRIPT_DIR" == *"nockchain"* ]]; then
    # Assume script is in nockchain/scripts or similar
    NCK_DIR="$(dirname "$SCRIPT_DIR")"
else
    NCK_DIR="$HOME/nockchain"
fi

ENV_FILE="$NCK_DIR/.env"
# Service file requires root, defined globally for clarity but only used in root functions
SERVICE_FILE="/etc/systemd/system/nockchain-miner.service"
MINER_SCRIPT="$NCK_DIR/scripts/run_nockchain_miner.sh" # Define run script path globally


# ========= å¸¸ç”¨å‡½æ•° =========

# æ˜¾ç¤ºè„šæœ¬æ¨ªå¹…
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain å®‰è£…/ç®¡ç†åŠ©æ‰‹"
  echo "==============================================="
  echo -e "${RESET}"
  echo "ğŸ“Œ ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº«"
  echo "ğŸ”— Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "ğŸ¦ Twitter:  https://x.com/BtcK241918"
  echo "-----------------------------------------------"
  echo ""
  echo "âœ¨ ä¼˜åŒ–æŒ–çŸ¿: é…ç½®çº¿ç¨‹åˆ©ç”¨, æ¨èä½¿ç”¨ Systemd å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯ âœ¨"
  echo "âš¡ ä¼˜åŒ–ç¼–è¯‘: åˆ©ç”¨å¤šæ ¸å¿ƒå¹¶è¡Œç¼–è¯‘ï¼Œæ¨èé…ç½® sccache åŠ é€Ÿ âš¡"
  echo ""
}

# æš‚åœå¹¶è¿”å›èœå•
function pause_and_return() {
  echo ""
  read -n1 -r -p "æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•..." key
  main_menu
}

# æ£€æŸ¥äº’è”ç½‘è¿æ¥
function check_internet() {
  echo -e "[*] æ£€æŸ¥äº’è”ç½‘è¿æ¥..."
  # ä½¿ç”¨ ping æ£€æŸ¥ï¼Œè®¾ç½®è¶…æ—¶å’Œæ¬¡æ•°
  if ping -c 1 -W 3 8.8.8.8 &> /dev/null; then
    echo -e "${GREEN}[+] äº’è”ç½‘è¿æ¥æ­£å¸¸${RESET}"
    return 0
  else
    echo -e "${RED}[-] é”™è¯¯: æ— æ³•è¿æ¥åˆ°äº’è”ç½‘ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè®¾ç½®ã€‚${RESET}"
    return 1
  fi
}

# æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ root
function check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}[-] é”™è¯¯: æ­¤æ“ä½œéœ€è¦ root æƒé™ã€‚è¯·ä½¿ç”¨ ${BOLD}sudo $0${RESET}${RED} è¿è¡Œæ­¤è„šæœ¬æˆ–åˆ‡æ¢åˆ° root ç”¨æˆ·ã€‚${RESET}"
        return 1
    fi
    return 0
}

# è¿è¡Œå‘½ä»¤å¹¶è¿›è¡Œé‡è¯•
# Usage: run_with_retries <command> [retries] [delay_seconds]
function run_with_retries() {
  local cmd="$1"
  local retries=${2:-3} # Default 3 retries
  local delay=${3:-10} # Default 10 seconds delay
  local attempt=1
  local success=0

  echo -e "[*] æ‰§è¡Œå‘½ä»¤: ${BOLD}$cmd${RESET}"

  while [ "$attempt" -le $((retries + 1)) ]; do
    echo -e "[*] å°è¯• $attempt/$((retries + 1))..."
    # Use 'eval' to execute the command string correctly.
    # Redirect stdout/stderr to see progress during retries
    if eval "$cmd"; then
      echo -e "${GREEN}[+] å‘½ä»¤æˆåŠŸ: ${BOLD}$cmd${RESET}"
      success=1
      break # Exit loop on success
    else
      local exit_code=$?
      if [ "$attempt" -le "$retries" ]; then
        echo -e "${YELLOW}[-] å°è¯• $attempt/$((retries + 1)) å¤±è´¥ (é€€å‡ºç : $exit_code)ã€‚ç­‰å¾… ${delay}s åé‡è¯•...${RESET}"
        sleep "$delay"
      else
        echo -e "${RED}[-] é”™è¯¯: å‘½ä»¤åœ¨æ‰€æœ‰ $((retries + 1)) æ¬¡å°è¯•åå¤±è´¥: ${BOLD}$cmd${RESET} (é€€å‡ºç : $exit_code)${RESET}"
        success=0 # Ensure failure status
      fi
    fi
    attempt=$((attempt + 1))
  done

  return $((1 - success)) # Return 0 for success, 1 for failure
}

# åˆ‡æ¢åˆ°é¡¹ç›®ç›®å½•å¹¶æ£€æŸ¥
function cd_nck_dir() {
  echo -e "[*] åˆ‡æ¢åˆ°é¡¹ç›®ç›®å½•: $NCK_DIR"
  if [ -d "$NCK_DIR" ]; then
    if cd "$NCK_DIR"; then
      echo -e "${GREEN}[+] å·²è¿›å…¥ç›®å½•${RESET}"
      return 0
    else
      echo -e "${RED}[-] é”™è¯¯: æ— æ³•è¿›å…¥ç›®å½• $NCK_DIR${RESET}"
      return 1
    fi
  else
    echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
    return 1
  fi
}

# æ£€æŸ¥å¹¶ç¡®è®¤ MINING_PUBKEY æ˜¯å¦å·²è®¾ç½®
function check_pubkey() {
  echo -e "[*] æ£€æŸ¥ MINING_PUBKEY é…ç½®..."
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] é”™è¯¯ï¼š.env æ–‡ä»¶ä¸å­˜åœ¨: $ENV_FILEã€‚è¯·ä½¿ç”¨é€‰é¡¹ 1 å®‰è£…æˆ–é€‰é¡¹ 3 è®¾ç½®ã€‚${RESET}"
    return 1 # Indicate failure
  fi

  # Read MINING_PUBKEY safely from .env
  local mining_pubkey_value=""
  # Using grep to find the line and cut to extract the value
  mining_pubkey_value=$(grep "^MINING_PUBKEY=" "$ENV_FILE" | cut -d '=' -f 2-)

  if [ -z "$mining_pubkey_value" ]; then
     echo -e "${RED}[-] é”™è¯¯ï¼š.env æ–‡ä»¶ä¸­ MINING_PUBKEY æœªè®¾ç½®æˆ–ä¸ºç©ºã€‚è¯·ä½¿ç”¨é€‰é¡¹ 3 è®¾ç½®ã€‚${RESET}"
     return 1 # Indicate failure
  fi
  echo -e "${GREEN}[+] MINING_PUBKEY å·²è®¾ç½®: ${mining_pubkey_value}${RESET}"
  return 0 # Indicate success
}

# ç¡®ä¿ ~/.cargo/env å·² sourced å¹¶åœ¨ shell RC æ–‡ä»¶ä¸­é…ç½®
function setup_cargo_env() {
    local cargo_env_file="$HOME/.cargo/env"
    local rc_file=""

    echo -e "[*] é…ç½® Rust ç¯å¢ƒå˜é‡..."

    # Determine RC file based on shell
    case "$(basename "$SHELL")" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh)  rc_file="$HOME/.zshrc" ;;
        fish) rc_file="$HOME/.config/fish/config.fish" ;;
        *)    echo -e "${YELLOW}[!] è­¦å‘Š: æœªçŸ¥ Shell (${SHELL})ã€‚è¯·æ‰‹åŠ¨å°† 'source $cargo_env_file' æ·»åŠ åˆ°æ‚¨çš„ Shell å¯åŠ¨æ–‡ä»¶ã€‚${RESET}"; return 0 ;; # Continue but warn
    esac

    # Source in current shell session
    if [ -f "$cargo_env_file" ]; then
        source "$cargo_env_file"
        echo -e "${GREEN}[+] å·²åœ¨å½“å‰ Shell ä¼šè¯ä¸­åŠ è½½ Rust ç¯å¢ƒå˜é‡ã€‚${RESET}"
    else
        echo -e "${RED}[-] é”™è¯¯: Rust ç¯å¢ƒå˜é‡æ–‡ä»¶ '$cargo_env_file' ä¸å­˜åœ¨ã€‚Rust å¯èƒ½æœªæ­£ç¡®å®‰è£…ã€‚${RESET}"
        return 1
    fi

    # Add to RC file if not present (skip for fish, requires manual config)
    if [[ "$(basename "$SHELL")" != "fish" ]]; then
        if [ -f "$rc_file" ] && grep -q "source \"\$HOME/.cargo/env\"" "$rc_file"; then
            echo -e "${YELLOW}[*] Rust ç¯å¢ƒå˜é‡é…ç½®å·²å­˜åœ¨äº $rc_fileã€‚è·³è¿‡ã€‚${RESET}"
        else
            echo "" >> "$rc_file" # Add newline for safety
            echo "# Nockchain setup script added Rust cargo environment" >> "$rc_file"
            echo "source \"\$HOME/.cargo/env\"" >> "$rc_file"
            echo -e "${GREEN}[+] å·²å°† Rust ç¯å¢ƒå˜é‡é…ç½®æ·»åŠ åˆ° $rc_fileã€‚${RESET}"
            echo -e "${YELLOW}[!] è¯·åœ¨æ–°ç»ˆç«¯ä¼šè¯ä¸­è¿è¡Œï¼Œæˆ–æ‰‹åŠ¨è¿è¡Œ 'source $rc_file' ä½¿å…¶ç”Ÿæ•ˆã€‚${RESET}"
        fi
    else
        echo -e "${YELLOW}[!] æ‚¨ä½¿ç”¨çš„æ˜¯ fish shell. è¯·æ‰‹åŠ¨å°† 'source $cargo_env_file' æ·»åŠ åˆ°æ‚¨çš„ fish é…ç½®æ–‡ä»¶ ($rc_file)ã€‚${RESET}"
    fi
    return 0
}


# --- é€šç”¨æ„å»ºå‡½æ•° ---
# This function performs the compilation and installation of binaries.
# It assumes the script is already in the NCK_DIR.
# It relies on CARGO_BUILD_JOBS and RUSTC_WRAPPER env vars being set externally if desired.
function build_project() {
    echo -e "[*] å¼€å§‹æ„å»ºé¡¹ç›®..."

    # Ensure in correct directory
    if ! cd_nck_dir; then return 1; fi

    # Ensure ~/.cargo/env is sourced for this session (for rustc, cargo, sccache)
    # This is also added to RC file, but sourcing here makes it work immediately.
    setup_cargo_env || { echo -e "${RED}[-] é…ç½® Rust ç¯å¢ƒå˜é‡å¤±è´¥ã€‚${RESET}"; return 1; }


    echo -e "[*] å®‰è£… hoonc..."
    if ! run_with_retries "make install-hoonc"; then
        echo -e "${RED}[-] install-hoonc å¤±è´¥${RESET}"
        return 1
    fi
    echo -e "${GREEN}[+] hoonc å®‰è£…å®Œæˆ${RESET}"

    echo -e "[*] ç¼–è¯‘ Nockchain (èŠ‚ç‚¹)..."
    # make build likely calls cargo build --release
    # CARGO_BUILD_JOBS and RUSTC_WRAPPER env vars are picked up by cargo
    if ! run_with_retries "make build"; then
        echo -e "${RED}[-] build å¤±è´¥${RESET}"
        echo -e "${YELLOW}[!] ç¼–è¯‘å¤±è´¥å¯èƒ½æ˜¯ç”±äºä¾èµ–ä¸‹è½½ã€ç½‘ç»œé—®é¢˜æˆ–ä»£ç é”™è¯¯ã€‚æ£€æŸ¥é”™è¯¯æ—¥å¿—ã€‚${RESET}"
        echo -e "${YELLOW}[!] å¦‚æœæ˜¯ç½‘ç»œé—®é¢˜ï¼Œé‡è¯•å®‰è£…é€šå¸¸å¯ä»¥è§£å†³ã€‚å¦‚æœæŒç»­å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç¯å¢ƒæˆ–ä»£ç é—®é¢˜ã€‚${RESET}"
        return 1
    fi
    echo -e "${GREEN}[+] Nockchain ç¼–è¯‘å®Œæˆ${RESET}"

    # Optional: Verify node executable exists
    if [ ! -f "./target/release/nockchain" ]; then
        echo -e "${YELLOW}[-] è­¦å‘Š: Nockchain èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ° (${NCK_DIR}/target/release/nockchain)ï¼Œå³ä½¿ make build æŠ¥å‘ŠæˆåŠŸã€‚${RESET}"
    fi


    echo -e "[*] å®‰è£…é’±åŒ…..."
    if ! run_with_retries "make install-nockchain-wallet"; then
        echo -e "${RED}[-] install-nockchain-wallet å¤±è´¥${RESET}"
        return 1
    fi
    # Optional: Verify wallet executable exists
    if [ ! -f "./target/release/nockchain-wallet" ]; then
        echo -e "${YELLOW}[-] è­¦å‘Š: é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ° (${NCK_DIR}/target/release/nockchain-wallet)ï¼Œå³ä½¿ make install-nockchain-wallet æŠ¥å‘ŠæˆåŠŸã€‚${RESET}"
    fi
    echo -e "${GREEN}[+] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶å®‰è£…å®Œæˆ${RESET}"


    return 0 # Indicate success
}
# --- ç»“æŸé€šç”¨æ„å»ºå‡½æ•° ---


# ========= ä¸»åŠŸèƒ½å‡½æ•° =========

# 1) ä¸€é”®å®‰è£…å¹¶æ„å»º (é¦–æ¬¡å®‰è£…æˆ–å®Œæ•´é‡è£…)
function setup_all() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¼€å§‹ä¸€é”®å®‰è£…å¹¶æ„å»º (é¦–æ¬¡å®‰è£…æˆ–å®Œæ•´é‡è£…)...${RESET}"
  echo -e "${YELLOW}[!] æç¤º: Rust ç¼–è¯‘æ—¶é—´å¯èƒ½è¾ƒé•¿ï¼Œç‰¹åˆ«æ˜¯é¦–æ¬¡ç¼–è¯‘ã€‚${RESET}"
  echo -e "${YELLOW}[!] å¼ºçƒˆæ¨èåœ¨å®‰è£…åä½¿ç”¨é€‰é¡¹ 11 å®‰è£…å¹¶é…ç½® sccache ä»¥åŠ é€Ÿåç»­ç¼–è¯‘ã€‚${RESET}"


  # æ£€æŸ¥ç½‘ç»œ
  if ! check_internet; then
    pause_and_return
    return
  fi

  echo -e "[*] å®‰è£…ç³»ç»Ÿä¾èµ– (apt)..."
  if ! run_with_retries "sudo apt update && sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen"; then
    echo -e "${RED}[-] ç³»ç»Ÿä¾èµ–å®‰è£…å¤±è´¥${RESET}"
    pause_and_return
    return
  fi
  echo -e "${GREEN}[+] ç³»ç»Ÿä¾èµ–å®‰è£…å®Œæˆ${RESET}"

  echo -e "[*] å®‰è£… Rust..."
  if ! command -v cargo &>/dev/null; then
    # Install Rust quietly (-y)
    if ! run_with_retries "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y"; then
       echo -e "${RED}[-] Rust å®‰è£…å¤±è´¥${RESET}"
       pause_and_return
       return
    fi
    echo -e "${GREEN}[+] Rust å®‰è£…å®Œæˆ${RESET}"
  else
      echo -e "${YELLOW}[*] Rust å·²å®‰è£…ï¼Œè·³è¿‡å®‰è£…æ­¥éª¤ã€‚${RESET}"
  fi
  # Ensure Rust environment is set up for current session and future sessions
  if ! setup_cargo_env; then
      pause_and_return
      return
  fi
  echo -e "${GREEN}[+] Rust å®‰è£…/é…ç½®å®Œæˆ${RESET}"


  echo -e "[*] è·å–æˆ–æ›´æ–°ä»“åº“..."
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] é¡¹ç›®ç›®å½•å·²å­˜åœ¨ï¼Œè¿›è¡Œ git pull..."
    if ! cd_nck_dir; then pause_and_return; return; fi # Check if cd was successful
    if ! run_with_retries "git pull"; then
        echo -e "${RED}[-] git pull å¤±è´¥${RESET}"
        echo -e "${YELLOW}[!] è¯·æ£€æŸ¥ç½‘ç»œæˆ–æ‰‹åŠ¨å¤„ç† git é—®é¢˜ã€‚${RESET}"
        pause_and_return
        return
    fi
  else
    echo -e "[*] å…‹éš†é¡¹ç›®ä»“åº“åˆ° $NCK_DIR..."
    # Ensure parent directory exists if NCK_DIR is not just $HOME/<name>
    mkdir -p "$(dirname "$NCK_DIR")" || { echo -e "${RED}[-] æ— æ³•åˆ›å»ºé¡¹ç›®çˆ¶ç›®å½•ã€‚${RESET}"; pause_and_return; return; }
    if ! run_with_retries "git clone https://github.com/zorp-corp/nockchain \"$NCK_DIR\""; then
        echo -e "${RED}[-] git clone å¤±è´¥${RESET}"
        echo -e "${YELLOW}[!] è¯·æ£€æŸ¥ç½‘ç»œæˆ– Git é…ç½®ã€‚${RESET}"
        pause_and_return
        return
    fi
    if ! cd_nck_dir; then pause_and_return; return; fi # Check if cd was successful
  fi
  echo -e "${GREEN}[+] ä»“åº“è·å–å®Œæˆ${RESET}"

  echo -e "[*] è®¾ç½® .env æ–‡ä»¶..."
  if [ ! -f "$ENV_FILE" ]; then
    cp .env_example "$ENV_FILE" || { echo -e "${RED}[-] å¤åˆ¶ .env_example å¤±è´¥${RESET}"; pause_and_return; return; }
    echo -e "${GREEN}[+] .env æ–‡ä»¶åˆ›å»ºå®Œæˆ (${ENV_FILE})ã€‚${RESET}"
  else
    echo -e "${YELLOW}[*] .env æ–‡ä»¶å·²å­˜åœ¨ (${ENV_FILE})ï¼Œè·³è¿‡åˆ›å»ºã€‚${RESET}"
  fi

  # --- Rust ç¼–è¯‘ä¼˜åŒ– ---
  # Set CARGO_BUILD_JOBS env var to maximize parallel compilation
  NUM_PROCESSORS=$(nproc || echo 1) # Default to 1 if nproc fails
  echo -e "[*] è®¾ç½® CARGO_BUILD_JOBS=${NUM_PROCESSORS} å¯ç”¨ ${NUM_PROCESSORS} æ ¸å¿ƒå¹¶è¡Œç¼–è¯‘..."
  export CARGO_BUILD_JOBS="$NUM_PROCESSORS"
  # --------------------

  # --- è°ƒç”¨é€šç”¨çš„æ„å»ºå‡½æ•° ---
  if ! build_project; then
    echo -e "${RED}[-] é¡¹ç›®æ„å»ºå¤±è´¥ã€‚${RESET}"
    # Unset jobs var even on failure
    unset CARGO_BUILD_JOBS
    pause_and_return
    return
  fi
  echo -e "${GREEN}[+] é¡¹ç›®æ„å»ºå®Œæˆã€‚${RESET}"
  # --- æ„å»ºå‡½æ•°ç»“æŸ ---

  # --- æ¸…é™¤ CARGO_BUILD_JOBS ç¯å¢ƒå˜é‡ï¼Œä»¥å…å½±å“åç»­éç¼–è¯‘å‘½ä»¤ ---
  unset CARGO_BUILD_JOBS
  # --------------------------------------------------------------

  echo -e "${GREEN}[+] ä¸€é”®å®‰è£…å¹¶æ„å»ºæµç¨‹å®Œæˆ${RESET}"
  echo -e "${YELLOW}[!] æ¥ä¸‹æ¥è¯·åŠ¡å¿…æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ä»¥è¿›è¡ŒæŒ–çŸ¿ä¼˜åŒ–å’Œå¯åŠ¨:${RESET}"
  echo -e "${YELLOW}    1. ç”Ÿæˆé’±åŒ… (é€‰é¡¹ 2)${RESET}"
  echo -e "${YELLOW}    2. å°†ç”Ÿæˆçš„å…¬é’¥è®¾ç½®åˆ° .env æ–‡ä»¶ (é€‰é¡¹ 3) - ${BOLD}å¿…é¡»è®¾ç½®!${RESET}${YELLOW}"
  echo -e "${YELLOW}    3. é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨ (é€‰é¡¹ 8) - ${BOLD}å¼ºçƒˆæ¨è!${RESET}${YELLOW}"
  echo -e "${YELLOW}    4. é…ç½® Systemd æœåŠ¡å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯ (é€‰é¡¹ 9) - ${BOLD}å¼ºçƒˆæ¨è!${RESET}${YELLOW}"
  echo -e "${YELLOW}    5. å¯åŠ¨çŸ¿æœºæœåŠ¡: ${BOLD}sudo systemctl start nockchain-miner${RESET}${YELLOW}"
  echo -e "${YELLOW}    (æˆ–ä½¿ç”¨é€‰é¡¹ 6/7 ä½¿ç”¨ Screen æ–¹å¼ï¼Œä½† Systemd æ›´ç¨³å®šæŒä¹…)${RESET}"
  echo -e "${TERMINAL_BLUE}[!] æ¨è: ä½¿ç”¨é€‰é¡¹ 11 å®‰è£…é…ç½® sccache åŠ é€Ÿåç»­ç¼–è¯‘/æ›´æ–°é€Ÿåº¦!${RESET}"

  pause_and_return
}

# 11) å®‰è£…å’Œé…ç½® sccache åŠ é€Ÿç¼–è¯‘
function setup_sccache() {
    show_banner # Refresh banner
    echo -e "${TERMINAL_BLUE}[*] å®‰è£…å’Œé…ç½® sccache ä»¥åŠ é€Ÿ Rust ç¼–è¯‘...${RESET}"
    echo -e "${YELLOW}[!] sccache ä¼šç¼“å­˜ç¼–è¯‘ç»“æœï¼Œå¯¹åç»­å¢é‡ç¼–è¯‘æé€Ÿæ˜æ˜¾ã€‚${RESET}"
    echo -e "${YELLOW}[!] é¦–æ¬¡å®‰è£… sccache æœ¬èº«å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚${RESET}"

    # Check if Rust is installed and cargo is in PATH
    if ! command -v cargo &>/dev/null; then
        echo -e "${RED}[-] é”™è¯¯: æœªæ£€æµ‹åˆ° Rust/cargoã€‚è¯·å…ˆæ‰§è¡Œé€‰é¡¹ 1 å®‰è£… Rustã€‚${RESET}"
        pause_and_return
        return
    fi

    # Check if sccache is already installed
    if command -v sccache &>/dev/null; then
        echo -e "${YELLOW}[*] sccache å·²å®‰è£…ã€‚è·³è¿‡å®‰è£…æ­¥éª¤ã€‚${RESET}"
    else
        echo -e "[*] å®‰è£… sccache (å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´)..."
        # Need to ensure ~/.cargo/bin is in PATH for this command to work reliably
        # Even if not in RC file yet, sourcing .cargo/env helps for the current session
        setup_cargo_env || { echo -e "${RED}[-] æ— æ³•åŠ è½½ cargo ç¯å¢ƒå˜é‡ï¼Œsccache å®‰è£…å¯èƒ½å¤±è´¥ã€‚${RESET}"; pause_and_return; return; }

        # Use --force to ensure it rebuilds/updates if needed, though usually not necessary
        if ! run_with_retries "cargo install sccache"; then
            echo -e "${RED}[-] sccache å®‰è£…å¤±è´¥ã€‚${RESET}"
            echo -e "${YELLOW}[!] è¯·æ£€æŸ¥ç½‘ç»œæˆ– cargo å®‰è£…æ˜¯å¦æ­£å¸¸ã€‚${RESET}"
            pause_and_return
            return
        fi
        echo -e "${GREEN}[+] sccache å®‰è£…å®Œæˆã€‚${RESET}"
    fi

    echo -e "[*] é…ç½® shell ç¯å¢ƒå˜é‡ (RUSTC_WRAPPER)..."
    # Determine user's current shell config file and syntax
    local shell_name=$(basename "$SHELL")
    local rc_file=""
    local env_cmd=""
    local check_cmd=""
    local append_cmd=""

    case "$shell_name" in
        bash)
            rc_file="$HOME/.bashrc"
            env_cmd='export RUSTC_WRAPPER="sccache"'
            check_cmd='^export RUSTC_WRAPPER=sccache'
            append_cmd="$env_cmd"
            ;;
        zsh)
            rc_file="$HOME/.zshrc"
            env_cmd='export RUSTC_WRAPPER="sccache"'
            check_cmd='^export RUSTC_WRAPPER=sccache'
            append_cmd="$env_cmd"
            ;;
        fish)
            rc_file="$HOME/.config/fish/config.fish"
            env_cmd='set -gx RUSTC_WRAPPER sccache' # fish syntax for global export
            check_cmd='^set -gx RUSTC_WRAPPER sccache'
            append_cmd="$env_cmd"
            ;;
        *)
            echo -e "${YELLOW}[!] è­¦å‘Š: æœªçŸ¥ Shell ($shell_name)ã€‚è¯·æ‰‹åŠ¨å°† 'RUSTC_WRAPPER=sccache' æ·»åŠ åˆ°æ‚¨çš„ Shell ç¯å¢ƒå˜é‡é…ç½®ä¸­ã€‚${RESET}"
            pause_and_return
            return
            ;;
    esac

    # Add to RC file if not present
    if [ -f "$rc_file" ]; then
        if grep -q "$check_cmd" "$rc_file"; then
            echo -e "${YELLOW}[*] RUSTC_WRAPPER é…ç½®å·²å­˜åœ¨äº $rc_fileã€‚è·³è¿‡é…ç½®ã€‚${RESET}"
        else
            # Ensure directory for fish config exists
            if [[ "$shell_name" == "fish" ]]; then
                mkdir -p "$(dirname "$rc_file")" || { echo -e "${RED}[-] æ— æ³•åˆ›å»º fish é…ç½®ç›®å½•ã€‚${RESET}"; pause_and_return; return; }
            fi
            echo "" >> "$rc_file" # Add newline for safety
            echo "# Nockchain setup script added sccache wrapper" >> "$rc_file"
            echo "$append_cmd" >> "$rc_file"
            echo -e "${GREEN}[+] å·²å°† '$append_cmd' æ·»åŠ åˆ° $rc_fileã€‚${RESET}"
        fi
    else
        # If rc file doesn't exist, create it (except for fish where directory might not exist)
        if [[ "$shell_name" != "fish" ]]; then
             echo "$append_cmd" >> "$rc_file"
             echo -e "${GREEN}[+] å·²å°† '$append_cmd' æ·»åŠ åˆ° ${rc_file} (æ–‡ä»¶å·²åˆ›å»º)ã€‚${RESET}"
        else
             # For fish, warn and ask user to create the file/dir
             echo -e "${YELLOW}[!] æ‚¨ä½¿ç”¨çš„æ˜¯ fish shellï¼Œä¸”é…ç½®æ–‡ä»¶ (${rc_file}) ä¸å­˜åœ¨ã€‚è¯·æ‰‹åŠ¨åˆ›å»ºç›®å½•å’Œæ–‡ä»¶ï¼Œå¹¶æ·»åŠ  '$append_cmd'ã€‚${RESET}"
             pause_and_return
             return
        fi
    fi

    # Set RUSTC_WRAPPER in current shell session for immediate use
    if [[ -n "$env_cmd" ]]; then
        # Execute the command in the current shell
        eval "$env_cmd"
        echo -e "${GREEN}[+] RUSTC_WRAPPER å·²åœ¨å½“å‰ Shell ä¼šè¯ä¸­è®¾ç½®ä¸º sccacheã€‚${RESET}"
    fi

    echo -e "${GREEN}[+] sccache é…ç½®å®Œæˆã€‚${RESET}"
    if [[ "$shell_name" != "fish" ]]; then
        echo -e "${YELLOW}[!] é‡è¦: ä¸ºäº†ä½¿ sccache åœ¨æ–°çš„ç»ˆç«¯ä¼šè¯æˆ– Systemd/Screen æœåŠ¡ä¸­ç”Ÿæ•ˆï¼Œé€šå¸¸ä¼šè‡ªåŠ¨åŠ è½½æ­¤é…ç½®ã€‚${RESET}"
        echo -e "${YELLOW}[!] å¦‚æœæ‚¨æƒ³åœ¨å½“å‰ç»ˆç«¯ç«‹å³ä½¿ç”¨ï¼Œè¯·è¿è¡Œ: ${BOLD}source $rc_file${RESET}${YELLOW}"
    else
        echo -e "${YELLOW}[!] é‡è¦: å¯¹äº fish shellï¼Œè¯·æ‰‹åŠ¨å°†é…ç½®æ·»åŠ åˆ° $rc_file å¹¶é‡æ–°å¯åŠ¨æ‚¨çš„ fish shell ä¼šè¯ã€‚${RESET}"
    fi
    echo -e "${YELLOW}[!] sccache ç¼“å­˜é»˜è®¤å­˜å‚¨åœ¨ ~/.cache/sccacheã€‚æ‚¨å¯ä»¥ä½¿ç”¨ '${BOLD}sccache --show-stats${RESET}${YELLOW}' æŸ¥çœ‹ç¼“å­˜çŠ¶æ€æˆ–ä½¿ç”¨ '${BOLD}sccache --zero-stats${RESET}${YELLOW}' æ¸…é›¶ç»Ÿè®¡ã€‚${RESET}"

    pause_and_return
}


# --- æ›´æ–°ä»£ç å¹¶é‡æ–°æ„å»ºå‡½æ•° ---
function update_and_rebuild() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¼€å§‹æ›´æ–°ä»£ç å¹¶é‡æ–°æ„å»º...${RESET}"
  echo -e "${YELLOW}[!] æç¤º: å¢é‡ç¼–è¯‘é€šå¸¸æ¯”é¦–æ¬¡ç¼–è¯‘å¿«ï¼Œç‰¹åˆ«æ˜¯å¦‚æœä½¿ç”¨ sccache (é€‰é¡¹ 11) åŠ é€Ÿã€‚${RESET}"

  # Check if NCK_DIR exists
  if [ ! -d "$NCK_DIR" ]; then
      echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
      echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 1 è¿›è¡Œé¦–æ¬¡å®‰è£…ã€‚"
      pause_and_return
      return
  fi

  # Change to NCK_DIR
  if ! cd_nck_dir; then pause_and_return; return; fi

  # Perform git pull
  echo -e "[*] æ‹‰å–æœ€æ–°ä»£ç ..."
  if ! run_with_retries "git pull"; then
      echo -e "${RED}[-] git pull å¤±è´¥ï¼Œæ— æ³•æ›´æ–°ä»£ç ã€‚${RESET}"
      echo "è¯·æ£€æŸ¥ç½‘ç»œæˆ–æ‰‹åŠ¨å¤„ç† git é—®é¢˜ã€‚"
      pause_and_return
      return
  fi
  echo -e "${GREEN}[+] ä»£ç æ›´æ–°å®Œæˆ${RESET}"

  # --- Rust ç¼–è¯‘ä¼˜åŒ– ---
  NUM_PROCESSORS=$(nproc || echo 1)
  echo -e "[*] è®¾ç½® CARGO_BUILD_JOBS=${NUM_PROCESSORS} å¯ç”¨ ${NUM_PROCESSORS} æ ¸å¿ƒå¹¶è¡Œç¼–è¯‘..."
  export CARGO_BUILD_JOBS="$NUM_PROCESSORS"
  # --------------------

  # Build the project using the common function
  if ! build_project; then
    echo -e "${RED}[-] é¡¹ç›®é‡æ–°æ„å»ºå¤±è´¥ã€‚${RESET}"
    # Unset jobs var even on failure
    unset CARGO_BUILD_JOBS
    pause_and_return
    return
  fi
  echo -e "${GREEN}[+] é¡¹ç›®é‡æ–°æ„å»ºå®Œæˆã€‚${RESET}"

  # --- æ¸…é™¤ CARGO_BUILD_JOBS ç¯å¢ƒå˜é‡ ---
  unset CARGO_BUILD_JOBS
  # ------------------------------------

  echo -e "${GREEN}[+] ä»£ç æ›´æ–°å¹¶é‡æ–°æ„å»ºå®Œæˆã€‚${RESET}"
  echo -e "${YELLOW}[!] é‡è¦: æ‚¨éœ€è¦æ‰‹åŠ¨åœæ­¢å¹¶é‡æ–°å¯åŠ¨çŸ¿æœºï¼Œä»¥è¿è¡Œæ–°æ„å»ºçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚${RESET}"
  echo -e "${YELLOW}[!] å¦‚æœä½¿ç”¨ Systemd ç®¡ç†ï¼Œè¯·ä½¿ç”¨é€‰é¡¹ 13 è¿›è¡Œæ›´æ–°ã€æ„å»ºå¹¶è‡ªåŠ¨é‡å¯ã€‚${RESET}"

  pause_and_return
}
# --- ç»“æŸæ›´æ–°ä»£ç å¹¶é‡æ–°æ„å»ºå‡½æ•° ---

# --- æ›´æ–°ã€æ„å»ºå¹¶é‡å¯ Systemd æœåŠ¡å‡½æ•° ---
function update_rebuild_restart_systemd() {
    show_banner # Refresh banner
    echo -e "${BLUE}[*] å¼€å§‹æ›´æ–°ä»£ç ã€é‡æ–°æ„å»ºå¹¶é‡å¯ Systemd çŸ¿æœºæœåŠ¡...${RESET}"

    # Check root permissions
    if ! check_root; then
      pause_and_return
      return
    fi

    # Check if NCK_DIR exists
    if [ ! -d "$NCK_DIR" ]; then
        echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
        echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 1 è¿›è¡Œé¦–æ¬¡å®‰è£…ã€‚"
        pause_and_return
        return
    fi

    # Check if Systemd service file exists
    if [ ! -f "$SERVICE_FILE" ]; then
        echo -e "${RED}[-] Systemd æœåŠ¡æ–‡ä»¶ä¸å­˜åœ¨: $SERVICE_FILE${RESET}"
        echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 9 é…ç½® Systemd æœåŠ¡ã€‚"
        pause_and_return
        return
    fi

    # Change to NCK_DIR
    if ! cd_nck_dir; then pause_and_return; return; fi

    # Perform git pull
    echo -e "[*] æ‹‰å–æœ€æ–°ä»£ç ..."
    if ! run_with_retries "git pull"; then
        echo -e "${RED}[-] git pull å¤±è´¥ï¼Œæ— æ³•æ›´æ–°ä»£ç ã€‚${RESET}"
        echo "è¯·æ£€æŸ¥ç½‘ç»œæˆ–æ‰‹åŠ¨å¤„ç† git é—®é¢˜ã€‚"
        pause_and_return
        return
    fi
    echo -e "${GREEN}[+] ä»£ç æ›´æ–°å®Œæˆ${RESET}"

    # --- Rust ç¼–è¯‘ä¼˜åŒ– ---
    NUM_PROCESSORS=$(nproc || echo 1)
    echo -e "[*] è®¾ç½® CARGO_BUILD_JOBS=${NUM_PROCESSORS} å¯ç”¨ ${NUM_PROCESSORS} æ ¸å¿ƒå¹¶è¡Œç¼–è¯‘..."
    export CARGO_BUILD_JOBS="$NUM_PROCESSORS"
    # --------------------

    # Build the project
    if ! build_project; then
      echo -e "${RED}[-] é¡¹ç›®é‡æ–°æ„å»ºå¤±è´¥ã€‚${RESET}"
      # Unset jobs var even on failure
      unset CARGO_BUILD_JOBS
      echo -e "${YELLOW}[!] ç”±äºæ„å»ºå¤±è´¥ï¼Œæœªé‡å¯çŸ¿æœºæœåŠ¡ã€‚è¯·æ£€æŸ¥æ„å»ºé”™è¯¯å¹¶æ‰‹åŠ¨å¤„ç†ã€‚${RESET}"
      pause_and_return
      return
    fi
    echo -e "${GREEN}[+] é¡¹ç›®é‡æ–°æ„å»ºå®Œæˆã€‚${RESET}"

    # --- æ¸…é™¤ CARGO_BUILD_JOBS ç¯å¢ƒå˜é‡ ---
    unset CARGO_BUILD_JOBS
    # ------------------------------------

    echo -e "[*] åœæ­¢å½“å‰è¿è¡Œçš„ miner Systemd æœåŠ¡..."
    # Stop the service. Use || true in case it's not running, to avoid script exit.
    if ! systemctl stop nockchain-miner || true; then
        echo -e "${YELLOW}[!] è­¦å‘Š: åœæ­¢ nockchain-miner æœåŠ¡å¯èƒ½å¤±è´¥æˆ–æœåŠ¡æœªè¿è¡Œã€‚å°†ç»§ç»­å°è¯•å¯åŠ¨æ–°ç‰ˆæœ¬ã€‚${RESET}"
    else
        echo -e "${GREEN}[+] nockchain-miner æœåŠ¡å·²åœæ­¢ã€‚${RESET}"
    fi

    echo -e "[*] ç­‰å¾… 5 ç§’ä»¥ç¡®ä¿æœåŠ¡å®Œå…¨åœæ­¢..."
    sleep 5

    echo -e "[*] å¯åŠ¨æ–°æ„å»ºçš„ miner Systemd æœåŠ¡..."
    if ! systemctl start nockchain-miner; then
        echo -e "${RED}[-] é”™è¯¯: å¯åŠ¨ nockchain-miner æœåŠ¡å¤±è´¥ã€‚${RESET}"
        echo -e "${YELLOW}[!] è¯·ä½¿ç”¨ '${BOLD}sudo systemctl status nockchain-miner${RESET}${YELLOW}' å’Œé€‰é¡¹ 14 '${BOLD}sudo journalctl -u nockchain-miner -f${RESET}${YELLOW}' æ£€æŸ¥æ—¥å¿—ã€‚${RESET}"
        pause_and_return
        return
    fi
    echo -e "${GREEN}[+] nockchain-miner æœåŠ¡å·²å¯åŠ¨ã€‚${RESET}"

    echo -e "[*] æœåŠ¡çŠ¶æ€ç®€æŠ¥:"
    # Use sudo systemctl status directly, --no-pager is good.
    sudo systemctl status nockchain-miner --no-pager || { echo -e "${RED}[-] æ— æ³•è·å–æœåŠ¡çŠ¶æ€ã€‚${RESET}"; }

    echo -e "${GREEN}[+] ä»£ç æ›´æ–°ã€é‡æ–°æ„å»ºå¹¶é‡å¯æœåŠ¡æµç¨‹å®Œæˆã€‚${RESET}"
    echo -e "${YELLOW}[!] ä½¿ç”¨é€‰é¡¹ 14 æŸ¥çœ‹å®æ—¶æ—¥å¿—: ${BOLD}sudo journalctl -u nockchain-miner -f${RESET}"

    pause_and_return
}
# --- ç»“æŸæ›´æ–°ã€æ„å»ºå¹¶é‡å¯ Systemd æœåŠ¡å‡½æ•° ---

# 2) ç”Ÿæˆé’±åŒ…
function generate_wallet() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] ç”Ÿæˆé’±åŒ…...${RESET}"
  if ! cd_nck_dir; then pause_and_return; return; fi

  local wallet_exec="$NCK_DIR/target/release/nockchain-wallet"
  if [ ! -f "$wallet_exec" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $wallet_execã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹...è¯·è®°å½•ä¸‹å…¬é’¥ï¼${RESET}"
  # Execute keygen and capture output for emphasis
  output=$(eval "$wallet_exec keygen")
  if [ $? -eq 0 ]; then
      echo -e "${GREEN}$output${RESET}" # Print the successful output
      echo -e "${YELLOW}[!] é’±åŒ…ç”Ÿæˆå®Œæˆã€‚è¯·æ‰‹åŠ¨å°†ä¸Šé¢è¾“å‡ºçš„å…¬é’¥å¤åˆ¶ï¼Œå¹¶ä½¿ç”¨é€‰é¡¹ 3 å°†å…¶å†™å…¥ .env æ–‡ä»¶ä¸­çš„ MINING_PUBKEY=${RESET}"
  else
      echo -e "${RED}[-] é’±åŒ…ç”Ÿæˆå¤±è´¥ã€‚${RESET}"
      echo "$output" # Print error output if any
  fi


  pause_and_return
}

# 3) è®¾ç½® MINING_PUBKEY åˆ° .env
function set_pubkey_env() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] è®¾ç½® MINING_PUBKEY åˆ° .env...${RESET}"
  # No need to cd to NCK_DIR as we use the full path $ENV_FILE

  if [ ! -f "$ENV_FILE" ]; then
      echo -e "${RED}[-] .env æ–‡ä»¶ä¸å­˜åœ¨: $ENV_FILEã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  read -p "è¯·è¾“å…¥æ‚¨è¦æŒ–çŸ¿çš„å…¬é’¥ (MINING_PUBKEY): " pubkey
  if [ -z "$pubkey" ]; then
    echo -e "${RED}[-] å…¬é’¥ä¸èƒ½ä¸ºç©ºã€‚${RESET}"
    pause_and_return
    return
  fi

  # Use awk safely to update or add MINING_PUBKEY
  # If line exists, replace it; otherwise, add to end of file.
  # Need to handle potential quoting issues if the key contains spaces or special chars, though pubkeys usually don't.
  # Using a temporary file for atomic update
  awk -v pubkey_val="$pubkey" '
    /^MINING_PUBKEY=/ { $0="MINING_PUBKEY="pubkey_val; found=1 }
    { print }
    END { if (!found) print "MINING_PUBKEY="pubkey_val }
  ' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"

  # Check if move was successful
  if [ -f "$ENV_FILE" ]; then
    echo -e "${GREEN}[+] å·²å°† MINING_PUBKEY=${pubkey} å†™å…¥ ${ENV_FILE}${RESET}"
  else
    echo -e "${RED}[-] å†™å…¥ MINING_PUBKEY åˆ° ${ENV_FILE} å¤±è´¥ã€‚${RESET}"
  fi

  pause_and_return
}

# 4) å¯¼å‡ºé’±åŒ…å¯†é’¥
function export_keys() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯¼å‡ºé’±åŒ…å¯†é’¥...${RESET}"
  if ! cd_nck_dir; then pause_and_return; return; fi

  local wallet_exec="$NCK_DIR/target/release/nockchain-wallet"
  if [ ! -f "$wallet_exec" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $wallet_execã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨å¯¼å‡ºé’±åŒ…å¯†é’¥åˆ° ${NCK_DIR}/keys.export...${RESET}"
  if "$wallet_exec" export-keys; then
      echo -e "${GREEN}[+] å¯†é’¥å·²å¯¼å‡ºåˆ° ${NCK_DIR}/keys.export${RESET}"
      echo -e "${YELLOW}[!] è¯·å¦¥å–„ä¿ç®¡ keys.export æ–‡ä»¶ï¼å®ƒæ˜¯æ‚¨é’±åŒ…çš„å¤‡ä»½ã€‚${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å‡ºå¤±è´¥${RESET}"
  fi

  pause_and_return
}

# 5) å¯¼å…¥é’±åŒ…å¯†é’¥
function import_keys() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯¼å…¥é’±åŒ…å¯†é’¥...${RESET}"
  if ! cd_nck_dir; then pause_and_return; return; fi

  local wallet_exec="$NCK_DIR/target/release/nockchain-wallet"
  if [ ! -f "$wallet_exec" ]; then
      echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $wallet_execã€‚è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚${RESET}"
      pause_and_return
      return
  fi

  read -p "[?] è¯·è¾“å…¥å¯†é’¥æ–‡ä»¶è·¯å¾„ (é»˜è®¤: ${NCK_DIR}/keys.export): " keyfile
  keyfile=${keyfile:-"${NCK_DIR}/keys.export"}

  if [ ! -f "$keyfile" ]; then
      echo -e "${RED}[-] å¯†é’¥æ–‡ä»¶ä¸å­˜åœ¨: $keyfile${RESET}"
      pause_and_return
      return
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨ä» $keyfile å¯¼å…¥å¯†é’¥...${RESET}"
  if "$wallet_exec" import-keys --input "$keyfile"; then
      echo -e "${GREEN}[+] å¯†é’¥å·²æˆåŠŸå¯¼å…¥ã€‚${RESET}"
      echo -e "${YELLOW}[!] æ³¨æ„: å¯¼å…¥ä¼šè¦†ç›–ç°æœ‰å¯†é’¥ã€‚${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å…¥å¤±è´¥${RESET}"
      echo -e "${YELLOW}[!] è¯·æ£€æŸ¥æ–‡ä»¶å†…å®¹æˆ–æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚${RESET}"
  fi

  pause_and_return
}

# 8) é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ (ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨)
function configure_miner_script() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨...${RESET}"
  # No need to cd NCK_DIR initially, but script path is derived from it.

  if [ ! -d "$NCK_DIR" ]; then
      echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
      echo "è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1ã€‚"
      pause_and_return
      return
  fi

  # Ensure the scripts directory exists
  local scripts_dir="$NCK_DIR/scripts"
  mkdir -p "$scripts_dir" || { echo -e "${RED}[-] æ— æ³•åˆ›å»ºè„šæœ¬ç›®å½•: $scripts_dir${RESET}"; pause_and_return; return; }


  local BACKUP_SCRIPT="$MINER_SCRIPT.bak_$(date +%Y%m%d%H%M%S)"

  if [ -f "$MINER_SCRIPT" ]; then
    echo -e "[*] å¤‡ä»½åŸæœ‰è„šæœ¬åˆ° $BACKUP_SCRIPT"
    cp "$MINER_SCRIPT" "$BACKUP_SCRIPT" || { echo -e "${RED}[-] å¤‡ä»½è„šæœ¬å¤±è´¥${RESET}"; pause_and_return; return; }
  fi

  # --- åˆ›å»ºæ–°çš„è„šæœ¬å†…å®¹ ---
  # Get number of CPU cores - This value will be written into the script
  NUM_CORES=$(nproc || echo 1) # Default to 1 if nproc fails

  echo -e "[*] åˆ›å»ºæ–°çš„ $MINER_SCRIPT å†…å®¹ï¼Œå°†ä½¿ç”¨ ${NUM_CORES} ä¸ªçº¿ç¨‹..."
  # Use heredoc. Variables inside the heredoc that are prefixed with '$'
  # will be expanded by the *current shell* before the content is written to the file.
  # This is why NUM_CORES and NCK_DIR are used directly.
  # MINING_PUBKEY needs to be sourced from .env *within* the script when it runs.
  cat << EOL > "$MINER_SCRIPT"
#!/bin/bash
# This script was configured by the setup tool to use multiple CPU threads for mining.

# Define the NCK_DIR path explicitly relative to script location or use the standard path.
# This assumes the script is inside the NCK_DIR/scripts directory.
SCRIPT_DIR="\$(dirname \"\$(readlink -f \"\$0\")\")"
NCK_DIR_ACTUAL="\$(dirname \"\$SCRIPT_DIR\")" # Assuming script is in NCK_DIR/scripts

# Fallback to standard location if the above fails or script location is unusual
if [ ! -d "\$NCK_DIR_ACTUAL" ] || [ ! -f "\$NCK_DIR_ACTUAL/Cargo.toml" ]; then
    NCK_DIR_ACTUAL="${NCK_DIR}" # Use the path defined in the setup script
fi

ENV_FILE="\$NCK_DIR_ACTUAL/.env"

# Source .env file if it exists, needed for MINING_PUBKEY and other potential env vars
if [ -f "\$ENV_FILE" ]; then
  # Use 'set -a' to automatically export variables read from the file.
  # Be cautious if .env contains untrusted content.
  set -a
  source "\$ENV_FILE"
  set +a
fi

# Check if MINING_PUBKEY is set and not empty
if [ -z "\$MINING_PUBKEY" ]; then
  echo "é”™è¯¯: MINING_PUBKEY æœªåœ¨ \$ENV_FILE ä¸­è®¾ç½®æˆ–ä¸ºç©ºã€‚" >&2 # Output error to stderr
  echo "è¯·ä½¿ç”¨ setup è„šæœ¬çš„é€‰é¡¹ 3 è®¾ç½®å…¬é’¥åå†å¯åŠ¨çŸ¿æœºã€‚" >&2
  exit 1
fi

# Get number of CPU cores - This value is hardcoded during script creation by the setup tool
NUM_CORES=${NUM_CORES} # Value inserted by the setup script

# Check if the miner executable exists
MINER_EXEC="\$NCK_DIR_ACTUAL/target/release/nockchain"
if [ ! -f "\$MINER_EXEC" ]; then
    echo "é”™è¯¯: çŸ¿æœºå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: \$MINER_EXEC" >&2
    echo "è¯·å…ˆè¿è¡Œ setup è„šæœ¬çš„é€‰é¡¹ 1 æˆ– 12 è¿›è¡Œå®‰è£…å’Œæ„å»ºã€‚" >&2
    exit 1
fi

echo "å¯åŠ¨ Nockchain Miner..."
echo "é¡¹ç›®ç›®å½•: \$NCK_DIR_ACTUAL"
echo "ä½¿ç”¨å…¬é’¥: \$MINING_PUBKEY"
echo "ä½¿ç”¨çº¿ç¨‹æ•°: \$NUM_CORES"
echo "æŒ–çŸ¿æ—¥å¿—å°†è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º/æ ‡å‡†é”™è¯¯ (å¦‚æœä½¿ç”¨ Systemd æˆ– Screen ç®¡ç†ï¼Œè¯·æŸ¥çœ‹å¯¹åº”æ—¥å¿—)."

# Execute the miner with optimized parameters
# IMPORTANT: Verify '$MINER_EXEC' supports --threads parameter!
# Use exec to replace the current shell process with the miner process
exec "\$MINER_EXEC" \
    --chain nockchain_mainnet \
    --miner \
    --mining-pubkey "\$MINING_PUBKEY" \
    --threads "\$NUM_CORES" \# <-- Pass the calculated threads argument

# Note: 'exec' replaces the current shell process. Commands after it are not run
# unless the executed program fails immediately.
EOL
          # --- ç»“æŸåˆ›å»ºæ–°çš„è„šæœ¬å†…å®¹ ---

          chmod +x "$MINER_SCRIPT" || { echo -e "${RED}[-] è®¾ç½®è„šæœ¬æ‰§è¡Œæƒé™å¤±è´¥${RESET}"; pause_and_return; return; }

          echo -e "${GREEN}[+] æŒ–çŸ¿å¯åŠ¨è„šæœ¬å·²é…ç½®å®Œæˆ ($MINER_SCRIPT)ã€‚${RESET}"
          echo -e "${YELLOW}[!] é‡è¦: æ­¤é…ç½®å‡è®¾ Nockchain èŠ‚ç‚¹ç¨‹åºæ”¯æŒ '--threads' å‚æ•°ã€‚è¯·éªŒè¯ï¼${RESET}"
          echo -e "${YELLOW}[!] æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨é€‰é¡¹ 6 (Screen) æˆ–é€‰é¡¹ 9 (Systemd) å¯åŠ¨çŸ¿æœºã€‚${RESET}"
          pause_and_return
        }


# 9) é…ç½® Systemd æœåŠ¡
function setup_systemd_miner() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] é…ç½® Systemd æœåŠ¡ (æ¨èç”¨äºè‡ªåŠ¨å¯åŠ¨å’Œé‡å¯)...${RESET}"

  # Check root permissions at the very beginning
  if ! check_root; then
    pause_and_return
    return
  fi

  # Check if NCK_DIR exists
  if [ ! -d "$NCK_DIR" ]; then
      echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
      echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 1 è¿›è¡Œé¦–æ¬¡å®‰è£…ã€‚"
      pause_and_return
      return
  fi
  # Check if .env exists
  if [ ! -f "$ENV_FILE" ]; then
      echo -e "${RED}[-] .env æ–‡ä»¶ä¸å­˜åœ¨: $ENV_FILEã€‚è¯·å…ˆä½¿ç”¨é€‰é¡¹ 1 å®‰è£…æˆ–é€‰é¡¹ 3 è®¾ç½®ã€‚${RESET}"
      pause_and_return
      return
  fi
  # Check if the run script exists
  if [ ! -f "$MINER_SCRIPT" ]; then
      echo -e "${RED}[-] æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä¸å­˜åœ¨: $MINER_SCRIPT${RESET}"
      echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 8 é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ã€‚"
      pause_and_return
      return
  fi
  # Check if miner executable exists (optional but good check before setting up service)
  local miner_exec_path="$NCK_DIR/target/release/nockchain"
   if [ ! -f "$miner_exec_path" ]; then
      echo -e "${RED}[-] çŸ¿æœºå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $miner_exec_path${RESET}"
      echo "è¯·å…ˆä½¿ç”¨é€‰é¡¹ 1 æˆ– 12 è¿›è¡Œæ„å»ºã€‚"
      pause_and_return
      return
  fi


  echo -e "${YELLOW}[!] å»ºè®®æ‚¨åœ¨é…ç½® Systemd æœåŠ¡å‰ï¼Œå…ˆä½¿ç”¨é€‰é¡¹ 8 é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä»¥ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨ã€‚${RESET}"
  echo -e "${YELLOW}[!] å¹¶ä¸”ç¡®ä¿å·²ä½¿ç”¨é€‰é¡¹ 3 è®¾ç½®äº† MINING_PUBKEYã€‚${RESET}"
  read -p "æ˜¯å¦ç»§ç»­é…ç½® Systemd æœåŠ¡ ($SERVICE_FILE)? (y/n): " confirm_systemd
  if [[ ! "$confirm_systemd" =~ ^[Yy]$ ]]; then
     echo -e "${RED}[-] å·²å–æ¶ˆ Systemd é…ç½®ã€‚${RESET}"
     pause_and_return
     return
  fi

  # Get the username of the user who ran the script (important if using sudo)
  USERNAME=$(logname 2>/dev/null || whoami)
  echo -e "[*] Systemd æœåŠ¡å°†ä»¥ç”¨æˆ· '$USERNAME' èº«ä»½è¿è¡Œã€‚"

  # --- åˆ›å»º Systemd æœåŠ¡æ–‡ä»¶å†…å®¹ ---
  echo -e "[*] åˆ›å»º Systemd æœåŠ¡æ–‡ä»¶: $SERVICE_FILE"
  # Use tee with sudo to write to privileged location
  # Use variables directly as tee is redirecting the output of cat in the current shell
  cat <<EOL | sudo tee "$SERVICE_FILE" > /dev/null
[Unit]
Description=Nockchain Miner Node
After=network.target

[Service]
User=$USERNAME # ä»¥æŒ‡å®šç”¨æˆ·èº«ä»½è¿è¡Œ
WorkingDirectory=$NCK_DIR # å·¥ä½œç›®å½•ä¸ºé¡¹ç›®æ ¹ç›®å½•
EnvironmentFile=$ENV_FILE # ä» .env æ–‡ä»¶åŠ è½½ç¯å¢ƒå˜é‡ (ä¾‹å¦‚ MINING_PUBKEY)
ExecStart=$MINER_SCRIPT # æ‰§è¡Œé…ç½®å¥½çš„æŒ–çŸ¿å¯åŠ¨è„šæœ¬
Restart=always # å…³é”®: ç¨‹åºé€€å‡ºæ—¶è‡ªåŠ¨é‡å¯
RestartSec=10 # 10ç§’åå°è¯•é‡å¯

# æ¨èçš„æ–‡ä»¶æè¿°ç¬¦å’Œè¿›ç¨‹æ•°é™åˆ¶ï¼Œé¿å…èµ„æºè€—å°½
LimitNOFILE=65536
LimitNPROC=65536

# å°†æ—¥å¿—è¾“å‡ºåˆ° journald
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOL
  # --- ç»“æŸæœåŠ¡æ–‡ä»¶å†…å®¹ ---

  # Check if the file was written successfully
  if [ ! -f "$SERVICE_FILE" ]; then
    echo -e "${RED}[-] é”™è¯¯: Systemd æœåŠ¡æ–‡ä»¶åˆ›å»ºå¤±è´¥ã€‚è¯·æ£€æŸ¥æƒé™ã€‚${RESET}"
    pause_and_return
    return
  fi

  echo -e "[*] é‡è½½ Systemd ç®¡ç†å™¨é…ç½®..."
  if ! systemctl daemon-reload; then
      echo -e "${RED}[-] é‡è½½ Systemd å¤±è´¥ã€‚è¯·æ£€æŸ¥æœåŠ¡æ–‡ä»¶è¯­æ³•ã€‚${RESET}"
      pause_and_return
      return
  fi

  echo -e "[*] å¯ç”¨ nockchain-miner æœåŠ¡ (è®¾ç½®å¼€æœºè‡ªå¯)..."
  if ! systemctl enable nockchain-miner.service; then
      echo -e "${RED}[-] å¯ç”¨ Systemd æœåŠ¡å¤±è´¥${RESET}"
      echo -e "${YELLOW}[!] è¯·æ‰‹åŠ¨è¿è¡Œ 'sudo systemctl enable nockchain-miner.service' æ£€æŸ¥é”™è¯¯ã€‚${RESET}"
      pause_and_return
      return
  fi

  echo -e "${GREEN}[+] Systemd æœåŠ¡å·²é…ç½® ($SERVICE_FILE) å¹¶è®¾ä¸ºå¼€æœºè‡ªå¯ã€‚${RESET}"
  echo -e "${YELLOW}[!] æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç®¡ç†æœåŠ¡:${RESET}"
  echo -e "${YELLOW}    å¯åŠ¨çŸ¿æœº: ${BOLD}sudo systemctl start nockchain-miner${RESET}"
  echo -e "${YELLOW}    æ£€æŸ¥çŠ¶æ€: ${BOLD}sudo systemctl status nockchain-miner${RESET}"
  echo -e "${YELLOW}    æŸ¥çœ‹æ—¥å¿—: ${BOLD}sudo journalctl -u nockchain-miner -f${RESET} ${GREEN}(é€‰é¡¹ 14)${RESET}"
  echo -e "${YELLOW}    åœæ­¢çŸ¿æœº: ${BOLD}sudo systemctl stop nockchain-miner${RESET}"
  echo -e "${YELLOW}    ç¦ç”¨å¼€æœºè‡ªå¯: ${BOLD}sudo systemctl disable nockchain-miner${RESET}"

  pause_and_return
}

# 14) æŸ¥çœ‹ Systemd èŠ‚ç‚¹æ—¥å¿—
function view_logs_systemd() {
    show_banner # Refresh banner
    echo -e "${BLUE}[*] æŸ¥çœ‹ Systemd èŠ‚ç‚¹æ—¥å¿— (å®æ—¶è·Ÿè¸ª)...${RESET}"

     # Check root permissions as journalctl often requires it to view system units
    if ! check_root; then
      pause_and_return
      return
    fi

    echo -e "${YELLOW}[!] æŒ‰ Ctrl+C é€€å‡ºæ—¥å¿—è·Ÿè¸ªã€‚${RESET}"
    echo ""

    # Check if the service exists before trying to view logs
    if ! systemctl list-units --full --no-pager --all | grep -Fq "nockchain-miner.service"; then
        echo -e "${RED}[-] Systemd æœåŠ¡ 'nockchain-miner.service' ä¸å­˜åœ¨ã€‚è¯·å…ˆä½¿ç”¨é€‰é¡¹ 9 é…ç½®æœåŠ¡ã€‚${RESET}"
        pause_and_return
        return
    fi

    # -f follows the log output
    # -u specifies the unit
    # --no-pager prevents output from being piped to 'less' or 'more'
    if ! journalctl -u nockchain-miner -f --no-pager; then
        echo -e "${RED}[-] é”™è¯¯: æ— æ³•è·å– Systemd æ—¥å¿—ã€‚${RESET}"
        echo -e "${YELLOW}[!] è¯·æ£€æŸ¥æœåŠ¡çŠ¶æ€ ('sudo systemctl status nockchain-miner') æˆ– journalctl æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚${RESET}"
    fi

    pause_and_return
}

# 6) å¯åŠ¨èŠ‚ç‚¹ (Screen åå°)
function start_node_screen() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] å¯åŠ¨èŠ‚ç‚¹ (screen åå°è¿è¡Œ)...${RESET}"
  # No need to cd NCK_DIR initially

  # Check if miner executable exists
  local miner_exec_path="$NCK_DIR/target/release/nockchain"
  if [ ! -f "$miner_exec_path" ]; then
      echo -e "${RED}[-] çŸ¿æœºå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨: $miner_exec_path${RESET}"
      echo "è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1 æˆ–é€‰é¡¹ 12 è¿›è¡Œæ„å»ºã€‚"
      pause_and_return
      return
  fi

  # Ensure starting script exists and is executable
  if [ ! -f "$MINER_SCRIPT" ]; then
      echo -e "${RED}[-] é”™è¯¯: æŒ–çŸ¿å¯åŠ¨è„šæœ¬ä¸å­˜åœ¨: $MINER_SCRIPT${RESET}"
      echo "è¯·å…ˆæ‰§è¡Œå®‰è£…é€‰é¡¹ 1 æˆ–é€‰é¡¹ 8ã€‚"
      pause_and_return
      return
  fi
  if [ ! -x "$MINER_SCRIPT" ]; then
       echo -e "[*] è®¾ç½®è„šæœ¬æ‰§è¡Œæƒé™..."
       if ! chmod +x "$MINER_SCRIPT"; then
           echo -e "${RED}[-] è®¾ç½®è„šæœ¬æ‰§è¡Œæƒé™å¤±è´¥${RESET}"
           pause_and_return
           return
       fi
       echo -e "${GREEN}[+] è„šæœ¬æ‰§è¡Œæƒé™å·²è®¾ç½®ã€‚${RESET}"
  fi

  # Check if MINING_PUBKEY is set before attempting to start
  if ! check_pubkey; then
      pause_and_return
      return
  fi

  # Check and close old screen sessions
  if screen -list | grep -qw "nockchain"; then
    echo "[*] æ£€æµ‹åˆ°æ—§çš„ 'nockchain' screen ä¼šè¯ï¼Œæ­£åœ¨å°è¯•å…³é—­..."
    # Try graceful quit first
    screen -S nockchain -X quit &> /dev/null
    # Give it a moment
    sleep 2
    # Check if it's still running
    if screen -list | grep -qw "nockchain"; then
         echo -e "${YELLOW}[-] æ—§çš„ screen ä¼šè¯æœªå®Œå…¨å…³é—­ï¼Œå°è¯•å¼ºåˆ¶ç»ˆæ­¢...${RESET}"
         # Clean up dead sessions first
         screen -wipe &> /dev/null
         # Find and kill process associated with this screen name if still exists
         # Use pgrep to find the screen process ID by its command line args
         pids=$(pgrep -f "SCREEN -S nockchain")
         if [ -n "$pids" ]; then
             echo "  -> æ€æ­»è¿›ç¨‹ ID: $pids"
             kill -9 $pids 2>/dev/null || true # Use kill -9 for stubborn processes, ignore errors if already gone
         fi
         sleep 2
         if screen -list | grep -qw "nockchain"; then
             echo -e "${RED}[-] é”™è¯¯: æ— æ³•ç»ˆæ­¢æ—§çš„ screen ä¼šè¯ã€‚è¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit', 'screen -wipe', 'pkill -f \"SCREEN -S nockchain\"' å¹¶é‡è¯•ã€‚${RESET}"
             pause_and_return
             return
         else
             echo -e "${GREEN}[+] æ—§çš„ screen ä¼šè¯å·²æ¸…ç†ã€‚${RESET}"
         fi
    else
       echo -e "${GREEN}[+] æ—§çš„ screen ä¼šè¯å·²æ¸…ç†ã€‚${RESET}"
    fi
  fi

  echo -e "[*] æ­£åœ¨å¯åŠ¨æ–°çš„ 'nockchain' screen ä¼šè¯..."
  # Use screen -dmS in the background to create a session and execute the command.
  # The bash -c command will cd into NCK_DIR and then execute the miner script.
  # The miner script itself handles sourcing the .env and running the binary with exec.
  # Quote paths to handle potential spaces (unlikely but safe)
  if screen -dmS nockchain bash -c "cd \"$NCK_DIR\" && \"$MINER_SCRIPT\""; then
       echo -e "${GREEN}[+] èŠ‚ç‚¹å·²æˆåŠŸå¯åŠ¨åœ¨ 'nockchain' screen ä¼šè¯ä¸­ã€‚${RESET}"
       echo -e "${YELLOW}[!] æ‚¨å¯ä»¥ä½¿ç”¨é€‰é¡¹ 7 æŸ¥çœ‹æ—¥å¿— (æŒ‰ Ctrl+A+D åˆ†ç¦»).${RESET}"
       echo -e "${YELLOW}[!] æ³¨æ„: Screen æ–¹å¼ä¸å¦‚ Systemd (é€‰é¡¹ 9) ç¨³å®šå’ŒæŒä¹…ï¼Œä¸å…·å¤‡è‡ªåŠ¨é‡å¯åŠŸèƒ½ã€‚${RESET}"
       echo -e "${YELLOW}[!] å¼ºçƒˆæ¨èä½¿ç”¨ Systemd (é€‰é¡¹ 9 å’Œ 13) æ¥ç®¡ç†æ‚¨çš„çŸ¿æœºã€‚${RESET}"
  else
       echo -e "${RED}[-] èŠ‚ç‚¹å¯åŠ¨å¤±è´¥ã€‚è¯·æ£€æŸ¥ $MINER_SCRIPT è„šæœ¬å†…å®¹ã€æƒé™æˆ–ä¾èµ–æ˜¯å¦æ­£ç¡®ã€‚${RESET}"
       echo -e "${YELLOW}[!] æ‚¨å¯ä»¥å°è¯•ä½¿ç”¨é€‰é¡¹ 7 æŸ¥çœ‹çŸ­æš‚å¯åŠ¨åé€€å‡ºçš„ä¼šè¯æ—¥å¿—ã€‚${RESET}"
  fi
  pause_and_return
}

# 7) æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—
function view_logs_screen() {
  show_banner # Refresh banner
  echo -e "${BLUE}[*] æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—...${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] è¿æ¥åˆ° 'nockchain' screen ä¼šè¯ã€‚æŒ‰ Ctrl+A+D ç»„åˆé”®å¯åˆ†ç¦»ä¼šè¯è¿”å›è„šæœ¬èœå•ï¼Œä¸ä¼šåœæ­¢çŸ¿æœºã€‚${RESET}"
    echo -e "${YELLOW}[!] ${BOLD}è­¦å‘Š:${RESET}${YELLOW} åœ¨ screen ä¼šè¯ä¸­æŒ‰ Ctrl+C å¯èƒ½ä¼šåœæ­¢çŸ¿æœºï¼è¯·è°¨æ…æ“ä½œã€‚${RESET}"
    echo ""
    # screen -r attempts to resume a session. -d -r can detach from elsewhere and resume here.
    # Check if the session is actually attached elsewhere
    if screen -list | grep -q "nockchain[[:space:]]"; then # Check for 'nockchain' followed by space (indicating attached)
        echo -e "${YELLOW}[*] 'nockchain' screen ä¼šè¯å½“å‰å·²è¿æ¥ã€‚å°è¯•é‡æ–°è¿æ¥...${RESET}"
        screen -x nockchain # Connect to already attached session
    else
        screen -r nockchain # Resume detached session
    fi
    # User will return here after detaching from screen session (Ctrl+A+D)
    echo "" # Add a newline after returning
    echo -e "${GREEN}[+] å·²ä» screen ä¼šè¯åˆ†ç¦»ã€‚${RESET}"
  else
    echo -e "${RED}[-] æœªæ‰¾åˆ°åä¸º 'nockchain' çš„ screen ä¼šè¯ã€‚è¯·ç¡®è®¤èŠ‚ç‚¹å·²ä½¿ç”¨é€‰é¡¹ 6 å¯åŠ¨ã€‚${RESET}"
  fi
  pause_and_return
}


# ========= ä¸»èœå• =========
function main_menu() {
  show_banner
  echo "è¯·é€‰æ‹©æ“ä½œ:"
  echo "-----------------------------------------------"
  echo " ${BLUE}ğŸ“¦ å®‰è£…/æ„å»º${RESET}"
  echo "  1) ä¸€é”®å®‰è£…å¹¶æ„å»º (é¦–æ¬¡å®‰è£…æ¨è)"
  echo " ${TERMINAL_BLUE}11) å®‰è£…å¹¶é…ç½® sccache (å¯é€‰, åŠ é€Ÿåç»­ç¼–è¯‘) - å¼ºçƒˆæ¨è!${RESET}"
  echo "-----------------------------------------------"
  echo " ${BLUE}ğŸ”„ æ›´æ–°/å‡çº§ (ä»£ç ä¸ç¨‹åº)${RESET}"
  echo "  12) æ›´æ–°ä»£ç å¹¶é‡æ–°æ„å»º"
  echo "  13) æ›´æ–°ä»£ç ã€é‡æ–°æ„å»ºå¹¶é‡å¯çŸ¿æœº (Systemd) - æ¨è!"
  echo "-----------------------------------------------"
  echo " ${BLUE}ğŸ”‘ é’±åŒ…/å¯†é’¥ç®¡ç†${RESET}"
  echo "  2) ç”Ÿæˆé’±åŒ… (æŸ¥çœ‹è¾“å‡ºæ—¥å¿—)"
  echo "  3) è®¾ç½® MINING_PUBKEY åˆ° .env (æ‰‹åŠ¨è¾“å…¥) - ${BOLD}å¿…é¡»è®¾ç½®!${RESET}"
  echo "  4) å¯¼å‡ºé’±åŒ…å¯†é’¥"
  echo "  5) å¯¼å…¥é’±åŒ…å¯†é’¥"
  echo "-----------------------------------------------"
  echo " ${BLUE}âš™ï¸ çŸ¿æœºå¯åŠ¨/ç®¡ç†${RESET}"
  echo "  8) é…ç½®æŒ–çŸ¿å¯åŠ¨è„šæœ¬ (ä¼˜åŒ–çº¿ç¨‹åˆ©ç”¨, æ¨è!)"
  echo "  9) é…ç½® Systemd æœåŠ¡ (æ¨è! å®ç°è‡ªåŠ¨å¯åŠ¨/é‡å¯)"
  echo "  6) å¯åŠ¨èŠ‚ç‚¹ (Screen åå°è¿è¡Œ, åŸºæœ¬æ–¹å¼)"
  echo "  7) æŸ¥çœ‹ Screen èŠ‚ç‚¹æ—¥å¿—"
  echo " ${TERMINAL_BLUE}14) æŸ¥çœ‹ Systemd èŠ‚ç‚¹æ—¥å¿— (å®æ—¶è·Ÿè¸ª) - æ¨è!${RESET}"
  echo "-----------------------------------------------"
  echo "  0) é€€å‡º"
  echo ""
  read -p "è¯·è¾“å…¥ç¼–å·: " choice

  case "$choice" in
    1) setup_all ;;
    11) setup_sccache ;;
    12) update_and_rebuild ;;
    13) update_rebuild_restart_systemd ;;
    2) generate_wallet ;;
    3) set_pubkey_env ;;
    4) export_keys ;;
    5) import_keys ;;
    8) configure_miner_script ;;
    9) setup_systemd_miner ;;
    6) start_node_screen ;;
    7) view_logs_screen ;;
    14) view_logs_systemd ;; # New option for Systemd logs
    0) echo -e "${GREEN}é€€å‡ºè„šæœ¬.${RESET}"; exit 0 ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

# ========= è„šæœ¬å…¥å£ =========
# åœ¨å¯åŠ¨ä¸»èœå•å‰åˆ·æ–°ä¸€æ¬¡æ¨ªå¹…
show_banner

# è¿è¡Œä¸»èœå•
main_menu
