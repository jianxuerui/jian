#!/bin/bash
# Nockchain 编排器 v5.1.2 "普罗米修斯" (中文交互版 / 功能增强)
#
# 更新日志:
# v5.1.2: 新增完整的节点管理功能 (启动/停止/重启/状态)，智能适配 systemd 与 screen。
#         新增添加挖矿/验证者公钥功能。优化主菜单结构。
# v5.1.1: 修正了 pkg_map 关联数组的 Bash 语法错误。
#
set -euo pipefail

# --- 脚本元数据 ---
SCRIPT_VERSION="5.1.2"

# --- 配置与日志 ---
CONFIG_FILE="/etc/nockchain/nockchain.conf"
BUILD_DIR="${HOME}/.nockchain_build"
LOG_FILE="$BUILD_DIR/nockchain-orchestrator.log"
ERROR_LOG="$BUILD_DIR/nockchain-error.log"

# --- 设置日志记录 ---
mkdir -p "$BUILD_DIR"
exec 3>&1
exec > >(tee -a "$LOG_FILE") 2> >(tee -a "$ERROR_LOG" >&2)

# --- 工具与颜色函数 ---
green='\e[32m'; blue='\e[34m'; red='\e[31m'; yellow='\e[33m'; reset='\e[0m'
ColorGreen(){ echo -ne "${green}$1${reset}"; }
ColorBlue() { echo -ne "${blue}$1${reset}"; }
ColorRed()  { echo -ne "${red}$1${reset}"; }
ColorYellow(){ echo -ne "${yellow}$1${reset}"; }

log_info() { echo -e "[$(date '+%F %T')] $(ColorGreen '[信息]') $1" | tee -a /dev/fd/3; }
log_warn() { echo -e "[$(date '+%F %T')] $(ColorYellow '[警告]') $1" | tee -a /dev/fd/3; }
log_error() { echo -e "[$(date '+%F %T')] $(ColorRed '[错误]') $1" | tee -a /dev/fd/3 >&2; }

handle_error() {
    local exit_code=$1 line_no=$2
    log_error "在脚本第 $line_no 行发生致命错误，退出码 $exit_code."
    ColorRed "\n部署失败！详情请见日志: $LOG_FILE 和 $ERROR_LOG\n" >&2
    exit "$exit_code"
}
trap 'handle_error $? $LINENO' ERR

# --- 兼容性核心函数 ---
# ... [detect_distro, install_dependencies, setup_compiler_env, robust_clone 函数与上一版相同] ...
detect_distro() {
    if [ -f /etc/os-release ]; then . /etc/os-release; DISTRO=${ID,,}; VER=${VERSION_ID%%.*};
    elif type lsb_release >/dev/null 2>&1; then DISTRO=$(lsb_release -si | tr '[:upper:]' '[:lower:]'); VER=$(lsb_release -sr | cut -d. -f1);
    else DISTRO=$( ( lsb_release -is || cat /etc/issue || cat /etc/redhat-release || cat /etc/lsb-release || uname -s ) 2>/dev/null | head -n1 | awk '{print $1}' | tr '[:upper:]' '[:lower:]' ); VER=$( ( lsb_release -rs || cat /etc/issue || cat /etc/redhat-release || cat /etc/lsb-release || uname -r ) 2>/dev/null | head -n1 | grep -oE '[0-9]+' | head -n1); fi
    log_info "检测到系统发行版: $DISTRO, 版本: $VER"
}

install_dependencies() {
    log_info "正在为 $DISTRO 系统解析并安装依赖..."
    local pkg_manager=""; if command -v apt-get &>/dev/null; then pkg_manager="apt"; elif command -v dnf &>/dev/null; then pkg_manager="dnf"; elif command -v yum &>/dev/null; then pkg_manager="yum"; else log_error "不支持的包管理器。" && exit 1; fi
    declare -A pkg_map=( [build_essentials]="build-essential gcc-c++ make" [clang]="clang-15 clang" [llvm_dev]="llvm-15-dev llvm-devel" [cmake]="cmake cmake" [openssl_dev]="libssl-dev openssl-devel" [pkg_config]="pkg-config pkgconfig" [uuid_dev]="uuid-dev libuuid-devel" [git]="git git" [utils]="screen htop jq curl unzip tor fail2ban" [time_sync]="ntpdate chrony" [python_venv]="python3-venv python3-devel" )
    local packages_to_install=(); for generic_name in "${!pkg_map[@]}"; do local pkg_string; case $DISTRO in ubuntu|debian) pkg_string=$(echo "${pkg_map[$generic_name]}" | cut -d' ' -f1);; centos|rhel|alma|rocky|fedora) pkg_string=$(echo "${pkg_map[$generic_name]}" | cut -d' ' -f2-);; *) log_error "无法为发行版 $DISTRO 确定软件包。" && exit 1 ;; esac; if [[ -n "$pkg_string" ]]; then packages_to_install+=($pkg_string); fi; done
    case $pkg_manager in apt) sudo apt-get update; sudo apt-get install -y software-properties-common wget; wget -qO- https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -; sudo add-apt-repository -y "deb http://apt.llvm.org/$(lsb_release -sc)/ llvm-toolchain-$(lsb_release -sc)-15 main"; sudo apt-get update; sudo apt-get install -y --no-install-recommends "${packages_to_install[@]}";; dnf|yum) sudo "$pkg_manager" install -y epel-release; local builder_repo_id=$(sudo "$pkg_manager" repolist all | grep -i -E 'powertools|crb|codeready|builder' | awk '{print $1}' | head -n 1); if [[ -n "$builder_repo_id" ]]; then sudo "$pkg_manager" config-manager --set-enabled "$builder_repo_id"; else log_warn "未找到开发工具仓库 (powertools/crb)，部分软件包可能安装失败。"; fi; sudo "$pkg_manager" install -y "${packages_to_install[@]}";; esac
    log_info "依赖项安装成功。"
}

setup_compiler_env() { log_info "正在探测并设置编译器环境..."; COMPILER_ENV_CMD=""; if [ -d /opt/rh ]; then local scl_enable_path=$(find /opt/rh -type f -path "*/gcc-toolset-*/enable" | sort -V | tail -n 1); if [ -n "$scl_enable_path" ]; then log_info "检测到 SCL 环境: $scl_enable_path。将在编译和运行时加载。"; COMPILER_ENV_CMD="source $scl_enable_path && "; return; fi; fi; export CC=$(command -v clang-15 || command -v clang || echo "gcc"); export CXX=$(command -v clang++-15 || command -v clang++ || echo "g++"); log_info "将使用 CC=$CC 和 CXX=$CXX 进行编译。"; }
robust_clone() { local repo_url=$1; local dest_dir=$2; local base_repo=$(echo "$repo_url" | sed -e 's/https:\/\///' -e 's/http:\/\///'); declare -a mirrors=("https://kgithub.com" "https://ghproxy.com" "https://hub.fale.io" "https://github.com"); log_info "正在克隆 $base_repo ..."; for mirror in "${mirrors[@]}"; do local url="$mirror/$base_repo"; log_info "正在尝试从 $url 克隆..."; if git clone --depth 1 "$url" "$dest_dir"; then log_info "从 $mirror 克隆成功。"; return 0; fi; log_warn "从 $mirror 克隆失败。正在尝试下一个镜像..."; rm -rf "$dest_dir"; done; log_error "从所有可用镜像克隆仓库均失败。"; exit 1; }

# --- 安装与管理核心逻辑 ---

install_nockchain_node() {
    # ... 函数内容与上一版相同 ...
    log_info "Nockchain 套件安装成功。"
}

setup_daemon() {
    # ... 函数内容与上一版相同 ...
    log_info "守护进程配置完成。"
}

# --- 新增功能：节点管理 ---
manage_node() {
    PS3="$(ColorYellow '请选择节点操作: ')"
    select action in "启动节点" "停止节点" "重启节点" "查看状态" "返回主菜单"; do
        case $action in
            "启动节点")
                log_info "正在尝试启动 Nockchain 节点..."
                if command -v systemctl &>/dev/null && [ -f /etc/systemd/system/nockchain-node.service ]; then
                    sudo systemctl start nockchain-node.service
                elif [ -f /usr/local/bin/start-nockchain.sh ]; then
                    if ! screen -list | grep -q "nockchain"; then
                        sudo /usr/local/bin/start-nockchain.sh
                    else
                        log_warn "节点已经在 screen 会话中运行。"
                    fi
                else
                    log_error "未找到 systemd 服务或启动脚本，无法启动。"
                fi
                break
                ;;
            "停止节点")
                log_info "正在尝试停止 Nockchain 节点..."
                if command -v systemctl &>/dev/null && [ -f /etc/systemd/system/nockchain-node.service ]; then
                    sudo systemctl stop nockchain-node.service
                elif screen -list | grep -q "nockchain"; then
                    screen -S nockchain -X quit
                    log_info "已向 screen 会话发送停止命令。"
                else
                    log_error "未找到正在运行的节点服务或 screen 会话。"
                fi
                break
                ;;
            "重启节点")
                log_info "正在尝试重启 Nockchain 节点..."
                if command -v systemctl &>/dev/null && [ -f /etc/systemd/system/nockchain-node.service ]; then
                    sudo systemctl restart nockchain-node.service
                else
                    # 先停止
                    if screen -list | grep -q "nockchain"; then
                        screen -S nockchain -X quit
                        sleep 2
                    fi
                    # 再启动
                    if [ -f /usr/local/bin/start-nockchain.sh ]; then
                        sudo /usr/local/bin/start-nockchain.sh
                    else
                         log_error "未找到启动脚本，无法重启。"
                    fi
                fi
                break
                ;;
            "查看状态")
                log_info "检查 Nockchain 节点状态..."
                if command -v systemctl &>/dev/null && [ -f /etc/systemd/system/nockchain-node.service ]; then
                    sudo systemctl status nockchain-node.service
                elif screen -list | grep -q "nockchain"; then
                    log_info "$(ColorGreen '节点正在 screen 会话中运行。')"
                    echo "使用 'screen -r nockchain' 查看详情。"
                else
                    log_info "$(ColorRed '节点当前已停止。')"
                fi
                break
                ;;
            "返回主菜单")
                break
                ;;
            *) echo "无效选项 $REPLY";;
        esac
    done
}

# --- 新增功能：添加挖矿公钥 ---
add_mining_key() {
    # 假设 CONFIG 数组已通过配置文件加载
    local nock_user=${CONFIG[USER]:-"nockchain"}
    local data_dir=${CONFIG[DATA_DIR]:-"/var/lib/nockchain"}

    log_info "即将为用户 '$nock_user' 添加挖矿/验证者公钥..."
    read -p "请输入公钥的 URL 或本地文件路径: " key_src
    
    local ssh_dir="$data_dir/.ssh"
    log_info "将在 '$ssh_dir' 目录配置 authorized_keys..."
    
    sudo mkdir -p "$ssh_dir"
    sudo chown "$nock_user":"$nock_user" "$ssh_dir"
    sudo chmod 700 "$ssh_dir"
    
    local tmp_key_file="/tmp/nockchain_miner_key.pub"
    
    if [[ $key_src =~ ^https?:// ]]; then
        if ! curl -fsSL "$key_src" -o "$tmp_key_file"; then
            log_error "从 URL 下载公钥失败！请检查链接是否正确。"
            return 1
        fi
        log_info "已从 URL 下载公钥。"
    elif [ -f "$key_src" ]; then
        cp "$key_src" "$tmp_key_file"
        log_info "已从本地文件复制公钥。"
    else
        log_error "错误：提供的路径 '$key_src' 不是一个有效的 URL 或本地文件。"
        return 1
    fi
    
    sudo cat "$tmp_key_file" >> "$ssh_dir/authorized_keys"
    sudo chown "$nock_user":"$nock_user" "$ssh_dir/authorized_keys"
    sudo chmod 600 "$ssh_dir/authorized_keys"
    sudo rm -f "$tmp_key_file"
    
    log_info "$(ColorGreen '公钥已成功添加！')"
}


# --- 中文交互菜单 (已更新) ---
show_banner() {
    ColorBlue '
    _   __         _                    _           _             
   / | / /  ___   | | __   ___    ___  | |_   _ __ (_)  ___   ___ 
  /  |/ /  / _ \  | |/ /  / _ \  / __| | __| |  __| | |/ __| / __|
 / /|  /  | (_) | |   <  | (_) | \__ \ | |_  | |    | | (__  \__ \
/_/ |_/    \___/  |_|\_\  \___/  |___/  \__| |_|    |_| \___| |___/
           编排器 v5.1.2 "普罗米修斯" (中文版)
'
}

full_installation_menu() {
    # ... 与上一版相同 ...
}

advanced_operations_menu() {
    PS3="$(ColorYellow '请选择高级操作: ')"
    select task in "添加挖矿/验证者公钥" "备份节点" "升级节点" "从备份恢复" "返回主菜单"; do
        case $task in
            "添加挖矿/验证者公钥") add_mining_key; break;;
            "备份节点") log_info "执行备份..."; break;;
            "升级节点") log_info "执行升级..."; break;;
            "从备份恢复") log_info "执行恢复..."; break;;
            "返回主菜单") break;;
        esac
    done
}

main_menu() {
    clear
    show_banner
    local status
    if command -v systemctl &>/dev/null && systemctl is-active nockchain-node.service &>/dev/null; then
        status="$(ColorGreen '运行中')"
    elif screen -list | grep -q "nockchain"; then
        status="$(ColorGreen '运行中 (Screen)')"
    else
        status="$(ColorRed '已停止')"
    fi
    echo -e "节点状态: $status\n"
    
    PS3="$(ColorBlue '请输入您的选择 [1-7]: ')"
    COLUMNS=12
    select opt in \
        "安装与组件管理" \
        "节点管理 (启动/停止/状态)" \
        "高级操作 (公钥/备份/升级)" \
        "安全中心 (防火墙/Fail2ban)" \
        "运行 AI 运维协处理器" \
        "查看实时日志" \
        "彻底卸载" \
        "退出脚本"; do
        case $opt in
            "安装与组件管理") full_installation_menu ;;
            "节点管理 (启动/停止/状态)") manage_node ;;
            "高级操作 (公钥/备份/升级)") advanced_operations_menu ;;
            "安全中心 (防火墙/Fail2ban)") log_info "进入安全中心...";;
            "运行 AI 运维协处理器") log_info "运行 AI 协处理器...";;
            "查看实时日志") 
                if command -v systemctl &>/dev/null && systemctl is-active nockchain-node.service &>/dev/null 2>&1; then
                    sudo journalctl -u nockchain-node -n 100 -f
                else
                    log_warn "非 systemd 系统，请使用 'screen -r nockchain' 查看日志。"
                fi
                ;;
            "彻底卸载") log_info "执行卸载...";;
            "退出脚本") exit 0 ;;
            *) echo "无效选项 $REPLY" ;;
        esac
        read -p $'\n按回车键返回主菜单...'
        main_menu
    done
}

# --- 脚本入口 ---

# (已禁用 root 检查)
for cmd in git curl jq unzip; do
    if ! command -v $cmd &> /dev/null; then
        log_error "必需命令 '$cmd' 未找到。请先安装它。"
        exit 1
    fi
done

# --- 执行开始 ---
# load_or_create_config # 配置文件加载逻辑需要被实现或调用
detect_distro
setup_compiler_env
main_menu
