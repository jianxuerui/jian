#!/bin/bash

# ========= è‰²å½©å®šä¹‰ =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'

# ========= é¡¹ç›®è·¯å¾„ =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
BACKUP_DIR="$HOME/nockchain_backups"
LOG_FILE="$NCK_DIR/nockchain.log"

# ========= ç³»ç»Ÿå…¼å®¹æ€§æ£€æµ‹ =========
function detect_system() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if [ -f /etc/debian_version ]; then
      SYSTEM="debian"
      PKG_MANAGER="apt"
    elif [ -f /etc/redhat-release ]; then
      SYSTEM="redhat"
      PKG_MANAGER="yum"
    else
      SYSTEM="linux"
      PKG_MANAGER="apt"
    fi
  else
    echo -e "${RED}[-] ä¸æ”¯æŒçš„æ“ä½œç³»ç»Ÿ: $OSTYPE${RESET}"
    exit 1
  fi
}

# ========= æ¨ªå¹… =========
function show_banner() {
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "      Nockchain é«˜çº§ç®¡ç†åŠ©æ‰‹ v2.0"
  echo "      Advanced Setup & Management Tool"
  echo "==============================================="
  echo -e "${RESET}"
  echo "ğŸ“Œ ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº«"
  echo "ğŸ”— Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "ğŸ¦ Twitter:  https://x.com/BtcK241918"
  echo "ğŸ’» å¢å¼ºç‰ˆæœ¬: å²è¯—çº§åŠŸèƒ½é›†æˆ"
  echo "-----------------------------------------------"
  echo ""
}

function cd_nck_dir() {
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR" || exit 1
  else
    echo -e "${RED}[-] é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
    exit 1
  fi
}

# ========= ä¾èµ–æ£€æŸ¥å¢å¼º =========
function check_dependencies() {
  echo -e "${BLUE}[*] æ£€æŸ¥ç³»ç»Ÿä¾èµ–...${RESET}"
  
  local missing_deps=()
  local deps=("curl" "git" "make" "gcc" "cmake")
  
  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      missing_deps+=("$dep")
    fi
  done
  
  if [ ${#missing_deps[@]} -ne 0 ]; then
    echo -e "${YELLOW}[!] ç¼ºå°‘ä¾èµ–: ${missing_deps[*]}${RESET}"
    return 1
  else
    echo -e "${GREEN}[+] æ‰€æœ‰ä¾èµ–å·²æ»¡è¶³${RESET}"
    return 0
  fi
}

function check_rust_installation() {
  echo -e "${BLUE}[*] æ£€æŸ¥ Rust å®‰è£…...${RESET}"
  
  if command -v cargo &>/dev/null; then
    local rust_version=$(rustc --version 2>/dev/null || echo "æœªçŸ¥")
    echo -e "${GREEN}[+] Rust å·²å®‰è£…: $rust_version${RESET}"
    return 0
  else
    echo -e "${YELLOW}[!] Rust æœªå®‰è£…${RESET}"
    return 1
  fi
}

function check_disk_space() {
  local available_gb=$(df "$HOME" | awk 'NR==2 {printf "%.1f", $4/1024/1024}')
  local required_gb=10
  
  if (( $(echo "$available_gb > $required_gb" | bc -l) )); then
    echo -e "${GREEN}[+] ç£ç›˜ç©ºé—´å……è¶³: ${available_gb}GB å¯ç”¨${RESET}"
    return 0
  else
    echo -e "${RED}[-] ç£ç›˜ç©ºé—´ä¸è¶³: éœ€è¦è‡³å°‘ ${required_gb}GBï¼Œå½“å‰å¯ç”¨ ${available_gb}GB${RESET}"
    return 1
  fi
}

function check_memory_usage() {
  local mem_usage=$(free | awk '/^Mem:/ {printf "%.1f", ($3/$2)*100}')
  local mem_available=$(free -h | awk '/^Mem:/ {print $7}')
  
  echo "å†…å­˜ä½¿ç”¨ç‡: ${mem_usage}% (å¯ç”¨: ${mem_available})"
  
  if (( $(echo "$mem_usage > 90" | bc -l) )); then
    echo -e "${YELLOW}[!] å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${mem_usage}%${RESET}"
    return 1
  else
    echo -e "${GREEN}[+] å†…å­˜ä½¿ç”¨æ­£å¸¸${RESET}"
    return 0
  fi
}

function check_port_conflicts() {
  local ports=("8545" "30303")
  local conflicts=()
  
  for port in "${ports[@]}"; do
    if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
      conflicts+=("$port")
    fi
  done
  
  if [ ${#conflicts[@]} -ne 0 ]; then
    echo -e "${YELLOW}[!] ç«¯å£å†²çª: ${conflicts[*]}${RESET}"
    return 1
  else
    echo -e "${GREEN}[+] ç«¯å£å¯ç”¨${RESET}"
    return 0
  fi
}

# ========= ç³»ç»Ÿç›‘æ§æ¨¡å— =========
function system_health_check() {
  echo -e "${CYAN}========== ç³»ç»Ÿå¥åº·æ£€æŸ¥ ==========${RESET}"
  
  echo -e "${BOLD}ç³»ç»Ÿä¿¡æ¯:${RESET}"
  echo "ä¸»æœºå: $(hostname)"
  echo "å†…æ ¸: $(uname -r)"
  echo "å‘è¡Œç‰ˆ: $(lsb_release -d 2>/dev/null | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
  
  # CPUä¿¡æ¯ï¼ˆå…¼å®¹æ€§å¤„ç†ï¼‰
  if command -v lscpu &>/dev/null; then
    echo "CPU: $(lscpu | grep 'Model name' | awk -F: '{print $2}' | xargs)"
  else
    echo "CPU: $(cat /proc/cpuinfo | grep 'model name' | head -1 | awk -F: '{print $2}' | xargs)"
  fi
  
  echo "å†…å­˜: $(free -h | awk '/^Mem:/ {printf "%s / %s (%.1f%%)", $3, $2, ($3/$2)*100}')"
  echo "ç£ç›˜: $(df -h / | awk '/^\// {printf "%s / %s (%s)", $3, $2, $5}')"
  echo "è´Ÿè½½: $(uptime | awk -F'load average:' '{print $2}')"
  
  echo -e "\n${BOLD}æœåŠ¡çŠ¶æ€:${RESET}"
  check_node_status
  check_dependencies
  check_disk_space
  check_memory_usage
  check_port_conflicts
}

function check_node_status() {
  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] èŠ‚ç‚¹æœåŠ¡: è¿è¡Œä¸­${RESET}"
    
    # æ£€æŸ¥è¿›ç¨‹è¯¦æƒ…
    local pid=$(screen -list | grep nockchain | awk '{print $1}' | cut -d. -f1)
    if [ -n "$pid" ]; then
      local mem_usage=$(ps -p "$pid" -o %mem --no-headers 2>/dev/null | xargs)
      local cpu_usage=$(ps -p "$pid" -o %cpu --no-headers 2>/dev/null | xargs)
      echo "  è¿›ç¨‹ID: $pid, CPU: ${cpu_usage}%, å†…å­˜: ${mem_usage}%"
    fi
  else
    echo -e "${RED}[-] èŠ‚ç‚¹æœåŠ¡: æœªè¿è¡Œ${RESET}"
  fi
}

function performance_dashboard() {
  echo -e "${CYAN}[*] å¯åŠ¨å®æ—¶æ€§èƒ½ç›‘æ§ (æŒ‰ Ctrl+C é€€å‡º)...${RESET}"
  
  trap 'echo -e "\n${YELLOW}[!] é€€å‡ºç›‘æ§${RESET}"; return' INT
  
  while true; do
    clear
    show_banner
    echo -e "${CYAN}========== å®æ—¶æ€§èƒ½ç›‘æ§ ==========${RESET}"
    echo "åˆ·æ–°æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "è¿è¡Œæ—¶é—´: $(uptime | awk '{print $3,$4}' | sed 's/,//')"
    
    # CPUä¿¡æ¯
    if command -v top &>/dev/null; then
      local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//' 2>/dev/null || echo "N/A")
      echo "CPUä½¿ç”¨: $cpu_usage"
    fi
    
    # å†…å­˜ä¿¡æ¯
    echo "å†…å­˜ä½¿ç”¨: $(free | awk '/^Mem:/ {printf "%.1f%% (%s/%s)", ($3/$2)*100, $3, $2}')"
    
    # ç£ç›˜IOï¼ˆå…¼å®¹æ€§å¤„ç†ï¼‰
    if command -v iostat &>/dev/null; then
      echo "ç£ç›˜I/O: $(iostat -d 1 1 2>/dev/null | tail -1 | awk '{print "è¯»:"$3"KB/s å†™:"$4"KB/s"}' || echo "N/A")"
    else
      echo "ç£ç›˜I/O: éœ€è¦å®‰è£… sysstat åŒ…"
    fi
    
    # ç½‘ç»œè¿æ¥
    local connections=$(netstat -an 2>/dev/null | grep ESTABLISHED | wc -l || echo "0")
    echo "ç½‘ç»œè¿æ¥: $connections ä¸ªæ´»è·ƒè¿æ¥"
    
    # èŠ‚ç‚¹çŠ¶æ€
    if screen -list | grep -qw "nockchain"; then
      echo -e "èŠ‚ç‚¹çŠ¶æ€: ${GREEN}è¿è¡Œä¸­${RESET}"
    else
      echo -e "èŠ‚ç‚¹çŠ¶æ€: ${RED}å·²åœæ­¢${RESET}"
    fi
    
    echo ""
    echo "ä¸‹æ¬¡åˆ·æ–°: 5ç§’å..."
    sleep 5
  done
}

# ========= æ—¥å¿—åˆ†æå·¥å…· =========
function advanced_log_analysis() {
  echo -e "${CYAN}========== é«˜çº§æ—¥å¿—åˆ†æ ==========${RESET}"
  
  if [ ! -f "$LOG_FILE" ]; then
    echo -e "${YELLOW}[!] æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°è¯•æŸ¥æ‰¾å…¶ä»–æ—¥å¿—...${RESET}"
    
    # å°è¯•åœ¨screenä¼šè¯ä¸­æŸ¥æ‰¾æ—¥å¿—
    if screen -list | grep -qw "nockchain"; then
      echo "æ£€æµ‹åˆ°è¿è¡Œä¸­çš„èŠ‚ç‚¹ï¼Œæ—¥å¿—å¯èƒ½åœ¨screenä¼šè¯ä¸­"
    fi
    pause_and_return
    return
  fi
  
  echo -e "${BOLD}æ—¥å¿—æ–‡ä»¶ä¿¡æ¯:${RESET}"
  echo "æ–‡ä»¶å¤§å°: $(du -h "$LOG_FILE" | cut -f1)"
  echo "æœ€åä¿®æ”¹: $(stat -c %y "$LOG_FILE" 2>/dev/null || stat -f %Sm "$LOG_FILE")"
  echo ""
  
  echo -e "${BOLD}é”™è¯¯ç»Ÿè®¡ (æœ€è¿‘10æ¡):${RESET}"
  grep -i "error\|fail\|panic\|fatal" "$LOG_FILE" 2>/dev/null | tail -10 || echo "æœªå‘ç°é”™è¯¯"
  echo ""
  
  echo -e "${BOLD}è­¦å‘Šç»Ÿè®¡:${RESET}"
  local warning_count=$(grep -ic "warn" "$LOG_FILE" 2>/dev/null || echo "0")
  echo "è­¦å‘Šæ€»æ•°: $warning_count"
  echo ""
  
  echo -e "${BOLD}è¿æ¥ç»Ÿè®¡:${RESET}"
  local peer_connections=$(grep -c "peer\|connection" "$LOG_FILE" 2>/dev/null || echo "0")
  echo "è¿æ¥äº‹ä»¶: $peer_connections æ¬¡"
  echo ""
  
  echo -e "${BOLD}æœ€è¿‘æ´»åŠ¨ (æœ€å20è¡Œ):${RESET}"
  tail -20 "$LOG_FILE" 2>/dev/null || echo "æ— æ³•è¯»å–æ—¥å¿—"
  
  pause_and_return
}

function log_rotation() {
  echo -e "${BLUE}[*] æ‰§è¡Œæ—¥å¿—è½®è½¬...${RESET}"
  
  if [ ! -f "$LOG_FILE" ]; then
    echo -e "${YELLOW}[!] æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨${RESET}"
    return
  fi
  
  # æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ100MB = 104857600 bytesï¼‰
  local file_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo "0")
  
  if [ "$file_size" -gt 104857600 ]; then
    echo "æ—¥å¿—æ–‡ä»¶è¿‡å¤§ ($(($file_size/1024/1024))MB)ï¼Œæ‰§è¡Œè½®è½¬..."
    
    # å¤‡ä»½å½“å‰æ—¥å¿—
    mv "$LOG_FILE" "${LOG_FILE}.$(date +%Y%m%d_%H%M%S)"
    
    # å‹ç¼©æ—§æ—¥å¿—
    gzip "${LOG_FILE}.$(date +%Y%m%d_%H%M%S)" &
    
    # åˆ›å»ºæ–°æ—¥å¿—æ–‡ä»¶
    touch "$LOG_FILE"
    
    echo -e "${GREEN}[+] æ—¥å¿—è½®è½¬å®Œæˆ${RESET}"
  else
    echo -e "${GREEN}[+] æ—¥å¿—æ–‡ä»¶å¤§å°æ­£å¸¸ ($(($file_size/1024/1024))MB)${RESET}"
  fi
}

# ========= å¤‡ä»½ä¸æ¢å¤ç³»ç»Ÿ =========
function backup_management() {
  echo -e "${CYAN}========== å¤‡ä»½ç®¡ç† ==========${RESET}"
  echo "1) åˆ›å»ºå®Œæ•´å¤‡ä»½"
  echo "2) åˆ›å»ºé…ç½®å¤‡ä»½"
  echo "3) åˆ—å‡ºå¤‡ä»½æ–‡ä»¶"
  echo "4) æ¢å¤å¤‡ä»½"
  echo "5) è®¾ç½®è‡ªåŠ¨å¤‡ä»½"
  echo "6) æ¸…ç†æ—§å¤‡ä»½"
  echo "0) è¿”å›ä¸»èœå•"
  echo ""
  read -p "è¯·é€‰æ‹©: " backup_choice
  
  case "$backup_choice" in
    1) create_full_backup ;;
    2) create_config_backup ;;
    3) list_backups ;;
    4) restore_backup ;;
    5) setup_auto_backup ;;
    6) cleanup_old_backups ;;
    0) main_menu ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function create_full_backup() {
  echo -e "${BLUE}[*] åˆ›å»ºå®Œæ•´å¤‡ä»½...${RESET}"
  
  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="$BACKUP_DIR/full_backup_$timestamp"
  
  mkdir -p "$backup_path"
  
  # å¤‡ä»½é¡¹ç›®ç›®å½•
  if [ -d "$NCK_DIR" ]; then
    echo "å¤‡ä»½é¡¹ç›®æ–‡ä»¶..."
    cp -r "$NCK_DIR" "$backup_path/nockchain" 2>/dev/null || true
  fi
  
  # å¤‡ä»½é’±åŒ…æ•°æ®
  if [ -d "$HOME/.nockchain" ]; then
    echo "å¤‡ä»½é’±åŒ…æ•°æ®..."
    cp -r "$HOME/.nockchain" "$backup_path/wallet_data" 2>/dev/null || true
  fi
  
  # åˆ›å»ºå¤‡ä»½ä¿¡æ¯æ–‡ä»¶
  cat > "$backup_path/backup_info.txt" << EOF
å¤‡ä»½ç±»å‹: å®Œæ•´å¤‡ä»½
å¤‡ä»½æ—¶é—´: $(date)
èŠ‚ç‚¹ç‰ˆæœ¬: $(cd "$NCK_DIR" && git rev-parse HEAD 2>/dev/null || echo "æœªçŸ¥")
ç³»ç»Ÿä¿¡æ¯: $(uname -a)
å¤‡ä»½å¤§å°: $(du -sh "$backup_path" | cut -f1)
EOF
  
  # å‹ç¼©å¤‡ä»½
  echo "å‹ç¼©å¤‡ä»½æ–‡ä»¶..."
  tar -czf "${backup_path}.tar.gz" -C "$BACKUP_DIR" "$(basename "$backup_path")" 2>/dev/null
  rm -rf "$backup_path"
  
  if [ -f "${backup_path}.tar.gz" ]; then
    echo -e "${GREEN}[+] å®Œæ•´å¤‡ä»½å·²åˆ›å»º: ${backup_path}.tar.gz${RESET}"
    echo "å¤‡ä»½å¤§å°: $(du -sh "${backup_path}.tar.gz" | cut -f1)"
  else
    echo -e "${RED}[-] å¤‡ä»½åˆ›å»ºå¤±è´¥${RESET}"
  fi
  
  pause_and_return
}

function create_config_backup() {
  echo -e "${BLUE}[*] åˆ›å»ºé…ç½®å¤‡ä»½...${RESET}"
  
  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="$BACKUP_DIR/config_backup_$timestamp"
  
  mkdir -p "$backup_path"
  
  # å¤‡ä»½é…ç½®æ–‡ä»¶
  [ -f "$ENV_FILE" ] && cp "$ENV_FILE" "$backup_path/"
  [ -f "$NCK_DIR/Cargo.toml" ] && cp "$NCK_DIR/Cargo.toml" "$backup_path/"
  
  # åˆ›å»ºå¤‡ä»½æ¸…å•
  cat > "$backup_path/backup_info.txt" << EOF
å¤‡ä»½ç±»å‹: é…ç½®å¤‡ä»½
å¤‡ä»½æ—¶é—´: $(date)
åŒ…å«æ–‡ä»¶: .env, Cargo.toml
EOF
  
  tar -czf "${backup_path}.tar.gz" -C "$BACKUP_DIR" "$(basename "$backup_path")"
  rm -rf "$backup_path"
  
  echo -e "${GREEN}[+] é…ç½®å¤‡ä»½å·²åˆ›å»º: ${backup_path}.tar.gz${RESET}"
  pause_and_return
}

function list_backups() {
  echo -e "${CYAN}========== å¤‡ä»½åˆ—è¡¨ ==========${RESET}"
  
  if [ ! -d "$BACKUP_DIR" ]; then
    echo -e "${YELLOW}[!] å¤‡ä»½ç›®å½•ä¸å­˜åœ¨${RESET}"
    pause_and_return
    return
  fi
  
  local backups=($(find "$BACKUP_DIR" -name "*.tar.gz" -type f 2>/dev/null | sort -r))
  
  if [ ${#backups[@]} -eq 0 ]; then
    echo -e "${YELLOW}[!] æ²¡æœ‰æ‰¾åˆ°å¤‡ä»½æ–‡ä»¶${RESET}"
  else
    echo "æ‰¾åˆ° ${#backups[@]} ä¸ªå¤‡ä»½æ–‡ä»¶:"
    echo ""
    for i in "${!backups[@]}"; do
      local backup="${backups[$i]}"
      local size=$(du -sh "$backup" | cut -f1)
      local date=$(stat -c %y "$backup" 2>/dev/null | cut -d' ' -f1 || stat -f %Sm "$backup" | cut -d' ' -f1)
      echo "$((i+1)). $(basename "$backup")"
      echo "   å¤§å°: $size, æ—¥æœŸ: $date"
      echo ""
    done
  fi
  
  pause_and_return
}

function setup_auto_backup() {
  echo -e "${BLUE}[*] è®¾ç½®è‡ªåŠ¨å¤‡ä»½...${RESET}"
  
  # åˆ›å»ºå¤‡ä»½è„šæœ¬
  cat > "$NCK_DIR/auto_backup.sh" << 'EOF'
#!/bin/bash
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
cd "$SCRIPT_DIR"
./nockchain_manager.sh auto_backup_task
EOF
  
  chmod +x "$NCK_DIR/auto_backup.sh"
  
  echo "é€‰æ‹©å¤‡ä»½é¢‘ç‡:"
  echo "1) æ¯æ—¥å¤‡ä»½ (å‡Œæ™¨2ç‚¹)"
  echo "2) æ¯å‘¨å¤‡ä»½ (å‘¨æ—¥å‡Œæ™¨2ç‚¹)"
  echo "3) è‡ªå®šä¹‰æ—¶é—´"
  
  read -p "è¯·é€‰æ‹©: " freq_choice
  
  local cron_job=""
  case "$freq_choice" in
    1) cron_job="0 2 * * * $NCK_DIR/auto_backup.sh" ;;
    2) cron_job="0 2 * * 0 $NCK_DIR/auto_backup.sh" ;;
    3) 
      read -p "è¯·è¾“å…¥cronè¡¨è¾¾å¼ (å¦‚: 0 2 * * *): " custom_cron
      cron_job="$custom_cron $NCK_DIR/auto_backup.sh"
      ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return; return ;;
  esac
  
  # æ·»åŠ åˆ°crontab
  (crontab -l 2>/dev/null | grep -v "auto_backup.sh"; echo "$cron_job") | crontab -
  
  echo -e "${GREEN}[+] è‡ªåŠ¨å¤‡ä»½å·²è®¾ç½®${RESET}"
  echo "å¤‡ä»½æ—¶é—´: $cron_job"
  
  pause_and_return
}

function auto_backup_task() {
  # é™é»˜æ‰§è¡Œå¤‡ä»½ä»»åŠ¡
  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="$BACKUP_DIR/auto_backup_$timestamp.tar.gz"
  
  mkdir -p "$BACKUP_DIR"
  
  # åˆ›å»ºä¸´æ—¶å¤‡ä»½ç›®å½•
  local temp_dir="$BACKUP_DIR/temp_$$"
  mkdir -p "$temp_dir"
  
  # å¤‡ä»½å…³é”®æ–‡ä»¶
  [ -f "$ENV_FILE" ] && cp "$ENV_FILE" "$temp_dir/"
  [ -d "$HOME/.nockchain" ] && cp -r "$HOME/.nockchain" "$temp_dir/" 2>/dev/null
  
  # å‹ç¼©å¤‡ä»½
  tar -czf "$backup_path" -C "$BACKUP_DIR" "$(basename "$temp_dir")" 2>/dev/null
  rm -rf "$temp_dir"
  
  # æ¸…ç†è¶…è¿‡30å¤©çš„å¤‡ä»½
  find "$BACKUP_DIR" -name "auto_backup_*.tar.gz" -mtime +30 -delete 2>/dev/null
  
  echo "$(date): è‡ªåŠ¨å¤‡ä»½å®Œæˆ - $backup_path" >> "$NCK_DIR/backup.log"
}

# ========= ç½‘ç»œè¯Šæ–­æ¨¡å— =========
function network_diagnostics() {
  echo -e "${CYAN}========== ç½‘ç»œè¯Šæ–­ ==========${RESET}"
  
  echo -e "${BOLD}ç«¯å£çŠ¶æ€æ£€æŸ¥:${RESET}"
  local important_ports=("8545" "30303")
  for port in "${important_ports[@]}"; do
    if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
      echo -e "ç«¯å£ $port: ${GREEN}å·²å ç”¨${RESET}"
      netstat -tlnp 2>/dev/null | grep ":$port " | head -1
    else
      echo -e "ç«¯å£ $port: ${YELLOW}ç©ºé—²${RESET}"
    fi
  done
  echo ""
  
  echo -e "${BOLD}ç½‘ç»œè¿æ¥ç»Ÿè®¡:${RESET}"
  local total_connections=$(netstat -an 2>/dev/null | grep ESTABLISHED | wc -l)
  echo "æ´»è·ƒè¿æ¥æ•°: $total_connections"
  echo ""
  
  echo -e "${BOLD}é˜²ç«å¢™çŠ¶æ€:${RESET}"
  if command -v ufw &>/dev/null; then
    sudo ufw status 2>/dev/null || echo "UFWæœªå®‰è£…æˆ–æœªå¯ç”¨"
  elif command -v iptables &>/dev/null; then
    echo "IPTablesè§„åˆ™æ•°: $(iptables -L INPUT 2>/dev/null | grep -c "^ACCEPT\|^DROP\|^REJECT" || echo "0")"
  else
    echo "æœªæ£€æµ‹åˆ°é˜²ç«å¢™é…ç½®"
  fi
  echo ""
  
  echo -e "${BOLD}ç½‘ç»œè¿é€šæ€§æµ‹è¯•:${RESET}"
  echo "æµ‹è¯•å¤–ç½‘è¿æ¥..."
  if ping -c 3 -W 3 8.8.8.8 >/dev/null 2>&1; then
    echo -e "${GREEN}[+] å¤–ç½‘è¿æ¥æ­£å¸¸${RESET}"
  else
    echo -e "${RED}[-] å¤–ç½‘è¿æ¥å¼‚å¸¸${RESET}"
  fi
  
  echo "æµ‹è¯•DNSè§£æ..."
  if nslookup google.com >/dev/null 2>&1; then
    echo -e "${GREEN}[+] DNSè§£ææ­£å¸¸${RESET}"
  else
    echo -e "${RED}[-] DNSè§£æå¼‚å¸¸${RESET}"
  fi
  
  pause_and_return
}

function optimize_network() {
  echo -e "${BLUE}[*] ç½‘ç»œä¼˜åŒ–...${RESET}"
  
  echo "æ­£åœ¨ä¼˜åŒ–ç½‘ç»œå‚æ•°..."
  
  # å¤‡ä»½åŸå§‹é…ç½®
  [ ! -f /etc/sysctl.conf.backup ] && sudo cp /etc/sysctl.conf /etc/sysctl.conf.backup
  
  # æ·»åŠ ç½‘ç»œä¼˜åŒ–å‚æ•°
  sudo tee -a /etc/sysctl.conf > /dev/null << 'EOF'

# Nockchainç½‘ç»œä¼˜åŒ–å‚æ•°
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_default = 262144
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 65536 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_congestion_control = bbr
EOF
  
  # åº”ç”¨é…ç½®
  sudo sysctl -p >/dev/null 2>&1
  
  echo -e "${GREEN}[+] ç½‘ç»œå‚æ•°ä¼˜åŒ–å®Œæˆ${RESET}"
  echo "ä¼˜åŒ–å†…å®¹:"
  echo "- å¢å¤§ç½‘ç»œç¼“å†²åŒº"
  echo "- å¯ç”¨BBRæ‹¥å¡æ§åˆ¶"
  echo "- ä¼˜åŒ–TCPå‚æ•°"
  
  pause_and_return
}

# ========= æ™ºèƒ½æ•…éšœè¯Šæ–­ =========
function smart_diagnostics() {
  echo -e "${CYAN}========== æ™ºèƒ½æ•…éšœè¯Šæ–­ ==========${RESET}"
  
  local issues=()
  
  echo "æ­£åœ¨æ‰§è¡Œå…¨é¢ç³»ç»Ÿæ£€æŸ¥..."
  echo ""
  
  # æ£€æŸ¥Rustç¯å¢ƒ
  if ! check_rust_installation >/dev/null 2>&1; then
    issues+=("Rustæœªæ­£ç¡®å®‰è£…")
  fi
  
  # æ£€æŸ¥ä¾èµ–
  if ! check_dependencies >/dev/null 2>&1; then
    issues+=("ç³»ç»Ÿä¾èµ–ç¼ºå¤±")
  fi
  
  # æ£€æŸ¥ç£ç›˜ç©ºé—´
  if ! check_disk_space >/dev/null 2>&1; then
    issues+=("ç£ç›˜ç©ºé—´ä¸è¶³")
  fi
  
  # æ£€æŸ¥å†…å­˜ä½¿ç”¨
  if ! check_memory_usage >/dev/null 2>&1; then
    issues+=("å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜")
  fi
  
  # æ£€æŸ¥ç«¯å£å†²çª
  if ! check_port_conflicts >/dev/null 2>&1; then
    issues+=("ç«¯å£è¢«å ç”¨")
  fi
  
  # æ£€æŸ¥é¡¹ç›®ç›®å½•
  if [ ! -d "$NCK_DIR" ]; then
    issues+=("é¡¹ç›®ç›®å½•ä¸å­˜åœ¨")
  fi
  
  # æ£€æŸ¥é…ç½®æ–‡ä»¶
  if [ ! -f "$ENV_FILE" ]; then
    issues+=("é…ç½®æ–‡ä»¶ç¼ºå¤±")
  fi
  
  # ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
  echo -e "${BOLD}è¯Šæ–­ç»“æœ:${RESET}"
  if [ ${#issues[@]} -eq 0 ]; then
    echo -e "${GREEN}[+] ç³»ç»ŸçŠ¶æ€è‰¯å¥½ï¼Œæœªå‘ç°é—®é¢˜${RESET}"
  else
    echo -e "${RED}[-] å‘ç° ${#issues[@]} ä¸ªé—®é¢˜:${RESET}"
    for issue in "${issues[@]}"; do
      echo "  â€¢ $issue"
    done
    echo ""
    
    read -p "æ˜¯å¦å°è¯•è‡ªåŠ¨ä¿®å¤è¿™äº›é—®é¢˜? (y/n): " auto_fix
    if [[ "$auto_fix" =~ ^[Yy]$ ]]; then
      auto_fix_issues "${issues[@]}"
    fi
  fi
  
  pause_and_return
}

function auto_fix_issues() {
  local issues=("$@")
  echo -e "${BLUE}[*] å°è¯•è‡ªåŠ¨ä¿®å¤é—®é¢˜...${RESET}"
  
  for issue in "${issues[@]}"; do
    echo "ä¿®å¤: $issue"
    case "$issue" in
      "Rustæœªæ­£ç¡®å®‰è£…")
        install_rust
        ;;
      "ç³»ç»Ÿä¾èµ–ç¼ºå¤±")
        install_system_dependencies
        ;;
      "ç£ç›˜ç©ºé—´ä¸è¶³")
        cleanup_disk_space
        ;;
      "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜")
        cleanup_memory
        ;;
      "é¡¹ç›®ç›®å½•ä¸å­˜åœ¨")
        clone_repository
        ;;
      "é…ç½®æ–‡ä»¶ç¼ºå¤±")
        create_default_config
        ;;
      *)
        echo "  æ— æ³•è‡ªåŠ¨ä¿®å¤æ­¤é—®é¢˜ï¼Œè¯·æ‰‹åŠ¨å¤„ç†"
        ;;
    esac
  done
}

function cleanup_disk_space() {
  echo "æ¸…ç†ç£ç›˜ç©ºé—´..."
  
  # æ¸…ç†ç³»ç»Ÿç¼“å­˜
  sudo apt-get autoremove -y >/dev/null 2>&1
  sudo apt-get autoclean >/dev/null 2>&1
  
  # æ¸…ç†æ—¥å¿—æ–‡ä»¶
  find "$NCK_DIR" -name "*.log" -size +50M -exec truncate -s 10M {} \; 2>/dev/null
  
  # æ¸…ç†æ—§çš„å¤‡ä»½æ–‡ä»¶
  find "$BACKUP_DIR" -name "*.tar.gz" -mtime +7 -delete 2>/dev/null
  
  echo -e "${GREEN}[+] ç£ç›˜æ¸…ç†å®Œæˆ${RESET}"
}

function cleanup_memory() {
  echo "æ¸…ç†å†…å­˜..."
  
  # æ¸…ç†é¡µé¢ç¼“å­˜
  sudo sync
  echo 1 | sudo tee /proc/sys/vm/drop_caches >/dev/null 2>&1
  
  echo -e "${GREEN}[+] å†…å­˜æ¸…ç†å®Œæˆ${RESET}"
}

# ========= é…ç½®ç®¡ç†å™¨ =========
function config_manager() {
  echo -e "${CYAN}========== é…ç½®ç®¡ç†å™¨ ==========${RESET}"
  echo "1) æŸ¥çœ‹å½“å‰é…ç½®"
  echo "2) åˆ›å»ºä¸»ç½‘é…ç½®"
  echo "3) åˆ›å»ºæµ‹è¯•ç½‘é…ç½®"
  echo "4) åˆ›å»ºå¼€å‘é…ç½®"
  echo "5) è‡ªå®šä¹‰é…ç½®å‘å¯¼"
  echo "6) å¤‡ä»½å½“å‰é…ç½®"
  echo "7) æ¢å¤é…ç½®"
  echo "0) è¿”å›ä¸»èœå•"
  echo ""
  read -p "è¯·é€‰æ‹©: " config_choice
  
  case "$config_choice" in
    1) view_current_config ;;
    2) create_mainnet_config ;;
    3) create_testnet_config ;;
    4) create_dev_config ;;
    5) custom_config_wizard ;;
    6) backup_config ;;
    7) restore_config ;;
    0) main_menu ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function view_current_config() {
  echo -e "${BLUE}[*] å½“å‰é…ç½®:${RESET}"
  
  if [ -f "$ENV_FILE" ]; then
    echo "é…ç½®æ–‡ä»¶: $ENV_FILE"
    echo "æ–‡ä»¶å¤§å°: $(du -h "$ENV_FILE" | cut -f1)"
    echo "ä¿®æ”¹æ—¶é—´: $(stat -c %y "$ENV_FILE" 2>/dev/null || stat -f %Sm "$ENV_FILE")"
    echo ""
    echo -e "${BOLD}é…ç½®å†…å®¹:${RESET}"
    cat "$ENV_FILE"
  else
    echo -e "${YELLOW}[!] é…ç½®æ–‡ä»¶ä¸å­˜åœ¨${RESET}"
  fi
  
  pause_and_return
}

function create_mainnet_config() {
  echo -e "${BLUE}[*] åˆ›å»ºä¸»ç½‘é…ç½®...${RESET}"
  
  cat > "$ENV_FILE" << 'EOF'
# Nockchain ä¸»ç½‘é…ç½®
NETWORK=mainnet
RPC_PORT=8545
P2P_PORT=30303
MINING_ENABLED=true
LOG_LEVEL=info
MAX_PEERS=50
SYNC_MODE=full

# æŒ–çŸ¿é…ç½®
MINING_PUBKEY=
MINING_THREADS=auto

# ç½‘ç»œé…ç½®
BOOTNODES=
NAT=auto

# å­˜å‚¨é…ç½®
DATA_DIR=./data
CACHE_SIZE=1024
EOF
  
  echo -e "${GREEN}[+] ä¸»ç½‘é…ç½®å·²åˆ›å»º${RESET}"
  echo -e "${YELLOW}[!] è¯·è®¾ç½® MINING_PUBKEY å‚æ•°${RESET}"
  
  pause_and_return
}

function create_testnet_config() {
  echo -e "${BLUE}[*] åˆ›å»ºæµ‹è¯•ç½‘é…ç½®...${RESET}"
  
  cat > "$ENV_FILE" << 'EOF'
# Nockchain æµ‹è¯•ç½‘é…ç½®
NETWORK=testnet
RPC_PORT=8545
P2P_PORT=30303
MINING_ENABLED=true
LOG_LEVEL=debug
MAX_PEERS=25
SYNC_MODE=fast

# æŒ–çŸ¿é…ç½®
MINING_PUBKEY=
MINING_THREADS=2

# ç½‘ç»œé…ç½®
BOOTNODES=
NAT=auto

# å­˜å‚¨é…ç½®
DATA_DIR=./testnet_data
CACHE_SIZE=512
EOF
  
  echo -e "${GREEN}[+] æµ‹è¯•ç½‘é…ç½®å·²åˆ›å»º${RESET}"
  pause_and_return
}

function create_dev_config() {
  echo -e "${BLUE}[*] åˆ›å»ºå¼€å‘é…ç½®...${RESET}"
  
  cat > "$ENV_FILE" << 'EOF'
# Nockchain å¼€å‘é…ç½®
NETWORK=dev
RPC_PORT=8545
P2P_PORT=30303
MINING_ENABLED=false
LOG_LEVEL=trace
MAX_PEERS=10
SYNC_MODE=light

# å¼€å‘é…ç½®
DEV_MODE=true
AUTO_MINE=false
BLOCK_TIME=5

# ç½‘ç»œé…ç½®
NAT=none

# å­˜å‚¨é…ç½®
DATA_DIR=./dev_data
CACHE_SIZE=256
EOF
  
  echo -e "${GREEN}[+] å¼€å‘é…ç½®å·²åˆ›å»º${RESET}"
  pause_and_return
}

function custom_config_wizard() {
  echo -e "${BLUE}[*] è‡ªå®šä¹‰é…ç½®å‘å¯¼...${RESET}"
  
  # ç½‘ç»œé€‰æ‹©
  echo "1. é€‰æ‹©ç½‘ç»œç±»å‹:"
  echo "  1) Mainnet"
  echo "  2) Testnet"
  echo "  3) Development"
  read -p "è¯·é€‰æ‹© (1-3): " network_choice
  
  local network=""
  case "$network_choice" in
    1) network="mainnet" ;;
    2) network="testnet" ;;
    3) network="dev" ;;
    *) network="mainnet" ;;
  esac
  
  # ç«¯å£é…ç½®
  read -p "2. RPCç«¯å£ (é»˜è®¤: 8545): " rpc_port
  rpc_port=${rpc_port:-8545}
  
  read -p "3. P2Pç«¯å£ (é»˜è®¤: 30303): " p2p_port
  p2p_port=${p2p_port:-30303}
  
  # æŒ–çŸ¿é…ç½®
  read -p "4. å¯ç”¨æŒ–çŸ¿? (y/n, é»˜è®¤: y): " mining_enabled
  mining_enabled=${mining_enabled:-y}
  [[ "$mining_enabled" =~ ^[Yy]$ ]] && mining_enabled="true" || mining_enabled="false"
  
  if [ "$mining_enabled" = "true" ]; then
    read -p "5. æŒ–çŸ¿å…¬é’¥: " mining_pubkey
    read -p "6. æŒ–çŸ¿çº¿ç¨‹æ•° (é»˜è®¤: auto): " mining_threads
    mining_threads=${mining_threads:-auto}
  fi
  
  # æ—¥å¿—çº§åˆ«
  echo "7. æ—¥å¿—çº§åˆ«:"
  echo "  1) error  2) warn  3) info  4) debug  5) trace"
  read -p "è¯·é€‰æ‹© (1-5): " log_choice
  
  local log_level=""
  case "$log_choice" in
    1) log_level="error" ;;
    2) log_level="warn" ;;
    3) log_level="info" ;;
    4) log_level="debug" ;;
    5) log_level="trace" ;;
    *) log_level="info" ;;
  esac
  
  # ç”Ÿæˆé…ç½®æ–‡ä»¶
  cat > "$ENV_FILE" << EOF
# Nockchain è‡ªå®šä¹‰é…ç½®
NETWORK=$network
RPC_PORT=$rpc_port
P2P_PORT=$p2p_port
MINING_ENABLED=$mining_enabled
LOG_LEVEL=$log_level

# æŒ–çŸ¿é…ç½®
MINING_PUBKEY=${mining_pubkey:-}
MINING_THREADS=${mining_threads:-auto}

# ç½‘ç»œé…ç½®
MAX_PEERS=50
SYNC_MODE=full
NAT=auto

# å­˜å‚¨é…ç½®
DATA_DIR=./data
CACHE_SIZE=1024

# ç”Ÿæˆæ—¶é—´
CREATED=$(date)
EOF
  
  echo -e "${GREEN}[+] è‡ªå®šä¹‰é…ç½®å·²åˆ›å»º${RESET}"
  pause_and_return
}

# ========= åŸæœ‰åŠŸèƒ½å¢å¼º =========
function setup_all() {
  echo -e "${CYAN}========== ä¸€é”®å®‰è£…å¹¶æ„å»º ==========${RESET}"
  
  # ç³»ç»Ÿæ£€æµ‹
  detect_system
  
  echo -e "[*] å®‰è£…ç³»ç»Ÿä¾èµ–..."
  install_system_dependencies
  
  echo -e "[*] å®‰è£… Rust..."
  install_rust
  
  echo -e "[*] è·å–ä»“åº“..."
  clone_repository
  
  cd_nck_dir
  
  echo -e "[*] è®¾ç½® .env æ–‡ä»¶..."
  setup_env_file
  
  echo -e "[*] å®‰è£… hoonc..."
  make install-hoonc || { echo -e "${RED}[-] install-hoonc å¤±è´¥${RESET}"; exit 1; }
  
  echo -e "[*] ç¼–è¯‘ Nockchain..."
  make build || { echo -e "${RED}[-] build å¤±è´¥${RESET}"; exit 1; }
  
  echo -e "[*] å®‰è£…é’±åŒ…..."
  make install-nockchain-wallet || { echo -e "${RED}[-] install-nockchain-wallet å¤±è´¥${RESET}"; exit 1; }
  
  echo -e "[*] å®‰è£…èŠ‚ç‚¹..."
  make install-nockchain || { echo -e "${RED}[-] install-nockchain å¤±è´¥${RESET}"; exit 1; }
  
  echo -e "${GREEN}[+] å®‰è£…å®Œæˆ${RESET}"
  echo "ä¸‹ä¸€æ­¥ï¼š"
  echo "1. ç”Ÿæˆé’±åŒ…å¯†é’¥"
  echo "2. è®¾ç½® MINING_PUBKEY"
  echo "3. å¯åŠ¨èŠ‚ç‚¹"
  
  pause_and_return
}

function install_system_dependencies() {
  case "$PKG_MANAGER" in
    apt)
      sudo apt update
      sudo apt install -y clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen bc sysstat
      ;;
    yum)
      sudo yum update -y
      sudo yum groupinstall -y "Development Tools"
      sudo yum install -y clang llvm-devel openssl-devel curl git make screen bc sysstat
      ;;
  esac
}

function install_rust() {
  if ! command -v cargo &>/dev/null; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source "$HOME/.cargo/env"
  fi
  
  # æ·»åŠ åˆ°shellé…ç½®æ–‡ä»¶
  for rc_file in "$HOME/.bashrc" "$HOME/.zshrc"; do
    if [ -f "$rc_file" ] && ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' "$rc_file"; then
      echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    fi
  done
  
  export PATH="$HOME/.cargo/bin:$PATH"
}

function clone_repository() {
  if [ -d "$NCK_DIR" ]; then
    echo "æ›´æ–°ç°æœ‰ä»“åº“..."
    cd "$NCK_DIR" && git pull
  else
    echo "å…‹éš†æ–°ä»“åº“..."
    git clone https://github.com/zorp-corp/nockchain "$NCK_DIR"
  fi
}

function setup_env_file() {
  if [ ! -f "$ENV_FILE" ]; then
    if [ -f "$NCK_DIR/.env_example" ]; then
      cp "$NCK_DIR/.env_example" "$ENV_FILE"
    else
      # åˆ›å»ºé»˜è®¤é…ç½®
      create_mainnet_config
    fi
  fi
}

function wallet_management() {
  echo -e "${CYAN}========== é’±åŒ…ç®¡ç† ==========${RESET}"
  echo "1) ç”Ÿæˆæ–°é’±åŒ…"
  echo "2) æŸ¥çœ‹é’±åŒ…ä¿¡æ¯"
  echo "3) å¯¼å‡ºé’±åŒ…å¯†é’¥"
  echo "4) å¯¼å…¥é’±åŒ…å¯†é’¥"
  echo "5) è®¾ç½®æŒ–çŸ¿å…¬é’¥"
  echo "6) å¤‡ä»½é’±åŒ…"
  echo "0) è¿”å›ä¸»èœå•"
  echo ""
  read -p "è¯·é€‰æ‹©: " wallet_choice
  
  case "$wallet_choice" in
    1) generate_wallet ;;
    2) view_wallet_info ;;
    3) export_keys ;;
    4) import_keys ;;
    5) set_pubkey_env ;;
    6) backup_wallet ;;
    0) main_menu ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function generate_wallet() {
  echo -e "${BLUE}[*] ç”Ÿæˆé’±åŒ…...${RESET}"
  cd_nck_dir
  
  # æ£€æŸ¥é’±åŒ…æ˜¯å¦å·²å­˜åœ¨
  if [ -d "$HOME/.nockchain" ]; then
    read -p "é’±åŒ…å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–? (y/n): " overwrite
    if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
      echo "å–æ¶ˆç”Ÿæˆé’±åŒ…"
      pause_and_return
      return
    fi
  fi
  
  ./target/release/nockchain-wallet keygen
  
  echo -e "${YELLOW}[!] é’±åŒ…ç”Ÿæˆå®Œæˆ${RESET}"
  echo "è¯·ä¿å­˜å¥½åŠ©è®°è¯å’Œç§é’¥ï¼"
  echo "ä¸‹ä¸€æ­¥è¯·å°†å…¬é’¥è®¾ç½®åˆ° .env æ–‡ä»¶ä¸­"
  
  pause_and_return
}

function view_wallet_info() {
  echo -e "${BLUE}[*] æŸ¥çœ‹é’±åŒ…ä¿¡æ¯...${RESET}"
  
  if [ ! -d "$HOME/.nockchain" ]; then
    echo -e "${RED}[-] é’±åŒ…æœªåˆå§‹åŒ–${RESET}"
    pause_and_return
    return
  fi
  
  echo "é’±åŒ…ç›®å½•: $HOME/.nockchain"
  echo "ç›®å½•å¤§å°: $(du -sh "$HOME/.nockchain" | cut -f1)"
  
  if [ -f "$HOME/.nockchain/keystore" ]; then
    echo "å¯†é’¥æ–‡ä»¶: å­˜åœ¨"
  else
    echo "å¯†é’¥æ–‡ä»¶: ä¸å­˜åœ¨"
  fi
  
  # æ˜¾ç¤ºå½“å‰é…ç½®çš„æŒ–çŸ¿å…¬é’¥
  if [ -f "$ENV_FILE" ]; then
    local current_pubkey=$(grep "^MINING_PUBKEY=" "$ENV_FILE" | cut -d'=' -f2)
    if [ -n "$current_pubkey" ]; then
      echo "å½“å‰æŒ–çŸ¿å…¬é’¥: $current_pubkey"
    else
      echo "æŒ–çŸ¿å…¬é’¥: æœªè®¾ç½®"
    fi
  fi
  
  pause_and_return
}

function set_pubkey_env() {
  echo -e "${BLUE}[*] è®¾ç½® MINING_PUBKEY åˆ° .env...${RESET}"
  cd_nck_dir
  
  # æ˜¾ç¤ºå½“å‰å€¼
  if [ -f "$ENV_FILE" ]; then
    local current_pubkey=$(grep "^MINING_PUBKEY=" "$ENV_FILE" | cut -d'=' -f2)
    if [ -n "$current_pubkey" ]; then
      echo "å½“å‰å…¬é’¥: $current_pubkey"
    fi
  fi
  
  read -p "è¯·è¾“å…¥æ–°çš„å…¬é’¥ (MINING_PUBKEY): " pubkey
  if [ -z "$pubkey" ]; then
    echo -e "${RED}[-] å…¬é’¥ä¸èƒ½ä¸ºç©º${RESET}"
    pause_and_return
    return
  fi
  
  # éªŒè¯å…¬é’¥æ ¼å¼ï¼ˆç®€å•æ£€æŸ¥ï¼‰
  if [[ ${#pubkey} -lt 40 ]]; then
    echo -e "${YELLOW}[!] è­¦å‘Š: å…¬é’¥é•¿åº¦ä¼¼ä¹ä¸æ­£ç¡®${RESET}"
    read -p "æ˜¯å¦ç»§ç»­? (y/n): " continue_anyway
    if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
      pause_and_return
      return
    fi
  fi
  
  # æ›´æ–°é…ç½®æ–‡ä»¶
  if [ -f "$ENV_FILE" ]; then
    # åˆ é™¤æ—§çš„é…ç½®è¡Œ
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE"
  else
    touch "$ENV_FILE"
  fi
  
  # æ·»åŠ æ–°çš„é…ç½®
  echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
  
  echo -e "${GREEN}[+] å·²å†™å…¥ MINING_PUBKEY åˆ° .env${RESET}"
  pause_and_return
}

function export_keys() {
  echo -e "${BLUE}[*] å¯¼å‡ºé’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir
  
  local export_file="./keys_$(date +%Y%m%d_%H%M%S).export"
  
  ./target/release/nockchain-wallet export-keys --output "$export_file"
  
  if [ -f "$export_file" ]; then
    echo -e "${GREEN}[+] å¯†é’¥å·²å¯¼å‡ºåˆ°: $export_file${RESET}"
    echo "æ–‡ä»¶å¤§å°: $(du -h "$export_file" | cut -f1)"
    echo -e "${YELLOW}[!] è¯·å¦¥å–„ä¿ç®¡å¯¼å‡ºæ–‡ä»¶${RESET}"
  else
    echo -e "${RED}[-] å¯¼å‡ºå¤±è´¥${RESET}"
  fi
  
  pause_and_return
}

function import_keys() {
  echo -e "${BLUE}[*] å¯¼å…¥é’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir
  
  echo "è¯·é€‰æ‹©å¯¼å…¥æ–¹å¼:"
  echo "1) ä»æ–‡ä»¶å¯¼å…¥"
  echo "2) è¾“å…¥é»˜è®¤è·¯å¾„ (./keys.export)"
  
  read -p "è¯·é€‰æ‹© (1-2): " import_choice
  
  local keyfile=""
  case "$import_choice" in
    1)
      read -p "è¯·è¾“å…¥å¯†é’¥æ–‡ä»¶å®Œæ•´è·¯å¾„: " keyfile
      ;;
    2)
      keyfile="./keys.export"
      ;;
    *)
      echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"
      pause_and_return
      return
      ;;
  esac
  
  if [ ! -f "$keyfile" ]; then
    echo -e "${RED}[-] æ–‡ä»¶ä¸å­˜åœ¨: $keyfile${RESET}"
    pause_and_return
    return
  fi
  
  echo "å¯¼å…¥æ–‡ä»¶: $keyfile"
  echo "æ–‡ä»¶å¤§å°: $(du -h "$keyfile" | cut -f1)"
  
  read -p "ç¡®è®¤å¯¼å…¥? (y/n): " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    ./target/release/nockchain-wallet import-keys --input "$keyfile"
    echo -e "${GREEN}[+] å¯†é’¥å·²å¯¼å…¥${RESET}"
  else
    echo "å–æ¶ˆå¯¼å…¥"
  fi
  
  pause_and_return
}

function backup_wallet() {
  echo -e "${BLUE}[*] å¤‡ä»½é’±åŒ…...${RESET}"
  
  if [ ! -d "$HOME/.nockchain" ]; then
    echo -e "${RED}[-] é’±åŒ…ç›®å½•ä¸å­˜åœ¨${RESET}"
    pause_and_return
    return
  fi
  
  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_file="$BACKUP_DIR/wallet_backup_$timestamp.tar.gz"
  
  mkdir -p "$BACKUP_DIR"
  
  # åˆ›å»ºé’±åŒ…å¤‡ä»½
  tar -czf "$backup_file" -C "$HOME" ".nockchain" 2>/dev/null
  
  if [ -f "$backup_file" ]; then
    echo -e "${GREEN}[+] é’±åŒ…å¤‡ä»½å·²åˆ›å»º: $backup_file${RESET}"
    echo "å¤‡ä»½å¤§å°: $(du -sh "$backup_file" | cut -f1)"
  else
    echo -e "${RED}[-] å¤‡ä»½åˆ›å»ºå¤±è´¥${RESET}"
  fi
  
  pause_and_return
}

function node_control() {
  echo -e "${CYAN}========== èŠ‚ç‚¹æ§åˆ¶ ==========${RESET}"
  echo "1) å¯åŠ¨èŠ‚ç‚¹"
  echo "2) åœæ­¢èŠ‚ç‚¹"
  echo "3) é‡å¯èŠ‚ç‚¹"
  echo "4) æŸ¥çœ‹èŠ‚ç‚¹çŠ¶æ€"
  echo "5) æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—"
  echo "6) èŠ‚ç‚¹æ€§èƒ½ç›‘æ§"
  echo "0) è¿”å›ä¸»èœå•"
  echo ""
  read -p "è¯·é€‰æ‹©: " node_choice
  
  case "$node_choice" in
    1) start_node ;;
    2) stop_node ;;
    3) restart_node ;;
    4) check_node_status ;;
    5) view_logs ;;
    6) performance_dashboard ;;
    0) main_menu ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function start_node() {
  echo -e "${BLUE}[*] å¯åŠ¨èŠ‚ç‚¹...${RESET}"
  cd_nck_dir
  
  # æ£€æŸ¥é…ç½®æ–‡ä»¶
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆè®¾ç½®é…ç½®${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"
  
  # æ£€æŸ¥æŒ–çŸ¿å…¬é’¥
  if [ "$MINING_ENABLED" = "true" ] && [ -z "$MINING_PUBKEY" ]; then
    echo -e "${YELLOW}[!] è­¦å‘Š: å¯ç”¨äº†æŒ–çŸ¿ä½†æœªè®¾ç½® MINING_PUBKEY${RESET}"
    read -p "æ˜¯å¦ç»§ç»­å¯åŠ¨? (y/n): " continue_start
    if [[ ! "$continue_start" =~ ^[Yy]$ ]]; then
      pause_and_return
      return
    fi
  fi
  
  # æ£€æŸ¥å¯åŠ¨è„šæœ¬
  if [ ! -f "./scripts/run_nockchain_miner.sh" ]; then
    echo -e "${YELLOW}[!] å¯åŠ¨è„šæœ¬ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤è„šæœ¬...${RESET}"
    mkdir -p scripts
    cat > "./scripts/run_nockchain_miner.sh" << 'EOF'
#!/bin/bash
cd "$(dirname "$0")/.."
source .env
./target/release/nockchain --config .env
EOF
    chmod +x "./scripts/run_nockchain_miner.sh"
  fi
  
  # ç¡®ä¿å¯åŠ¨è„šæœ¬æœ‰æ‰§è¡Œæƒé™
  chmod +x ./scripts/run_nockchain_miner.sh
  
  # åœæ­¢æ—§çš„ä¼šè¯
  if screen -list | grep -qw "nockchain"; then
    echo "[*] åœæ­¢æ—§çš„èŠ‚ç‚¹ä¼šè¯..."
    screen -S nockchain -X quit
    sleep 2
  fi
  
  # å¯åŠ¨æ–°ä¼šè¯
  echo "å¯åŠ¨èŠ‚ç‚¹ (screen ä¼šè¯å: nockchain)..."
  screen -dmS nockchain bash -c "cd $NCK_DIR && ./scripts/run_nockchain_miner.sh; read"
  
  sleep 3
  
  # éªŒè¯å¯åŠ¨
  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}[+] èŠ‚ç‚¹å·²å¯åŠ¨${RESET}"
    echo "ä¼šè¯å: nockchain"
    echo "æŸ¥çœ‹æ—¥å¿—: é€‰æ‹©èœå•é€‰é¡¹ 'æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—'"
    echo "è¿›å…¥ä¼šè¯: screen -r nockchain"
  else
    echo -e "${RED}[-] èŠ‚ç‚¹å¯åŠ¨å¤±è´¥${RESET}"
    echo "è¯·æ£€æŸ¥å¯åŠ¨è„šæœ¬æˆ–é…ç½®æ–‡ä»¶"
  fi
  
  pause_and_return
}

function stop_node() {
  echo -e "${BLUE}[*] åœæ­¢èŠ‚ç‚¹...${RESET}"
  
  if screen -list | grep -qw "nockchain"; then
    screen -S nockchain -X quit
    sleep 2
    
    if ! screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] èŠ‚ç‚¹å·²åœæ­¢${RESET}"
    else
      echo -e "${YELLOW}[!] å¼ºåˆ¶åœæ­¢èŠ‚ç‚¹...${RESET}"
      screen -S nockchain -X kill
    fi
  else
    echo -e "${YELLOW}[!] èŠ‚ç‚¹æœªè¿è¡Œ${RESET}"
  fi
  
  pause_and_return
}

function restart_node() {
  echo -e "${BLUE}[*] é‡å¯èŠ‚ç‚¹...${RESET}"
  stop_node
  sleep 2
  start_node
}

function view_logs() {
  echo -e "${BLUE}[*] æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—...${RESET}"
  
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] è¿›å…¥æ—¥å¿—æŸ¥çœ‹æ¨¡å¼ (Ctrl+A+D å¯é€€å‡º)...${RESET}"
    echo "ç­‰å¾…3ç§’åè¿›å…¥..."
    sleep 3
    screen -r nockchain
  else
    echo -e "${RED}[-] èŠ‚ç‚¹æœªè¿è¡Œ${RESET}"
    echo ""
    echo "æ˜¯å¦æŸ¥çœ‹å†å²æ—¥å¿—æ–‡ä»¶?"
    echo "1) æŸ¥çœ‹ä¸»æ—¥å¿—æ–‡ä»¶"
    echo "2) é«˜çº§æ—¥å¿—åˆ†æ"
    echo "3) è¿”å›"
    
    read -p "è¯·é€‰æ‹©: " log_choice
    case "$log_choice" in
      1)
        if [ -f "$LOG_FILE" ]; then
          echo "æœ€å50è¡Œæ—¥å¿—:"
          tail -50 "$LOG_FILE"
        else
          echo "æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨"
        fi
        ;;
      2)
        advanced_log_analysis
        return
        ;;
    esac
  fi
  
  pause_and_return
}

# ========= é«˜çº§åŠŸèƒ½èœå• =========
function advanced_features() {
  echo -e "${CYAN}========== é«˜çº§åŠŸèƒ½ ==========${RESET}"
  echo "1) ç³»ç»Ÿå¥åº·æ£€æŸ¥"
  echo "2) æ™ºèƒ½æ•…éšœè¯Šæ–­"
  echo "3) æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿"
  echo "4) ç½‘ç»œè¯Šæ–­ä¸ä¼˜åŒ–"
  echo "5) é«˜çº§æ—¥å¿—åˆ†æ"
  echo "6) è‡ªåŠ¨åŒ–è®¾ç½®"
  echo "0) è¿”å›ä¸»èœå•"
  echo ""
  read -p "è¯·é€‰æ‹©: " advanced_choice
  
  case "$advanced_choice" in
    1) system_health_check; pause_and_return ;;
    2) smart_diagnostics ;;
    3) performance_dashboard ;;
    4) network_features ;;
    5) advanced_log_analysis ;;
    6) automation_setup ;;
    0) main_menu ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function network_features() {
  echo -e "${CYAN}========== ç½‘ç»œåŠŸèƒ½ ==========${RESET}"
  echo "1) ç½‘ç»œè¯Šæ–­"
  echo "2) ç½‘ç»œä¼˜åŒ–"
  echo "3) ç«¯å£æ‰«æ"
  echo "4) è¿æ¥ç»Ÿè®¡"
  echo "0) è¿”å›"
  echo ""
  read -p "è¯·é€‰æ‹©: " net_choice
  
  case "$net_choice" in
    1) network_diagnostics ;;
    2) optimize_network ;;
    3) port_scan ;;
    4) connection_stats ;;
    0) advanced_features ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function port_scan() {
  echo -e "${BLUE}[*] ç«¯å£æ‰«æ...${RESET}"
  
  local ports=(8545 30303 22 80 443)
  echo "æ‰«æé‡è¦ç«¯å£..."
  
  for port in "${ports[@]}"; do
    if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
      local process=$(netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $7}' | head -1)
      echo -e "ç«¯å£ $port: ${GREEN}å¼€æ”¾${RESET} ($process)"
    else
      echo -e "ç«¯å£ $port: ${RED}å…³é—­${RESET}"
    fi
  done
  
  pause_and_return
}

function connection_stats() {
  echo -e "${BLUE}[*] è¿æ¥ç»Ÿè®¡...${RESET}"
  
  echo "TCPè¿æ¥ç»Ÿè®¡:"
  netstat -an 2>/dev/null | awk '/^tcp/ {print $6}' | sort | uniq -c | sort -nr
  
  echo ""
  echo "æ´»è·ƒè¿æ¥è¯¦æƒ…:"
  netstat -tuln 2>/dev/null | grep -E "8545|30303"
  
  pause_and_return
}

function automation_setup() {
  echo -e "${CYAN}========== è‡ªåŠ¨åŒ–è®¾ç½® ==========${RESET}"
  echo "1) è®¾ç½®å¼€æœºè‡ªå¯"
  echo "2) è®¾ç½®è‡ªåŠ¨å¤‡ä»½"
  echo "3) è®¾ç½®å¥åº·ç›‘æ§"
  echo "4) è®¾ç½®æ—¥å¿—è½®è½¬"
  echo "5) æŸ¥çœ‹å®šæ—¶ä»»åŠ¡"
  echo "6) ç§»é™¤è‡ªåŠ¨åŒ–"
  echo "0) è¿”å›"
  echo ""
  read -p "è¯·é€‰æ‹©: " auto_choice
  
  case "$auto_choice" in
    1) setup_autostart ;;
    2) setup_auto_backup ;;
    3) setup_health_monitor ;;
    4) setup_log_rotation ;;
    5) view_cron_jobs ;;
    6) remove_automation ;;
    0) advanced_features ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function setup_autostart() {
  echo -e "${BLUE}[*] è®¾ç½®å¼€æœºè‡ªå¯...${RESET}"
  
  # åˆ›å»ºsystemdæœåŠ¡æ–‡ä»¶
  cat > /tmp/nockchain.service << EOF
[Unit]
Description=Nockchain Node
After=network.target

[Service]
Type=forking
User=$USER
WorkingDirectory=$NCK_DIR
ExecStart=/usr/bin/screen -dmS nockchain $NCK_DIR/scripts/run_nockchain_miner.sh
ExecStop=/usr/bin/screen -S nockchain -X quit
Restart=always

[Install]
WantedBy=multi-user.target
EOF
  
  sudo mv /tmp/nockchain.service /etc/systemd/system/
  sudo systemctl daemon-reload
  sudo systemctl enable nockchain.service
  
  echo -e "${GREEN}[+] å¼€æœºè‡ªå¯å·²è®¾ç½®${RESET}"
  echo "ç®¡ç†å‘½ä»¤:"
  echo "  å¯åŠ¨: sudo systemctl start nockchain"
  echo "  åœæ­¢: sudo systemctl stop nockchain"
  echo "  çŠ¶æ€: sudo systemctl status nockchain"
  
  pause_and_return
}

function setup_health_monitor() {
  echo -e "${BLUE}[*] è®¾ç½®å¥åº·ç›‘æ§...${RESET}"
  
  # åˆ›å»ºç›‘æ§è„šæœ¬
  cat > "$NCK_DIR/health_monitor.sh" << 'EOF'
#!/bin/bash
LOG_FILE="$HOME/nockchain/health.log"
NCK_DIR="$HOME/nockchain"

log_message() {
  echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >> "$LOG_FILE"
}

# æ£€æŸ¥èŠ‚ç‚¹è¿›ç¨‹
if ! screen -list | grep -qw "nockchain"; then
  log_message "èŠ‚ç‚¹è¿›ç¨‹å¼‚å¸¸ï¼Œå°è¯•é‡å¯"
  cd "$NCK_DIR" && screen -dmS nockchain ./scripts/run_nockchain_miner.sh
fi

# æ£€æŸ¥ç£ç›˜ç©ºé—´
DISK_USAGE=$(df / | awk '/^\// {print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -gt 85 ]; then
  log_message "ç£ç›˜ç©ºé—´ä¸è¶³è­¦å‘Š: ${DISK_USAGE}%"
fi

# æ£€æŸ¥å†…å­˜ä½¿ç”¨
MEM_USAGE=$(free | awk '/^Mem:/ {printf "%.0f", ($3/$2)*100}')
if [ "$MEM_USAGE" -gt 90 ]; then
  log_message "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${MEM_USAGE}%"
fi
EOF
  
  chmod +x "$NCK_DIR/health_monitor.sh"
  
  # æ·»åŠ åˆ°crontab (æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡)
  (crontab -l 2>/dev/null | grep -v "health_monitor.sh"; echo "*/5 * * * * $NCK_DIR/health_monitor.sh") | crontab -
  
  echo -e "${GREEN}[+] å¥åº·ç›‘æ§å·²è®¾ç½® (æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡)${RESET}"
  echo "æ—¥å¿—æ–‡ä»¶: $NCK_DIR/health.log"
  
  pause_and_return
}

function setup_log_rotation() {
  echo -e "${BLUE}[*] è®¾ç½®æ—¥å¿—è½®è½¬...${RESET}"
  
  # æ·»åŠ æ—¥å¿—è½®è½¬åˆ°crontab (æ¯æ—¥æ‰§è¡Œ)
  (crontab -l 2>/dev/null | grep -v "log_rotation"; echo "0 3 * * * $0 log_rotation_task") | crontab -
  
  echo -e "${GREEN}[+] æ—¥å¿—è½®è½¬å·²è®¾ç½® (æ¯æ—¥å‡Œæ™¨3ç‚¹æ‰§è¡Œ)${RESET}"
  
  pause_and_return
}

function log_rotation_task() {
  log_rotation
}

function view_cron_jobs() {
  echo -e "${BLUE}[*] å½“å‰å®šæ—¶ä»»åŠ¡:${RESET}"
  
  crontab -l 2>/dev/null | grep -E "nockchain|health_monitor|backup" || echo "æœªæ‰¾åˆ°ç›¸å…³å®šæ—¶ä»»åŠ¡"
  
  pause_and_return
}

function remove_automation() {
  echo -e "${BLUE}[*] ç§»é™¤è‡ªåŠ¨åŒ–è®¾ç½®...${RESET}"
  
  # ç§»é™¤crontabä»»åŠ¡
  crontab -l 2>/dev/null | grep -v -E "nockchain|health_monitor|backup|log_rotation" | crontab -
  
  # ç§»é™¤systemdæœåŠ¡
  if [ -f "/etc/systemd/system/nockchain.service" ]; then
    sudo systemctl disable nockchain.service
    sudo rm /etc/systemd/system/nockchain.service
    sudo systemctl daemon-reload
  fi
  
  echo -e "${GREEN}[+] è‡ªåŠ¨åŒ–è®¾ç½®å·²ç§»é™¤${RESET}"
  
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "æŒ‰ä»»æ„é”®ç»§ç»­..." key
  main_menu
}

# ========= ä¸»èœå•å¢å¼º =========
function main_menu() {
  show_banner
  
  # æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€
  echo -e "${BOLD}ç³»ç»ŸçŠ¶æ€:${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "èŠ‚ç‚¹çŠ¶æ€: ${GREEN}è¿è¡Œä¸­${RESET}"
  else
    echo -e "èŠ‚ç‚¹çŠ¶æ€: ${RED}å·²åœæ­¢${RESET}"
  fi
  
  local mem_usage=$(free | awk '/^Mem:/ {printf "%.1f%%", ($3/$2)*100}')
  echo "å†…å­˜ä½¿ç”¨: $mem_usage"
  
  local disk_usage=$(df / | awk '/^\// {print $5}')
  echo "ç£ç›˜ä½¿ç”¨: $disk_usage"
  echo ""
  
  echo -e "${CYAN}========== åŸºç¡€åŠŸèƒ½ ==========${RESET}"
  echo "  1) ä¸€é”®å®‰è£…å¹¶æ„å»º"
  echo "  2) é’±åŒ…ç®¡ç†"
  echo "  3) èŠ‚ç‚¹æ§åˆ¶"
  echo "  4) é…ç½®ç®¡ç†å™¨"
  echo ""
  echo -e "${CYAN}========== é«˜çº§åŠŸèƒ½ ==========${RESET}"
  echo "  5) ç³»ç»Ÿç›‘æ§ä¸è¯Šæ–­"
  echo "  6) å¤‡ä»½ä¸æ¢å¤"
  echo "  7) ç½‘ç»œè¯Šæ–­ä¸ä¼˜åŒ–"
  echo "  8) æ—¥å¿—åˆ†æå·¥å…·"
  echo "  9) è‡ªåŠ¨åŒ–è®¾ç½®"
  echo ""
  echo -e "${CYAN}========== å…¶ä»–é€‰é¡¹ ==========${RESET}"
  echo " 10) æŸ¥çœ‹å¸®åŠ©ä¿¡æ¯"
  echo " 11) å…³äºæœ¬å·¥å…·"
  echo "  0) é€€å‡º"
  echo ""
  read -p "è¯·è¾“å…¥ç¼–å·: " choice
  
  case "$choice" in
    1) setup_all ;;
    2) wallet_management ;;
    3) node_control ;;
    4) config_manager ;;
    5) advanced_features ;;
    6) backup_management ;;
    7) network_features ;;
    8) advanced_log_analysis ;;
    9) automation_setup ;;
    10) show_help ;;
    11) show_about ;;
    0) echo "é€€å‡ºè„šæœ¬."; exit 0 ;;
    "auto_backup_task") auto_backup_task ;;
    "log_rotation_task") log_rotation_task ;;
    *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹${RESET}"; pause_and_return ;;
  esac
}

function show_help() {
  echo -e "${CYAN}========== å¸®åŠ©ä¿¡æ¯ ==========${RESET}"
  echo "æœ¬å·¥å…·æ˜¯ Nockchain èŠ‚ç‚¹çš„é«˜çº§ç®¡ç†åŠ©æ‰‹ï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š"
  echo ""
  echo -e "${BOLD}åŸºç¡€åŠŸèƒ½:${RESET}"
  echo "â€¢ ä¸€é”®å®‰è£…: è‡ªåŠ¨å®‰è£…æ‰€æœ‰ä¾èµ–å’Œç¼–è¯‘èŠ‚ç‚¹"
  echo "â€¢ é’±åŒ…ç®¡ç†: ç”Ÿæˆã€å¯¼å…¥ã€å¯¼å‡ºé’±åŒ…å¯†é’¥"
  echo "â€¢ èŠ‚ç‚¹æ§åˆ¶: å¯åŠ¨ã€åœæ­¢ã€é‡å¯èŠ‚ç‚¹æœåŠ¡"
  echo "â€¢ é…ç½®ç®¡ç†: åˆ›å»ºå’Œç®¡ç†ä¸åŒç½‘ç»œçš„é…ç½®"
  echo ""
  echo -e "${BOLD}é«˜çº§åŠŸèƒ½:${RESET}"
  echo "â€¢ ç³»ç»Ÿç›‘æ§: å®æ—¶ç›‘æ§ç³»ç»Ÿæ€§èƒ½å’ŒèŠ‚ç‚¹çŠ¶æ€"
  echo "â€¢ æ™ºèƒ½è¯Šæ–­: è‡ªåŠ¨æ£€æµ‹å’Œä¿®å¤å¸¸è§é—®é¢˜"
  echo "â€¢ å¤‡ä»½æ¢å¤: è‡ªåŠ¨å¤‡ä»½é‡è¦æ•°æ®å’Œé…ç½®"
  echo "â€¢ ç½‘ç»œä¼˜åŒ–: è¯Šæ–­å’Œä¼˜åŒ–ç½‘ç»œè¿æ¥"
  echo "â€¢ æ—¥å¿—åˆ†æ: æ·±åº¦åˆ†æèŠ‚ç‚¹è¿è¡Œæ—¥å¿—"
  echo "â€¢ è‡ªåŠ¨åŒ–: è®¾ç½®å¼€æœºè‡ªå¯ã€å®šæ—¶å¤‡ä»½ç­‰"
  echo ""
  echo -e "${BOLD}å¸¸ç”¨å¿«æ·é”®:${RESET}"
  echo "â€¢ Screenä¼šè¯: Ctrl+A+D é€€å‡ºä¼šè¯"
  echo "â€¢ æŸ¥çœ‹æ—¥å¿—: screen -r nockchain"
  echo "â€¢ å¼ºåˆ¶é€€å‡º: Ctrl+C"
  echo ""
  echo -e "${BOLD}é‡è¦æ–‡ä»¶ä½ç½®:${RESET}"
  echo "â€¢ é¡¹ç›®ç›®å½•: $NCK_DIR"
  echo "â€¢ é…ç½®æ–‡ä»¶: $ENV_FILE"
  echo "â€¢ é’±åŒ…æ•°æ®: $HOME/.nockchain"
  echo "â€¢ å¤‡ä»½ç›®å½•: $BACKUP_DIR"
  
  pause_and_return
}

function show_about() {
  echo -e "${CYAN}========== å…³äºæœ¬å·¥å…· ==========${RESET}"
  echo -e "${BOLD}Nockchain é«˜çº§ç®¡ç†åŠ©æ‰‹ v2.0${RESET}"
  echo ""
  echo "ä½œè€…: K2 èŠ‚ç‚¹æ•™ç¨‹åˆ†äº«"
  echo "Telegram: https://t.me/+EaCiFDOghoM3Yzll"
  echo "Twitter: https://x.com/BtcK241918"
  echo ""
  echo "ç‰ˆæœ¬ç‰¹æ€§:"
  echo "â€¢ å²è¯—çº§åŠŸèƒ½é›†æˆ"
  echo "â€¢ æ™ºèƒ½æ•…éšœè¯Šæ–­"
  echo "â€¢ è‡ªåŠ¨åŒ–è¿ç»´"
  echo "â€¢ é«˜çº§ç›‘æ§åˆ†æ"
  echo "â€¢ å¤šå¹³å°å…¼å®¹"
  echo ""
  echo "æ›´æ–°æ—¥å¿—:"
  echo "v2.0 - å…¨é¢é‡æ„ï¼Œæ·»åŠ é«˜çº§åŠŸèƒ½"
  echo "v1.0 - åŸºç¡€å®‰è£…å’Œç®¡ç†åŠŸèƒ½"
  echo ""
  echo "åé¦ˆä¸å»ºè®®è¯·è”ç³»ä½œè€…"
  
  pause_and_return
}

# ========= è„šæœ¬å…¥å£ =========
# åˆå§‹åŒ–
detect_system

# æ£€æŸ¥ç‰¹æ®Šå‚æ•°
case "${1:-}" in
  "auto_backup_task") auto_backup_task; exit 0 ;;
  "log_rotation_task") log_rotation_task; exit 0 ;;
  *) main_menu ;;
esac
