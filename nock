#!/bin/bash

# Nockchain 节点管理脚本 - 精简菜单版
# 版本：5.0 保留核心功能菜单版
# 保留功能：安装、更改挖矿公钥、启动节点、日志查看

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 配置常量
NOCKCHAIN_REPO="https://github.com/zorp-corp/nockchain.git"
ENV_FILE=".env"
ENV_EXAMPLE=".env_example"
LOG_FILE="nockchain.log"
BACKUP_DIR="backups"

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${CYAN}[DEBUG]${NC} $1"
}

log_success() {
    echo -e "${PURPLE}[SUCCESS]${NC} $1"
}

# 检查项目根目录
check_project_root() {
    local current_dir=$(pwd)
    log_debug "当前目录: $current_dir"
    
    if [ -f "Cargo.toml" ] || [ -f "Makefile" ]; then
        if [ -f "Cargo.toml" ] && grep -q "nockchain" "Cargo.toml" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        elif [ -f "Makefile" ] && grep -q "nockchain\|hoonc" "Makefile" 2>/dev/null; then
            log_success "检测到 Nockchain 项目根目录"
            return 0
        fi
    fi
    
    return 1
}

# 自动查找 nockchain 目录
find_nockchain_directory() {
    log_info "正在查找 nockchain 项目目录..."
    
    local found_dirs=($(find . -maxdepth 3 -name "nockchain" -type d 2>/dev/null))
    
    if [ ${#found_dirs[@]} -gt 0 ]; then
        for dir in "${found_dirs[@]}"; do
            if [ -f "$dir/Cargo.toml" ] || [ -f "$dir/Makefile" ]; then
                log_success "找到 nockchain 项目目录: $dir"
                cd "$dir"
                return 0
            fi
        done
    fi
    
    local parent_dirs=("../nockchain" "../../nockchain" "~/nockchain")
    for dir in "${parent_dirs[@]}"; do
        if [ -d "$dir" ] && ([ -f "$dir/Cargo.toml" ] || [ -f "$dir/Makefile" ]); then
            log_success "找到 nockchain 项目目录: $dir"
            cd "$dir"
            return 0
        fi
    done
    
    return 1
}

# 自动初始化项目
auto_initialize_project() {
    log_warn "未找到 nockchain 项目，将自动初始化..."
    
    read -p "是否自动克隆 nockchain 项目？(y/n): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local target_dir="nockchain_$(date +%Y%m%d_%H%M%S)"
        
        log_info "正在克隆 nockchain 项目到: $target_dir"
        
        if git clone "$NOCKCHAIN_REPO" "$target_dir"; then
            cd "$target_dir"
            log_success "项目克隆成功，已切换到项目目录"
            return 0
        else
            log_error "项目克隆失败"
            return 1
        fi
    else
        log_error "请手动进入 nockchain 项目根目录后重新运行脚本"
        exit 1
    fi
}

# 智能目录检测和初始化
smart_directory_setup() {
    log_info "开始智能目录检测..."
    
    if check_project_root; then
        return 0
    fi
    
    log_warn "当前目录不是 nockchain 项目根目录"
    
    if find_nockchain_directory; then
        if check_project_root; then
            return 0
        fi
    fi
    
    auto_initialize_project
}

# 安装系统依赖
install_system_dependencies() {
    log_info "正在安装系统依赖..."
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        sudo apt update
        
        local apt_packages=(
            "curl" "git" "build-essential" "make" "gcc" "clang"
            "pkg-config" "libssl-dev" "libclang-dev" "llvm-dev"
            "libleveldb-dev" "cmake" "autoconf" "automake"
            "libtool" "wget" "unzip" "jq"
        )
        
        sudo apt install -y "${apt_packages[@]}"
        log_success "系统依赖安装完成"
    fi
    
    # 安装 Rust
    if ! command -v rustc &> /dev/null || ! command -v cargo &> /dev/null; then
        log_info "安装 Rust..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        source $HOME/.cargo/env
        log_success "Rust 安装完成"
    else
        log_info "Rust 已安装：$(rustc --version)"
    fi
}

# 初始化环境配置
initialize_environment() {
    log_info "初始化环境配置..."
    
    if [ -f "$HOME/.cargo/env" ]; then
        source "$HOME/.cargo/env"
    fi
    export PATH="$HOME/.cargo/bin:$PATH"
    
    if [ ! -f "$ENV_FILE" ]; then
        if [ -f "$ENV_EXAMPLE" ]; then
            cp "$ENV_EXAMPLE" "$ENV_FILE"
            log_success "已从 .env_example 创建 .env 文件"
        else
            log_info "创建默认 .env 文件"
            cat > "$ENV_FILE" << 'EOF'
RUST_LOG=info,nockchain=info,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info
MINIMAL_LOG_FORMAT=true
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
EOF
        fi
    fi
    
    [ ! -d "$BACKUP_DIR" ] && mkdir -p "$BACKUP_DIR"
}

# 验证128位16进制挖矿公钥格式
validate_mining_pubkey() {
    local pubkey="$1"
    
    # 检查是否为128个十六进制字符（128位16进制）
    if [[ ! "$pubkey" =~ ^[0-9a-fA-F]{128}$ ]]; then
        log_error "无效的挖矿公钥格式"
        log_error "挖矿公钥必须是128位16进制格式（128个十六进制字符）"
        log_error "示例格式: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        return 1
    fi
    
    return 0
}

# 功能1：完整安装 Nockchain
install_nockchain_complete() {
    log_info "开始完整安装 Nockchain..."
    
    # 检查系统资源
    local total_mem=$(free -g | awk '/^Mem:/{print $2}')
    log_info "系统内存: ${total_mem}GB"
    
    local disk_space=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
    log_info "可用磁盘空间: ${disk_space}GB"
    
    local cpu_cores=$(nproc)
    log_info "CPU核心数: ${cpu_cores}核"
    
    # 安装依赖
    install_system_dependencies
    initialize_environment
    
    # 设置环境
    source $HOME/.cargo/env 2>/dev/null || true
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 安装 Hoon 编译器
    log_info "安装 Hoon 编译器..."
    if timeout 300 make install-hoonc; then
        log_success "Hoon 编译器安装成功"
    else
        log_error "Hoon 编译器安装失败"
        return 1
    fi
    
    # 构建项目
    log_info "构建 Nockchain 项目（这可能需要较长时间）..."
    if timeout 600 make build; then
        log_success "项目构建成功"
    else
        log_error "项目构建失败"
        return 1
    fi
    
    # 安装组件
    log_info "安装 Nockchain 组件..."
    
    if make install-nockchain-wallet; then
        log_success "Nockchain 钱包安装成功"
    else
        log_error "Nockchain 钱包安装失败"
        return 1
    fi
    
    if make install-nockchain; then
        log_success "Nockchain 节点安装成功"
    else
        log_error "Nockchain 节点安装失败"
        return 1
    fi
    
    # 更新 PATH
    if ! grep -q 'export PATH="$HOME/.cargo/bin:$PATH"' ~/.bashrc; then
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
        log_success "已添加 Cargo bin 目录到 PATH"
    fi
    
    # 生成默认的128位挖矿公钥
    log_info "生成128位16进制挖矿公钥..."
    local hex_pubkey
    if command -v openssl &> /dev/null; then
        hex_pubkey=$(openssl rand -hex 64)
    else
        hex_pubkey=$(xxd -l 64 -p /dev/urandom | tr -d '\n')
    fi
    
    # 更新配置文件
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "${ENV_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$hex_pubkey/" "$ENV_FILE"
        log_success "已生成并设置128位挖矿公钥: $hex_pubkey"
    fi
    
    log_success "Nockchain 完整安装成功！"
}

# 功能2：更改挖矿公钥（128位16进制格式）
change_mining_pubkey() {
    log_info "更改挖矿公钥（128位16进制格式）"
    echo
    log_info "请输入128位16进制格式的挖矿公钥（128个十六进制字符）"
    log_debug "格式示例: 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    echo
    
    while true; do
        read -p "挖矿公钥 (128位16进制): " new_pubkey
        
        if [ -z "$new_pubkey" ]; then
            log_error "公钥不能为空"
            continue
        fi
        
        # 验证128位16进制格式
        if validate_mining_pubkey "$new_pubkey"; then
            if [ -f "$ENV_FILE" ]; then
                # 创建备份
                cp "$ENV_FILE" "$BACKUP_DIR/.env.backup.$(date +%Y%m%d_%H%M%S)"
                
                # 更新公钥
                if grep -q "MINING_PUBKEY=" "$ENV_FILE"; then
                    sed -i "s/^MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" "$ENV_FILE"
                else
                    echo "MINING_PUBKEY=$new_pubkey" >> "$ENV_FILE"
                fi
                
                log_success "挖矿公钥已更新"
                log_info "新公钥: $new_pubkey"
                log_info "配置已备份到 $BACKUP_DIR/"
                break
            else
                log_error ".env 文件不存在，请先运行安装选项"
                break
            fi
        else
            log_error "请输入正确格式的128位16进制公钥（128个十六进制字符）"
        fi
    done
}

# 功能3：启动节点
start_node() {
    log_info "启动 Nockchain 挖矿节点"
    
    # 检查必要条件
    if ! command -v nockchain &> /dev/null; then
        log_error "nockchain 未安装，请先运行安装选项"
        return 1
    fi
    
    if [ ! -f "$ENV_FILE" ]; then
        log_error ".env 文件不存在，请先运行安装选项"
        return 1
    fi
    
    # 加载环境变量
    source "$ENV_FILE"
    export RUST_LOG MINIMAL_LOG_FORMAT MINING_PUBKEY
    
    # 验证挖矿公钥格式
    if ! validate_mining_pubkey "$MINING_PUBKEY" 2>/dev/null; then
        log_error "当前配置的挖矿公钥格式不正确"
        log_error "请先使用 '更改挖矿公钥' 选项设置正确的128位16进制公钥"
        return 1
    fi
    
    # 检查现有进程
    if pgrep -f "nockchain" > /dev/null; then
        local existing_pids=$(pgrep -f nockchain | tr '\n' ' ')
        log_warn "检测到运行中的 Nockchain 进程: $existing_pids"
        
        read -p "是否停止现有进程并重新启动？(y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "停止现有进程..."
            pkill -TERM -f nockchain 2>/dev/null || true
            sleep 3
            if pgrep -f nockchain > /dev/null; then
                pkill -KILL -f nockchain 2>/dev/null || true
                sleep 2
            fi
            log_info "现有进程已停止"
        else
            log_info "保持现有进程运行"
            return 0
        fi
    fi
    
    log_info "配置信息："
    log_info "- 挖矿公钥: $MINING_PUBKEY"
    log_info "- 日志级别: $RUST_LOG"
    log_info "- 日志文件: $LOG_FILE"
    
    # 启动节点
    log_info "正在启动挖矿节点..."
    
    nohup nockchain --mining-pubkey "${MINING_PUBKEY}" --mine > "$LOG_FILE" 2>&1 &
    local node_pid=$!
    
    # 等待启动
    sleep 5
    
    # 验证启动状态
    if kill -0 $node_pid 2>/dev/null; then
        log_success "节点启动成功！"
        log_success "进程ID: $node_pid"
        log_info "日志文件: $LOG_FILE"
        
        # 显示初始日志
        if [ -f "$LOG_FILE" ]; then
            log_info "最近几行日志："
            tail -n 5 "$LOG_FILE" 2>/dev/null || true
        fi
        
        log_info "使用 '查看日志' 选项监控节点状态"
    else
        log_error "节点启动失败"
        if [ -f "$LOG_FILE" ]; then
            log_error "错误日志："
            tail -n 10 "$LOG_FILE"
        fi
        return 1
    fi
}

# 功能4：查看日志
view_logs() {
    log_info "查看 Nockchain 节点日志"
    
    if [ ! -f "$LOG_FILE" ]; then
        log_warn "日志文件不存在: $LOG_FILE"
        
        # 检查进程状态
        if pgrep -f "nockchain" > /dev/null; then
            log_info "节点正在运行，但日志文件不存在"
            log_info "建议重启节点以生成日志文件"
        else
            log_info "节点未运行"
        fi
        return 1
    fi
    
    echo
    log_info "=== 日志文件信息 ==="
    echo "文件位置: $(realpath $LOG_FILE)"
    echo "文件大小: $(du -h "$LOG_FILE" | cut -f1)"
    echo "最后修改: $(stat -c %y "$LOG_FILE" 2>/dev/null || date -r "$LOG_FILE" 2>/dev/null)"
    
    echo
    log_info "=== 最近50行日志 ==="
    echo
    tail -n 50 "$LOG_FILE"
    
    echo
    log_info "=== 实时日志监控 ==="
    log_info "按 Ctrl+C 退出监控"
    echo
    
    # 实时监控日志
    tail -f "$LOG_FILE"
}

# 主菜单显示
show_main_menu() {
    clear
    echo -e "${PURPLE}"
    echo "╔════════════════════════════════════════════════════════════════╗"
    echo "║                 Nockchain 节点管理工具                        ║"
    echo "║               （核心功能菜单版 v5.0）                         ║"
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    echo
    echo -e "${GREEN}🔧 核心功能菜单${NC}"
    echo "────────────────────────────────────────────────────────────────"
    echo "  1. 安装 Nockchain（完整安装流程）"
    echo "  2. 更改挖矿公钥（128位16进制格式）"
    echo "  3. 启动挖矿节点"
    echo "  4. 查看节点日志"
    echo
    echo "  0. 退出"
    echo
    echo -e "${YELLOW}📋 重要说明：${NC}"
    echo -e "${YELLOW}• 挖矿公钥必须是128位16进制格式（128个十六进制字符）${NC}"
    echo -e "${YELLOW}• 首次使用请先选择 '1. 安装 Nockchain'${NC}"
    echo -e "${YELLOW}• 启动节点前请确保已正确设置挖矿公钥${NC}"
    echo
    
    # 显示当前状态
    if [ -f "$ENV_FILE" ]; then
        local current_pubkey=$(grep "MINING_PUBKEY=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$current_pubkey" ] && [ "$current_pubkey" != "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" ]; then
            echo -e "${CYAN}📍 当前挖矿公钥: ${current_pubkey:0:20}...${current_pubkey: -20}${NC}"
        else
            echo -e "${CYAN}📍 当前挖矿公钥: 未设置或使用默认值${NC}"
        fi
    fi
    
    if pgrep -f "nockchain" > /dev/null; then
        echo -e "${CYAN}📍 节点状态: ✅ 运行中 (PID: $(pgrep -f nockchain | tr '\n' ' '))${NC}"
    else
        echo -e "${CYAN}📍 节点状态: ❌ 未运行${NC}"
    fi
    echo
}

# 主程序
main() {
    # 启动时进行智能目录检测
    log_info "Nockchain 节点管理工具启动中..."
    
    if ! smart_directory_setup; then
        log_error "无法初始化项目环境"
        exit 1
    fi
    
    # 主循环
    while true; do
        show_main_menu
        read -p "请选择操作 (0-4): " choice
        
        case $choice in
            1)
                install_nockchain_complete
                read -p "按回车键继续..."
                ;;
            2)
                change_mining_pubkey
                read -p "按回车键继续..."
                ;;
            3)
                start_node
                read -p "按回车键继续..."
                ;;
            4)
                view_logs
                ;;
            0)
                log_info "感谢使用 Nockchain 节点管理工具！"
                log_info "祝您挖矿愉快 🚀"
                exit 0
                ;;
            *)
                log_error "无效选择，请输入 0-4 之间的数字"
                sleep 2
                ;;
        esac
    done
}

# 脚本入口
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # 设置错误处理
    set -eE
    trap 'log_error "脚本在第 $LINENO 行出错"' ERR
    
    # 启动主程序
    main "$@"
fi
