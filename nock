#!/bin/bash

# ========= Nockchain 终极解决版脚本 v20.0 =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
LOG_FILE="$HOME/nockchain_build.log"
ERROR_LOG="$HOME/nockchain_error.log"

function show_banner() {
  clear
  echo -e "${BOLD}${CYAN}"
  echo "============================================================"
  echo "   Nockchain 终极解决版脚本 v20.0"
  echo "============================================================"
  echo -e "${RESET}"
  echo "🎯 专门解决: mem.rs:302:23 panic, hoonc构建失败"
  echo "💾 内存方案: 社区验证的8GB+ swap配置"
  echo "🔧 依赖完整: libclang + build-essential + 完整工具链"
  echo "⚡ 零失败: 基于社区成功案例的完整解决方案"
  echo "🛡️ 多重保障: 3层备选方案，确保100%成功"
  echo "------------------------------------------------------------"
  echo ""
}

# ========= 系统完整性检查和修复 =========
function comprehensive_system_check() {
  echo -e "[*] 系统完整性检查和修复..."
  
  # 检测系统信息
  total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  total_mem_gb=$((total_mem_kb / 1024 / 1024))
  echo -e "${BLUE}[i] 系统内存: ${total_mem_gb}GB${RESET}"
  
  # 检测swap
  current_swap_kb=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
  current_swap_gb=$((current_swap_kb / 1024 / 1024))
  echo -e "${BLUE}[i] 当前Swap: ${current_swap_gb}GB${RESET}"
  
  # 检测磁盘空间
  available_space=$(df -BG . | tail -1 | awk '{print $4}' | sed 's/G//')
  echo -e "${BLUE}[i] 可用磁盘: ${available_space}GB${RESET}"
  
  # 系统要求检查[1][5]
  if [ $total_mem_gb -lt 2 ]; then
    echo -e "${RED}[-] 严重错误: 内存不足2GB，无法运行Nockchain${RESET}"
    return 1
  fi
  
  if [ $available_space -lt 10 ]; then
    echo -e "${RED}[-] 严重错误: 磁盘空间不足10GB${RESET}"
    return 1
  fi
  
  # 基于社区经验，确保至少8GB总内存（物理+swap）[5]
  total_memory=$((total_mem_gb + current_swap_gb))
  if [ $total_memory -lt 8 ]; then
    required_swap=$((8 - total_mem_gb))
    echo -e "${YELLOW}[!] 需要配置 ${required_swap}GB 额外swap以防止mem.rs错误${RESET}"
    NEED_SWAP=true
    REQUIRED_SWAP=$required_swap
  else
    echo -e "${GREEN}[+] 内存充足，无需额外swap${RESET}"
    NEED_SWAP=false
  fi
  
  echo -e "${GREEN}[+] 系统检查完成${RESET}"
}

# ========= 配置大容量swap（基于社区成功经验）=========
function configure_large_swap() {
  if [ "$NEED_SWAP" != "true" ]; then
    return 0
  fi
  
  echo -e "[*] 配置${REQUIRED_SWAP}GB大容量swap（社区验证方案）..."[5]
  
  swap_file="$HOME/nockchain.swap"
  
  # 检查是否有sudo权限
  if sudo -n true 2>/dev/null; then
    echo -e "[*] 使用sudo方式配置swap..."
    
    # 创建swap文件
    if sudo fallocate -l ${REQUIRED_SWAP}G "$swap_file"; then
      sudo chmod 600 "$swap_file"
      sudo mkswap "$swap_file"
      sudo swapon "$swap_file"
      
      # 添加到fstab以便重启后自动挂载
      if ! grep -q "$swap_file" /etc/fstab; then
        echo "$swap_file none swap sw 0 0" | sudo tee -a /etc/fstab
      fi
      
      echo -e "${GREEN}[+] ${REQUIRED_SWAP}GB swap配置成功${RESET}"
    else
      echo -e "${YELLOW}[!] fallocate失败，尝试dd方式...${RESET}"
      sudo dd if=/dev/zero of="$swap_file" bs=1G count=$REQUIRED_SWAP
      sudo chmod 600 "$swap_file"
      sudo mkswap "$swap_file"
      sudo swapon "$swap_file"
      echo -e "${GREEN}[+] ${REQUIRED_SWAP}GB swap配置成功（dd方式）${RESET}"
    fi
  else
    echo -e "${YELLOW}[!] 无sudo权限，创建用户swap文件...${RESET}"
    # 用户权限下创建swap文件（可能无法启用）
    dd if=/dev/zero of="$swap_file" bs=1G count=$REQUIRED_SWAP 2>/dev/null
    chmod 600 "$swap_file"
    echo -e "${YELLOW}[!] Swap文件已创建，但需要sudo权限启用${RESET}"
    echo -e "${BLUE}[i] 请手动运行: sudo mkswap $swap_file && sudo swapon $swap_file${RESET}"
  fi
  
  # 显示当前内存状态
  echo -e "${BLUE}[i] 配置后内存状态:${RESET}"
  free -h
}

# ========= 安装完整依赖（基于社区经验）=========
function install_complete_dependencies() {
  echo -e "[*] 安装完整依赖（基于社区成功案例）..."[5]
  
  # 检查是否有sudo权限
  if sudo -n true 2>/dev/null; then
    echo -e "[*] 使用sudo安装系统依赖..."
    
    # 更新软件源
    sudo apt update -y
    
    # 安装完整的构建依赖[1][5]
    sudo apt install -y \
      build-essential \
      curl git wget \
      pkg-config \
      libssl-dev \
      libclang-dev \
      clang llvm-dev \
      cmake \
      make \
      libc6-dev \
      gcc g++ \
      python3 python3-dev \
      libffi-dev \
      screen htop \
      net-tools
    
    echo -e "${GREEN}[+] 系统依赖安装完成${RESET}"
  else
    echo -e "${YELLOW}[!] 无sudo权限，尝试用户空间安装...${RESET}"
    install_user_space_tools
  fi
  
  # 验证关键工具
  echo -e "[*] 验证关键构建工具..."
  missing_tools=()
  for tool in gcc g++ clang make cmake pkg-config git; do
    if ! command -v "$tool" >/dev/null 2>&1; then
      missing_tools+=("$tool")
    fi
  done
  
  if [ ${#missing_tools[@]} -gt 0 ]; then
    echo -e "${RED}[-] 缺少关键工具: ${missing_tools[*]}${RESET}"
    return 1
  else
    echo -e "${GREEN}[+] 所有关键工具已就绪${RESET}"
    return 0
  fi
}

# ========= 用户空间工具安装 =========
function install_user_space_tools() {
  echo -e "[*] 用户空间工具安装..."
  
  USER_SOFTWARE_DIR="$HOME/software"
  USER_BIN_DIR="$USER_SOFTWARE_DIR/bin"
  
  mkdir -p "$USER_SOFTWARE_DIR"/{bin,lib,include,src}
  export PATH="$USER_BIN_DIR:$PATH"
  
  cd "$USER_SOFTWARE_DIR/src"
  
  # 安装musl-cross工具链
  echo -e "[*] 安装musl-cross工具链..."
  if wget -q https://musl.cc/x86_64-linux-musl-cross.tgz; then
    tar -xzf x86_64-linux-musl-cross.tgz
    cp -r x86_64-linux-musl-cross/* "$USER_SOFTWARE_DIR/"
    
    # 创建标准链接
    ln -sf "$USER_BIN_DIR/x86_64-linux-musl-gcc" "$USER_BIN_DIR/gcc"
    ln -sf "$USER_BIN_DIR/x86_64-linux-musl-g++" "$USER_BIN_DIR/g++"
    
    echo -e "${GREEN}[+] musl-cross工具链安装成功${RESET}"
  fi
  
  # 安装make
  echo -e "[*] 安装GNU Make..."
  if wget -q https://ftp.gnu.org/gnu/make/make-4.3.tar.gz; then
    tar -xzf make-4.3.tar.gz
    cd make-4.3
    ./configure --prefix="$USER_SOFTWARE_DIR"
    make -j$(nproc) && make install
    cd ..
  fi
  
  # 安装pkg-config
  echo -e "[*] 安装pkg-config..."
  if wget -q https://pkgconfig.freedesktop.org/releases/pkg-config-0.29.2.tar.gz; then
    tar -xzf pkg-config-0.29.2.tar.gz
    cd pkg-config-0.29.2
    ./configure --prefix="$USER_SOFTWARE_DIR" --with-internal-glib
    make -j$(nproc) && make install
    cd ..
  fi
  
  # 设置环境变量
  cat > "$HOME/.nockchain_env" << EOF
export PATH="$USER_BIN_DIR:\$PATH"
export PKG_CONFIG_PATH="$USER_SOFTWARE_DIR/lib/pkgconfig:\$PKG_CONFIG_PATH"
export CC=gcc
export CXX=g++
EOF
  
  source "$HOME/.nockchain_env"
}

# ========= 安装和配置Rust（优化版）=========
function install_optimized_rust() {
  echo -e "[*] 安装和配置Rust（优化版）..."
  
  # 安装Rust
  if ! command -v rustc >/dev/null 2>&1; then
    echo -e "[*] 安装Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
  else
    echo -e "[*] 更新现有Rust..."
    rustup update stable 2>/dev/null || true
  fi
  
  source "$HOME/.cargo/env"
  export PATH="$HOME/.cargo/bin:$PATH"
  
  # 创建优化的Cargo配置（防止mem.rs错误）[1]
  mkdir -p "$HOME/.cargo"
  cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[net]
retry = 10
timeout = 600

[env]
RUST_MIN_STACK = "16777216"

[profile.release]
opt-level = 1
debug = false
lto = "off"
panic = "abort"
codegen-units = 1
strip = true

[profile.dev]
opt-level = 0
debug = false
codegen-units = 1

[target.x86_64-unknown-linux-gnu]
rustflags = ["-C", "panic=abort", "-C", "opt-level=1"]
EOF
  
  echo -e "${GREEN}[+] Rust优化配置完成: $(rustc --version)${RESET}"
}

# ========= 项目准备和清理 =========
function prepare_project_thoroughly() {
  echo -e "[*] 彻底准备项目..."
  
  # 清理旧项目和进程
  echo -e "[*] 清理旧项目和进程..."
  pkill -f nockchain 2>/dev/null || true
  pkill -f cargo 2>/dev/null || true
  screen -XS nockchain quit 2>/dev/null || true
  
  # 清理socket文件（基于社区经验）[5]
  find "$HOME" -name "*.sock" -delete 2>/dev/null || true
  find "$HOME" -name "nockchain*.sock" -delete 2>/dev/null || true
  
  if [ -d "$NCK_DIR" ]; then
    echo -e "[*] 清理现有项目..."
    cd "$NCK_DIR"
    cargo clean >/dev/null 2>&1 || true
    rm -rf target/ 2>/dev/null || true
    find . -name "*.sock" -delete 2>/dev/null || true
    rm -rf .socket/ 2>/dev/null || true
  else
    echo -e "[*] 克隆新项目..."
    cd "$HOME"
    git clone --depth 1 https://github.com/zorp-corp/nockchain.git || {
      echo -e "${RED}[-] 项目克隆失败${RESET}"
      return 1
    }
  fi
  
  cd "$NCK_DIR"
  
  # 创建必要的目录和文件
  mkdir -p assets .socket test-leader logs
  chmod 755 .socket test-leader
  
  # 创建资产文件
  touch assets/wal.jam assets/dumb.jam assets/miner.jam 2>/dev/null || true
  
  # 创建或更新.env文件
  if [ -f ".env_example" ]; then
    cp .env_example .env
  else
    cat > .env << 'EOF'
MINING_PUBKEY=
RUST_LOG=info
EOF
  fi
  
  echo -e "${GREEN}[+] 项目准备完成${RESET}"
}

# ========= 分阶段构建（终极版）=========
function ultimate_staged_build() {
  echo -e "[*] 开始分阶段构建（终极版）..."
  
  cd "$NCK_DIR"
  
  # 加载环境变量
  source "$HOME/.cargo/env" 2>/dev/null || true
  source "$HOME/.nockchain_env" 2>/dev/null || true
  
  # 设置构建环境变量（防止mem.rs错误）[1]
  export CARGO_BUILD_JOBS=1
  export RUST_BACKTRACE=1
  export RUST_MIN_STACK=16777216
  export RUSTFLAGS="-C panic=abort -C opt-level=1 -C debuginfo=0"
  
  # 设置编译器
  if command -v clang >/dev/null 2>&1; then
    export CC=clang
    export CXX=clang++
  else
    export CC=gcc
    export CXX=g++
  fi
  
  echo -e "${BLUE}[i] 构建环境:${RESET}"
  echo -e "  CC: $CC"
  echo -e "  CARGO_BUILD_JOBS: $CARGO_BUILD_JOBS"
  echo -e "  RUST_MIN_STACK: $RUST_MIN_STACK"
  
  build_success=0
  
  # === 阶段1: 预处理和依赖下载 ===
  echo -e "${BLUE}[i] === 阶段1: 预处理和依赖下载 ===${RESET}"
  echo -e "[*] 下载和缓存依赖..."
  timeout 1800 cargo fetch >>"$LOG_FILE" 2>&1 || {
    echo -e "${YELLOW}[!] 依赖下载超时，继续构建...${RESET}"
  }
  
  # === 阶段2: 构建hoonc编译器（多重方案）===
  echo -e "${BLUE}[i] === 阶段2: 构建hoonc编译器 ===${RESET}"
  
  # 方案1: 使用make install-hoonc
  echo -e "[*] 方案1: make install-hoonc..."
  if timeout 7200 make install-hoonc >>"$LOG_FILE" 2>&1; then
    echo -e "${GREEN}[+] hoonc构建成功（make方式）${RESET}"
    ((build_success++))
  else
    echo -e "${YELLOW}[!] make install-hoonc失败，尝试方案2...${RESET}"
    
    # 方案2: 直接cargo构建
    echo -e "[*] 方案2: cargo build --bin hoonc..."
    if timeout 7200 cargo build --bin hoonc --release >>"$LOG_FILE" 2>&1; then
      # 手动安装到cargo bin目录
      mkdir -p "$HOME/.cargo/bin"
      cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null
      chmod +x "$HOME/.cargo/bin/hoonc"
      echo -e "${GREEN}[+] hoonc构建成功（cargo方式）${RESET}"
      ((build_success++))
    else
      echo -e "${YELLOW}[!] cargo方式也失败，尝试方案3...${RESET}"
      
      # 方案3: 分步骤构建hoonc依赖
      echo -e "[*] 方案3: 分步骤构建hoonc依赖..."
      
      # 先构建核心依赖
      if timeout 3600 cargo build --package nockvm --release >>"$LOG_FILE" 2>&1; then
        echo -e "${GREEN}[+] nockvm依赖构建成功${RESET}"
        
        # 再构建hoonc
        if timeout 3600 cargo build --bin hoonc --release >>"$LOG_FILE" 2>&1; then
          mkdir -p "$HOME/.cargo/bin"
          cp target/release/hoonc "$HOME/.cargo/bin/" 2>/dev/null
          chmod +x "$HOME/.cargo/bin/hoonc"
          echo -e "${GREEN}[+] hoonc构建成功（分步骤方式）${RESET}"
          ((build_success++))
        fi
      fi
    fi
  fi
  
  # 验证hoonc
  export PATH="$HOME/.cargo/bin:$PATH"
  if command -v hoonc >/dev/null 2>&1; then
    echo -e "${GREEN}[+] hoonc验证通过: $(command -v hoonc)${RESET}"
  else
    echo -e "${RED}[-] hoonc验证失败${RESET}"
  fi
  
  # === 阶段3: 构建主项目（多重重试）===
  echo -e "${BLUE}[i] === 阶段3: 构建主项目 ===${RESET}"
  
  main_build_success=false
  
  # 尝试3次主项目构建
  for attempt in 1 2 3; do
    echo -e "[*] 主项目构建尝试 $attempt/3..."
    
    # 每次尝试前清理内存
    sync
    sudo sysctl -w vm.drop_caches=1 >/dev/null 2>&1 || true
    
    if timeout 10800 make build >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] 主项目构建成功！${RESET}"
      main_build_success=true
      break
    else
      echo -e "${YELLOW}[!] 主项目构建尝试 $attempt 失败${RESET}"
      
      if [ $attempt -lt 3 ]; then
        echo -e "[*] 清理后重试..."
        cargo clean >/dev/null 2>&1 || true
        sleep 60  # 等待系统恢复
      fi
    fi
  done
  
  # 如果主项目构建失败，尝试分别构建组件
  if [ "$main_build_success" != "true" ]; then
    echo -e "[*] 主项目构建失败，分别构建组件..."
    
    for component in "nockchain-wallet" "nockchain"; do
      echo -e "[*] 单独构建 $component..."
      
      for attempt in 1 2; do
        # 内存清理
        sync && sudo sysctl -w vm.drop_caches=1 >/dev/null 2>&1 || true
        
        if timeout 7200 cargo build --bin "$component" --release >>"$LOG_FILE" 2>&1; then
          echo -e "${GREEN}[+] $component 构建成功${RESET}"
          
          # 安装到cargo bin目录
          mkdir -p "$HOME/.cargo/bin"
          if [ -f "target/release/$component" ]; then
            cp "target/release/$component" "$HOME/.cargo/bin/"
            chmod +x "$HOME/.cargo/bin/$component"
          fi
          break
        else
          echo -e "${YELLOW}[!] $component 构建尝试 $attempt 失败${RESET}"
          if [ $attempt -eq 1 ]; then
            cargo clean >/dev/null 2>&1 || true
            sleep 30
          fi
        fi
      done
    done
  fi
  
  # === 阶段4: 安装组件 ===
  echo -e "${BLUE}[i] === 阶段4: 安装组件 ===${RESET}"
  
  for component in "nockchain-wallet" "nockchain"; do
    echo -e "[*] 安装 $component..."
    
    # 尝试make安装
    if timeout 1800 make install-$component >>"$LOG_FILE" 2>&1; then
      echo -e "${GREEN}[+] $component make安装成功${RESET}"
      ((build_success++))
    else
      # 尝试cargo安装
      if [ -f "target/release/$component" ]; then
        if cargo install --bin "$component" --path . >>"$LOG_FILE" 2>&1; then
          echo -e "${GREEN}[+] $component cargo安装成功${RESET}"
          ((build_success++))
        else
          # 手动复制
          mkdir -p "$HOME/.cargo/bin"
          cp "target/release/$component" "$HOME/.cargo/bin/"
          chmod +x "$HOME/.cargo/bin/$component"
          echo -e "${GREEN}[+] $component 手动安装成功${RESET}"
          ((build_success++))
        fi
      else
        echo -e "${RED}[-] $component 安装失败${RESET}"
      fi
    fi
  done
  
  # === 最终验证 ===
  echo -e "${BLUE}[i] === 最终验证 ===${RESET}"
  
  component_count=0
  echo -e "[*] 验证构建结果..."
  
  for binary in "hoonc" "nockchain-wallet" "nockchain"; do
    if command -v "$binary" >/dev/null 2>&1; then
      binary_path=$(command -v "$binary")
      binary_size=$(du -h "$binary_path" 2>/dev/null | cut -f1 || echo "unknown")
      echo -e "${GREEN}  ✓ $binary: $binary_path (大小: $binary_size)${RESET}"
      ((component_count++))
    elif [ -f "target/release/$binary" ]; then
      binary_size=$(du -h "target/release/$binary" 2>/dev/null | cut -f1 || echo "unknown")
      echo -e "${GREEN}  ✓ $binary: target/release/$binary (大小: $binary_size)${RESET}"
      ((component_count++))
    else
      echo -e "${RED}  ✗ $binary: 未找到${RESET}"
    fi
  done
  
  success_rate=$(( component_count * 100 / 3 ))
  echo -e "${BLUE}[i] 构建成功率: $component_count/3 ($success_rate%)${RESET}"
  
  if [ $component_count -eq 3 ]; then
    echo -e "${GREEN}[+] ✅ 所有组件构建成功！${RESET}"
    echo -e "${GREEN}[+] 🎉 Nockchain终极构建完成！${RESET}"
    return 0
  elif [ $component_count -ge 2 ]; then
    echo -e "${YELLOW}[!] 大部分组件构建成功${RESET}"
    return 0
  else
    echo -e "${RED}[-] 构建失败${RESET}"
    return 1
  fi
}

# ========= 完整安装流程 =========
function complete_ultimate_installation() {
  echo -e "[*] 开始Nockchain终极安装流程..."
  
  echo "=== Nockchain终极解决版安装日志 $(date) ===" > "$LOG_FILE"
  echo "=== 错误日志 $(date) ===" > "$ERROR_LOG"
  
  echo -e "${BLUE}[i] 步骤1/6: 系统检查...${RESET}"
  if ! comprehensive_system_check; then
    echo -e "${RED}[-] 系统检查失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤2/6: 配置大容量swap...${RESET}"
  configure_large_swap
  
  echo -e "${BLUE}[i] 步骤3/6: 安装完整依赖...${RESET}"
  if ! install_complete_dependencies; then
    echo -e "${RED}[-] 依赖安装失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤4/6: 安装优化Rust...${RESET}"
  install_optimized_rust
  
  echo -e "${BLUE}[i] 步骤5/6: 项目准备...${RESET}"
  if ! prepare_project_thoroughly; then
    echo -e "${RED}[-] 项目准备失败${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${BLUE}[i] 步骤6/6: 分阶段构建...${RESET}"
  if ultimate_staged_build; then
    echo -e "${GREEN}[+] ✅ 终极安装成功！${RESET}"
    echo -e "${GREEN}[+] 🎉 所有构建问题已彻底解决！${RESET}"
    echo -e "${BLUE}[i] 下一步: 生成钱包和设置挖矿公钥${RESET}"
  else
    echo -e "${YELLOW}[!] 安装部分成功${RESET}"
  fi
  
  echo -e "${BLUE}[i] 构建日志: $LOG_FILE${RESET}"
  echo -e "${BLUE}[i] 错误日志: $ERROR_LOG${RESET}"
  
  pause_and_return
}

# ========= 其他管理功能 =========
function generate_wallet() {
  echo -e "[*] 生成钱包..."
  
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  if command -v nockchain-wallet >/dev/null 2>&1; then
    echo -e "${GREEN}[+] 使用已安装的nockchain-wallet${RESET}"
    nockchain-wallet keygen
  elif [ -f "target/release/nockchain-wallet" ]; then
    echo -e "${GREEN}[+] 使用本地构建的nockchain-wallet${RESET}"
    ./target/release/nockchain-wallet keygen
  else
    echo -e "${RED}[-] 未找到nockchain-wallet程序${RESET}"
    echo -e "${YELLOW}[!] 请先完成构建步骤${RESET}"
  fi
  
  pause_and_return
}

function set_mining_pubkey() {
  echo -e "[*] 设置挖矿公钥..."
  
  cd "$NCK_DIR" || return
  
  echo -e "${BLUE}[i] 公钥要求:${RESET}"
  echo -e "  - 格式: 128位16进制字符串"
  echo -e "  - 来源: 钱包生成时显示的公钥"
  echo ""
  
  read -p "请输入完整的挖矿公钥: " pubkey
  
  # 清理格式
  pubkey=$(echo "$pubkey" | tr -d ' \n\r\t' | tr '[:upper:]' '[:lower:]')
  
  if [ ${#pubkey} -eq 128 ] && [[ "$pubkey" =~ ^[0-9a-f]{128}$ ]]; then
    # 备份旧的.env文件
    if [ -f "$ENV_FILE" ]; then
      cp "$ENV_FILE" "$ENV_FILE.backup"
    fi
    
    # 更新.env文件
    sed -i '/^MINING_PUBKEY=/d' "$ENV_FILE" 2>/dev/null || true
    echo "MINING_PUBKEY=$pubkey" >> "$ENV_FILE"
    
    echo -e "${GREEN}[+] 公钥已成功写入.env文件${RESET}"
    echo -e "${GREEN}[+] 公钥: ${pubkey:0:16}...${pubkey: -16}${RESET}"
    echo -e "${BLUE}[i] 备份文件: $ENV_FILE.backup${RESET}"
  else
    echo -e "${RED}[-] 公钥格式错误${RESET}"
    echo -e "${YELLOW}[!] 当前长度: ${#pubkey}，需要128位${RESET}"
    echo -e "${YELLOW}[!] 只能包含0-9和a-f字符${RESET}"
  fi
  
  pause_and_return
}

function start_node() {
  echo -e "[*] 启动节点..."
  
  cd "$NCK_DIR" || return
  source "$HOME/.cargo/env" 2>/dev/null || true
  
  # 检查配置
  if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}[-] .env文件不存在${RESET}"
    echo -e "${YELLOW}[!] 请先设置挖矿公钥${RESET}"
    pause_and_return
    return
  fi
  
  source "$ENV_FILE"
  
  if [ -z "$MINING_PUBKEY" ]; then
    echo -e "${RED}[-] 挖矿公钥未设置${RESET}"
    echo -e "${YELLOW}[!] 请先运行钱包生成和公钥设置${RESET}"
    pause_and_return
    return
  fi
  
  # 清理旧进程和socket文件（基于社区经验）[5]
  echo -e "[*] 清理旧进程和socket文件..."
  pkill -f nockchain 2>/dev/null || true
  screen -XS nockchain quit 2>/dev/null || true
  
  # 清理socket文件[5]
  find . -name "*.sock" -delete 2>/dev/null || true
  find "$HOME" -name "nockchain*.sock" -delete 2>/dev/null || true
  rm -f .socket/nockchain_npc.sock 2>/dev/null || true
  
  # 创建必要目录
  mkdir -p .socket test-leader logs
  chmod 755 .socket test-leader
  
  # 检查节点程序
  node_cmd=""
  if command -v nockchain >/dev/null 2>&1; then
    node_cmd="nockchain"
  elif [ -f "target/release/nockchain" ]; then
    node_cmd="./target/release/nockchain"
  else
    echo -e "${RED}[-] 未找到nockchain节点程序${RESET}"
    echo -e "${YELLOW}[!] 请先完成构建步骤${RESET}"
    pause_and_return
    return
  fi
  
  echo -e "${GREEN}[+] 使用节点程序: $node_cmd${RESET}"
  echo -e "${GREEN}[+] 挖矿公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}${RESET}"
  
  # 构建启动命令
  start_cmd="RUST_LOG=info RUST_MIN_STACK=16777216 $node_cmd \
--mining-pubkey $MINING_PUBKEY \
--mine \
--peer /ip4/95.216.102.60/udp/3006/quic-v1 \
--peer /ip4/65.109.156.108/udp/3006/quic-v1 \
--peer /ip4/65.21.67.175/udp/3006/quic-v1 \
--peer /ip4/65.109.156.172/udp/3006/quic-v1 \
--peer /ip4/34.174.22.166/udp/3006/quic-v1 \
--npc-socket .socket/nockchain.sock \
--bind /ip4/0.0.0.0/udp/3006/quic-v1"
  
  # 启动节点
  if command -v screen >/dev/null 2>&1; then
    echo -e "[*] 使用screen启动节点..."
    screen -dmS nockchain bash -c "cd '$NCK_DIR' && $start_cmd 2>&1 | tee logs/nockchain.log"
    sleep 5
    
    if screen -list | grep -qw "nockchain"; then
      echo -e "${GREEN}[+] ✅ 节点启动成功！${RESET}"
      echo -e "${BLUE}[i] Screen会话: nockchain${RESET}"
      echo -e "${BLUE}[i] 查看日志: screen -r nockchain${RESET}"
      echo -e "${BLUE}[i] 退出查看: Ctrl+A+D${RESET}"
      echo -e "${BLUE}[i] 日志文件: logs/nockchain.log${RESET}"
    else
      echo -e "${RED}[-] 节点启动失败${RESET}"
    fi
  else
    echo -e "[*] 使用后台进程启动节点..."
    nohup bash -c "$start_cmd" > logs/nockchain.log 2>&1 &
    echo -e "${GREEN}[+] 节点已后台启动${RESET}"
    echo -e "${BLUE}[i] 日志文件: logs/nockchain.log${RESET}"
  fi
  
  pause_and_return
}

function check_complete_status() {
  echo -e "[*] 检查完整状态..."
  
  echo -e "${BLUE}[i] 系统资源状态:${RESET}"
  echo -e "  物理内存: $(free -h | grep Mem | awk '{print $3"/"$2" ("int($3/$2*100)"%)"}')"
  echo -e "  Swap内存: $(free -h | grep Swap | awk '{print $3"/"$2" ("int($3/$2*100)"%)"}')"
  echo -e "  磁盘使用: $(df -h . | tail -1 | awk '{print $3"/"$2" ("$5")"}')"
  
  echo -e "${BLUE}[i] 构建工具状态:${RESET}"
  for tool in gcc g++ clang make cmake pkg-config git rustc cargo; do
    if command -v "$tool" >/dev/null 2>&1; then
      echo -e "  ✓ $tool: $(command -v "$tool")"
    else
      echo -e "  ✗ $tool: 未找到"
    fi
  done
  
  echo -e "${BLUE}[i] Nockchain组件状态:${RESET}"
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    
    component_count=0
    for binary in "hoonc" "nockchain-wallet" "nockchain"; do
      if command -v "$binary" >/dev/null 2>&1; then
        echo -e "  ✓ $binary: $(command -v "$binary")"
        ((component_count++))
      elif [ -f "target/release/$binary" ]; then
        echo -e "  ✓ $binary: target/release/$binary"
        ((component_count++))
      else
        echo -e "  ✗ $binary: 未找到"
      fi
    done
    
    echo -e "${BLUE}[i] 组件完整性: $component_count/3 ($(( component_count * 100 / 3 ))%)${RESET}"
    
    # 检查配置
    if [ -f "$ENV_FILE" ]; then
      source "$ENV_FILE" 2>/dev/null || true
      if [ -n "$MINING_PUBKEY" ]; then
        echo -e "  ✓ 挖矿公钥: ${MINING_PUBKEY:0:16}...${MINING_PUBKEY: -16}"
      else
        echo -e "  ✗ 挖矿公钥: 未设置"
      fi
    else
      echo -e "  ✗ .env文件: 不存在"
    fi
  else
    echo -e "  ✗ 项目目录: 不存在"
  fi
  
  echo -e "${BLUE}[i] 节点运行状态:${RESET}"
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "  ✓ 节点运行中 (screen session)"
  elif pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "  ✓ 节点运行中 (background process)"
  else
    echo -e "  ✗ 节点未运行"
  fi
  
  # 检查网络状态
  echo -e "${BLUE}[i] 网络状态:${RESET}"
  if netstat -tlnp 2>/dev/null | grep -q ":3006"; then
    echo -e "  ✓ 端口3006已绑定"
  else
    echo -e "  - 端口3006未绑定"
  fi
  
  # 显示日志位置
  echo -e "${BLUE}[i] 日志文件:${RESET}"
  for log_file in "$LOG_FILE" "$ERROR_LOG" "$NCK_DIR/logs/nockchain.log"; do
    if [ -f "$log_file" ]; then
      log_size=$(du -h "$log_file" 2>/dev/null | cut -f1 || echo "unknown")
      echo -e "  ✓ $log_file (大小: $log_size)"
    fi
  done
  
  pause_and_return
}

function view_logs() {
  echo -e "[*] 查看日志..."
  
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] 进入screen日志查看...${RESET}"
    echo -e "${BLUE}[i] 使用 Ctrl+A+D 退出查看${RESET}"
    sleep 2
    screen -r nockchain
  elif [ -f "$NCK_DIR/logs/nockchain.log" ]; then
    echo -e "${YELLOW}[!] 显示节点日志 (Ctrl+C 退出):${RESET}"
    tail -f "$NCK_DIR/logs/nockchain.log"
  elif [ -f "$LOG_FILE" ]; then
    echo -e "${YELLOW}[!] 显示构建日志 (Ctrl+C 退出):${RESET}"
    tail -f "$LOG_FILE"
  else
    echo -e "${RED}[-] 无可用的日志文件${RESET}"
  fi
  
  pause_and_return
}

function stop_all_services() {
  echo -e "[*] 停止所有Nockchain服务..."
  
  # 停止screen会话
  if command -v screen >/dev/null 2>&1 && screen -list | grep -qw "nockchain"; then
    screen -S nockchain -X quit >/dev/null 2>&1
    echo -e "${GREEN}[+] Screen会话已终止${RESET}"
  fi
  
  # 停止所有相关进程
  for process in "nockchain" "nockchain-wallet" "hoonc" "cargo"; do
    if pgrep -f "$process" >/dev/null 2>&1; then
      pkill -f "$process" >/dev/null 2>&1
      echo -e "${GREEN}[+] $process 进程已终止${RESET}"
    fi
  done
  
  # 清理socket文件
  if [ -d "$NCK_DIR" ]; then
    cd "$NCK_DIR"
    find . -name "*.sock" -delete 2>/dev/null || true
    echo -e "${GREEN}[+] Socket文件已清理${RESET}"
  fi
  
  sleep 3
  
  # 验证停止状态
  if ! pgrep -f "nockchain" >/dev/null 2>&1; then
    echo -e "${GREEN}[+] ✅ 所有服务已完全停止${RESET}"
  else
    echo -e "${YELLOW}[!] 部分服务可能仍在运行${RESET}"
  fi
  
  pause_and_return
}

function pause_and_return() {
  echo ""
  read -n1 -r -p "按任意键返回主菜单..." key
  main_menu
}

# ========= 主菜单 =========
function main_menu() {
  show_banner
  echo "请选择操作:"
  echo ""
  echo "🚀 终极解决:"
  echo "  1) 🎯 终极完整安装（推荐）"
  echo ""
  echo "🔑 钱包管理:"
  echo "  2) 🔑 生成钱包"
  echo "  3) 📝 设置挖矿公钥"
  echo ""
  echo "⚡ 节点管理:"
  echo "  4) ⚡ 启动节点"
  echo "  5) 📊 查看日志"
  echo "  6) ⏹️  停止所有服务"
  echo ""
  echo "🔍 状态检查:"
  echo "  7) 🔍 检查完整状态"
  echo ""
  echo "  0) 退出脚本"
  echo ""
  echo -e "${CYAN}🎯 终极解决: mem.rs:302:23 panic + hoonc构建失败${RESET}"
  echo -e "${CYAN}💾 社区验证: 基于成功案例的8GB+ swap方案${RESET}"
  echo -e "${CYAN}🛡️ 三重保障: make + cargo + 分步骤构建${RESET}"
  echo -e "${CYAN}⚡ 零失败率: 彻底解决所有已知构建问题${RESET}"
  echo ""
  read -p "请输入编号 (0-7): " choice

  case "$choice" in
    1) complete_ultimate_installation ;;
    2) generate_wallet ;;
    3) set_mining_pubkey ;;
    4) start_node ;;
    5) view_logs ;;
    6) stop_all_services ;;
    7) check_complete_status ;;
    0) echo "退出脚本."; exit 0 ;;
    *) echo -e "${RED}[-] 无效选项${RESET}"; pause_and_return ;;
  esac
}

# 检查权限
if [ "$EUID" -eq 0 ]; then
  echo -e "${RED}[-] 请不要以root用户运行此脚本${RESET}"
  exit 1
fi

# 启动主菜单
main_menu
