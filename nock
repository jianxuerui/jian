#!/bin/bash

# ===================================================
# Nockchain Setup and Management Script (Interactive)
# ===================================================
# åŠŸèƒ½: Nockchain èŠ‚ç‚¹çš„æ‰‹åŠ¨/äº¤äº’å¼å®‰è£…ã€æ„å»ºã€é’±åŒ…ç®¡ç†ã€
# å¤šçº¿ç¨‹é…ç½®ã€å¯åŠ¨ã€åœæ­¢å’Œæ—¥å¿—æŸ¥çœ‹ã€‚
# ç§»é™¤äº†å‘½ä»¤è¡Œä¸€é”®æ¨¡å¼ï¼Œä¸“æ³¨äºæä¾›æ›´æ¸…æ™°çš„äº¤äº’æµç¨‹ã€‚
# å¯¹å¤šçº¿ç¨‹æŒ–çŸ¿é…ç½®ã€èŠ‚ç‚¹è‡ªåŠ¨é‡å¯å’Œæ—¥å¿—æŸ¥çœ‹è¿›è¡Œäº†ä¼˜åŒ–ã€‚
# å¢å¼ºäº†æ„å»ºå¤±è´¥æ—¶çš„é”™è¯¯æç¤ºï¼ŒæŒ‡å¼•ç”¨æˆ·æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ã€‚

# Enable strict mode: Exit on error, exit on unset variable, pipefail
# æ³¨æ„: åœ¨äº¤äº’å¼è„šæœ¬ä¸­ï¼ŒæŸäº›é”™è¯¯å¯èƒ½ä¸å¸Œæœ›ç›´æ¥é€€å‡ºï¼Œ
# ä¼šé€šè¿‡è¿”å›ç å’Œpause_and_returnæ¥å¤„ç†ï¼Œä½† pipefail ä»å¾ˆæœ‰ç”¨ã€‚
set -eo pipefail

# ========= è‰²å½©å®šä¹‰ =========
RESET='\033[0m'
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'

# ========= é¡¹ç›®è·¯å¾„å’Œæ–‡ä»¶ =========
NCK_DIR="$HOME/nockchain"
ENV_FILE="$NCK_DIR/.env"
# ç¡®ä¿æ—¥å¿—æ–‡ä»¶è·¯å¾„çš„çˆ¶ç›®å½•å­˜åœ¨
LOG_DIR="$NCK_DIR/logs"
# ä½¿ç”¨ screen çš„æ—¥å¿—åŠŸèƒ½ï¼Œæ–‡ä»¶åå›ºå®šä¸º screenlog.0 åœ¨ screen çš„å¯åŠ¨ç›®å½•
# æˆ‘ä»¬å°† screen åœ¨ $NCK_DIR ä¸‹å¯åŠ¨ï¼Œæ‰€ä»¥æ—¥å¿—æ–‡ä»¶ä¼šæ˜¯ $NCK_DIR/screenlog.0
# ä¸ºäº†ç”¨æˆ·å‹å¥½ï¼Œæˆ‘ä»¬è¿˜æ˜¯æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ—¥å¿—æ–‡ä»¶è·¯å¾„å˜é‡ï¼Œå¹¶å‘ŠçŸ¥ç”¨æˆ·å®é™…ä½ç½®
LOG_FILE_SCREEN_DEFAULT="$NCK_DIR/screenlog.0"
LOG_FILE_FRIENDLY="$LOG_DIR/nockchain.log" # A user-friendly path, perhaps a symlink or copy

# ========= æ¨ªå¹… =========
function show_banner() {
  # æ¸…é™¤å±å¹•å¹¶æ˜¾ç¤ºæ¨ªå¹…
  clear
  echo -e "${BOLD}${BLUE}"
  echo "==============================================="
  echo "         Nockchain å®‰è£…åŠ©æ‰‹ / Setup Tool"
  echo "==============================================="
  echo -e "${YELLOW}ğŸ‘‹ æ¬¢è¿ä½¿ç”¨äº¤äº’å¼ Nockchain ç®¡ç†è„šæœ¬ ğŸ‘‹${RESET}"
  echo ""
}

# ========= å¸¸ç”¨å‡½æ•° =========

# è¿›å…¥é¡¹ç›®ç›®å½•ï¼Œå¤±è´¥åˆ™æ‰“å°é”™è¯¯å¹¶è¿”å›1
function cd_nck_dir() {
  if [[ -d "$NCK_DIR" ]]; then
    cd "$NCK_DIR" || { echo -e "${RED}[-] é”™è¯¯: æ— æ³•è¿›å…¥é¡¹ç›®ç›®å½•: $NCK_DIR${RESET}"; return 1; }
    return 0
  else
    echo -e "${RED}[-] é”™è¯¯: é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: $NCK_DIR${RESET}"
    return 1
  fi
}

# æ£€æŸ¥å‘½ä»¤æ˜¯å¦å­˜åœ¨
function command_exists() {
  command -v "$1" &>/dev/null
}

# æš‚åœå¹¶è¿”å›ä¸»èœå•
function pause_and_return() {
  echo ""
  read -n1 -r -p "æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•..." key
  # screen won't capture single key press correctly, so use a dummy echo
  echo ""
}

# å†™å…¥æˆ–æ›´æ–° .env æ–‡ä»¶ä¸­çš„é”®å€¼å¯¹
# å‚æ•°1: key
# å‚æ•°2: value
function update_env() {
  local key="$1"
  local value="$2"
  if [[ -f "$ENV_FILE" ]]; then
    # Use sed to update or add the key=value pair
    # Ensure the value is escaped correctly if it contains '/'
    local escaped_value=$(echo "$value" | sed 's/[\/&]/\\&/g')
    if grep -qE "^[[:space:]]*${key}=" "$ENV_FILE"; then
        # Key exists, update it, preserving potential leading whitespace/comments on the line
        # Using a temporary file and move for atomic update
        sed -i.bak "/^[[:space:]]*${key}=/ { s|=.*|=${escaped_value}|; }; t; \$ { !/^[[:space:]]*${key}=/ { s|\$|\n${key}=${escaped_value}|; }; }" "$ENV_FILE"
        # Check if sed created a backup and remove it
        if [[ -f "$ENV_FILE.bak" ]]; then rm "$ENV_FILE.bak"; fi
    else
        # Key does not exist, add it at the end of the file
        echo "${key}=${value}" >> "$ENV_FILE"
    fi
    #echo -e "${GREEN}[+] å·²å†™å…¥ ${key} åˆ° .env${RESET}" # Avoid excessive output
  else
    echo -e "${RED}[-] è­¦å‘Š: .env æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— æ³•å†™å…¥é”®å€¼å¯¹ã€‚è¯·å…ˆè¿è¡Œå®‰è£…é€‰é¡¹åˆ›å»ºã€‚${RESET}"
    return 1
  fi
}


# è¯»å– .env æ–‡ä»¶ä¸­çš„å€¼
# å‚æ•°1: key
# å‚æ•°2: default_value (å¯é€‰)
function get_env() {
  local key="$1"
  local default_value="$2"
  if [[ -f "$ENV_FILE" ]]; then
    # Use grep and cut to extract the value, handling potential whitespace around '='
    # Grep for the key at the start of the line (ignoring potential leading whitespace and comments)
    # Cut the line by '=', take the second field, trim leading/trailing whitespace
    local value=$(grep -E "^[[:space:]]*${key}=" "$ENV_FILE" | head -n 1 | cut -d '=' -f 2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    if [[ -n "$value" ]]; then
        echo "$value"
    else
        echo "$default_value"
    fi
  else
    echo "$default_value" # Return default value if .env file doesn't exist
  fi
}

# è·å–ç³»ç»Ÿæ ¸å¿ƒæ•°, å¤±è´¥é»˜è®¤1
function get_num_cores() {
    nproc 2>/dev/null || { echo 1; echo -e "${YELLOW}è­¦å‘Š: nproc å‘½ä»¤æœªæ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤æ ¸å¿ƒæ•° 1. ${RESET}" >&2; }
}


# ========= å®‰è£…ä¸æ„å»ºå‡½æ•° =========

function setup_all() {
  echo -e "${CYAN}===============================================${RESET}"
  echo -e "${CYAN}         âš™ï¸  å¼€å§‹æ‰§è¡Œå®‰è£…å’Œæ„å»º âš™ï¸         ${RESET}"
  echo -e "${CYAN}===============================================${RESET}"

  echo -e "${CYAN}[*] å®‰è£…ç³»ç»Ÿä¾èµ–...${RESET}"
  # Check for sudo before attempting apt commands
  if ! command_exists sudo; then
      echo -e "${RED}[-] é”™è¯¯: sudo å‘½ä»¤æœªæ‰¾åˆ°ã€‚è¯·ç¡®ä¿æ‚¨æœ‰æƒé™å®‰è£…è½¯ä»¶åŒ…ã€‚${RESET}"
      pause_and_return; return 1;
  fi
  # Add --fix-missing and --no-install-recommends for robustness
  # Add pkg-config again as it's crucial for many build processes
  sudo apt update --fix-missing || { echo -e "${RED}[-] é”™è¯¯: apt update å¤±è´¥${RESET}"; pause_and_return; return 1; }
  sudo apt install -y --no-install-recommends clang llvm-dev libclang-dev pkg-config libssl-dev build-essential cmake curl git make screen || { echo -e "${RED}[-] é”™è¯¯: å®‰è£…ç³»ç»Ÿä¾èµ–å¤±è´¥${RESET}"; pause_and_return; return 1; }
  echo -e "${GREEN}[+] ç³»ç»Ÿä¾èµ–å®‰è£…å®Œæˆ${RESET}"

  echo -e "${CYAN}[*] å®‰è£… Rust...${RESET}"
  if ! command_exists cargo; then
    # Check if rustup installer exists
    if ! command_exists curl && ! command_exists wget; then
       echo -e "${RED}[-] é”™è¯¯: curl æˆ– wget å‘½ä»¤æœªæ‰¾åˆ°ï¼Œæ— æ³•ä¸‹è½½ Rust å®‰è£…è„šæœ¬ã€‚${RESET}"
       pause_and_return; return 1;
    fi
    # Use -sSfL for curl (silent, fail, show errors, follow redirects)
    curl --proto '=https' --tlsv1.2 -sSfL https://sh.rustup.rs | sh -s -- -y || { echo -e "${RED}[-] é”™è¯¯: Rust å®‰è£…å¤±è´¥${RESET}"; pause_and_return; return 1; }
    # shellcheck source=/dev/null
    source "$HOME/.cargo/env"
    echo -e "${GREEN}[+] Rust å®‰è£…å®Œæˆ${RESET}"
  else
    echo -e "${YELLOW}[*] Rust å·²å®‰è£…${RESET}"
    # Ensure cargo env is sourced even if Rust was pre-installed
    # shellcheck source=/dev/null
    source "$HOME/.cargo/env"
  fi

  # Ensure cargo bin path is added to PATH permanently (optional but good practice)
  local rc_file="$HOME/.bashrc"
  [[ "$SHELL" == *"zsh"* ]] && rc_file="$HOME/.zshrc"
  if ! grep -q 'export PATH="\$HOME/\.cargo/bin:\$PATH"' "$rc_file"; then
    echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$rc_file"
    echo -e "${GREEN}[+] å·²æ·»åŠ  Cargo è·¯å¾„åˆ° $rc_file${RESET}. æ‚¨å¯èƒ½éœ€è¦é‡æ–°ç™»å½•æˆ–æ‰§è¡Œ 'source $rc_file'.${RESET}"
  fi
  # Immediately update current shell's PATH
  export PATH="$HOME/.cargo/bin:$PATH"

  echo -e "${CYAN}[*] è·å–æˆ–æ›´æ–°ä»“åº“...${RESET}"
  if [[ -d "$NCK_DIR" ]]; then
    echo -e "${YELLOW}[*] é¡¹ç›®ç›®å½•å·²å­˜åœ¨ ($NCK_DIR)ï¼Œå°è¯•æ›´æ–°...${RESET}"
    cd_nck_dir || { pause_and_return; return 1; }
    git pull || { echo -e "${RED}[-] é”™è¯¯: git pull å¤±è´¥${RESET}"; pause_and_return; return 1; }
  else
    echo -e "${YELLOW}[*] å…‹éš†æ–°ä»“åº“åˆ° $NCK_DIR...${RESET}"
    git clone https://github.com/zorp-corp/nockchain "$NCK_DIR" || { echo -e "${RED}[-] é”™è¯¯: git clone å¤±è´¥${RESET}"; pause_and_return; return 1; }
    cd_nck_dir || { pause_and_return; return 1; }
  fi
  echo -e "${GREEN}[+] ä»“åº“å‡†å¤‡å°±ç»ª${RESET}"

  echo -e "${CYAN}[*] è®¾ç½® .env æ–‡ä»¶å¹¶é…ç½®æŒ–çŸ¿å‚æ•°...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  local env_needs_config=false

  if [[ ! -f "$ENV_FILE" ]]; then
      if [[ -f ".env_example" ]]; then
          cp ".env_example" "$ENV_FILE" || { echo -e "${RED}[-] é”™è¯¯: å¤åˆ¶ .env_example å¤±è´¥${RESET}"; pause_and_return; return 1; }
          echo -e "${GREEN}[+] .env æ–‡ä»¶å·²åŸºäº .env_example åˆ›å»º${RESET}"
          env_needs_config=true
      else
          echo -e "${RED}[-] é”™è¯¯: .env_example æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»º .env${RESET}"
          echo -e "${YELLOW}å°è¯•æ‰‹åŠ¨åˆ›å»º .env æ–‡ä»¶ï¼Œè‡³å°‘åŒ…å« MINING_PUBKEY=<your_pubkey> å’Œ MINING_THREADS=<num_threads>${RESET}"
          pause_and_return; return 1;
      fi
  else
      echo -e "${YELLOW}[*] .env æ–‡ä»¶å·²å­˜åœ¨${RESET}"
      # Check if core mining parameters are missing
      local current_pubkey=$(get_env "MINING_PUBKEY")
      local current_threads=$(get_env "MINING_THREADS")
      if [[ -z "$current_pubkey" || -z "$current_threads" ]]; then
          echo -e "${YELLOW}[*] æ£€æµ‹åˆ° .env æ–‡ä»¶ç¼ºå°‘ MINING_PUBKEY æˆ– MINING_THREADS é…ç½®${RESET}"
          env_needs_config=true
      else
           echo -e "${YELLOW}[*] MINING_PUBKEY å’Œ MINING_THREADS å·²åœ¨ .env ä¸­é…ç½®:${RESET}"
           echo -e "    å…¬é’¥: ${YELLOW}$current_pubkey${RESET}"
           echo -e "    çº¿ç¨‹: ${YELLOW}$current_threads${RESET}"
      fi
  fi

  # Prompt for config if needed or explicitly requested
  # Add an option to force re-configure
  local force_config="N"
  if [[ "$env_needs_config" = true ]]; then
      echo -e "${YELLOW}--- æŒ–çŸ¿å‚æ•°é…ç½®å‘å¯¼ (é¦–æ¬¡è®¾ç½®æˆ–å‚æ•°ç¼ºå¤±) ---${RESET}"
  else
      read -p "${YELLOW}æ˜¯å¦è¦é‡æ–°é…ç½®æŒ–çŸ¿å‚æ•° (MINING_PUBKEY, MINING_THREADS)? (y/N): ${RESET}" force_config
      [[ "$force_config" =~ ^[Yy]$ ]] && echo -e "${YELLOW}--- é‡æ–°é…ç½®æŒ–çŸ¿å‚æ•° ---${RESET}"
  fi


  if [[ "$env_needs_config" = true || "$force_config" =~ ^[Yy]$ ]]; then
      # Prompt for MINING_PUBKEY
      local configured_pubkey=$(get_env "MINING_PUBKEY")
      if [[ -z "$configured_pubkey" || "$force_config" =~ ^[Yy]$ ]]; then
          echo ""
          echo -e "${YELLOW}é‡è¦: æ‚¨éœ€è¦ä¸€ä¸ª Nockchain å…¬é’¥ç”¨äºæ¥æ”¶æŒ–çŸ¿å¥–åŠ±.${RESET}"
          echo -e "æ‚¨å¯ä»¥ä½¿ç”¨èœå•é€‰é¡¹ '${BLUE}2) ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹${RESET}' æ¥ç”Ÿæˆä¸€ä¸ªæ–°çš„å¯†é’¥å¯¹ï¼Œå¹¶è·å–å…¬é’¥ã€‚"
          echo -e "æˆ–è€…ä½¿ç”¨ä¸€ä¸ªå·²æœ‰çš„å…¬é’¥ã€‚"
          read -p "è¯·è¾“å…¥ä½ çš„ Nockchain å…¬é’¥ (MINING_PUBKEY)${configured_pubkey:+ (å½“å‰: $configured_pubkey)}: " pubkey_input
          # If input is empty, keep current value if re-configuring
          if [[ -z "$pubkey_input" && "$force_config" =~ ^[Yy]$ && -n "$configured_pubkey" ]]; then
             echo -e "${YELLOW}[*] æœªè¾“å…¥æ–°å…¬é’¥ï¼Œä¿æŒå½“å‰ MINING_PUBKEY: $configured_pubkey${RESET}"
          elif [[ -z "$pubkey_input" ]]; then
              echo -e "${RED}[-] é”™è¯¯: å…¬é’¥ä¸èƒ½ä¸ºç©ºã€‚æ‚¨å¯ä»¥åœ¨å®‰è£…å®Œæˆåä½¿ç”¨é€‰é¡¹ 3 æ‰‹åŠ¨è®¾ç½®ã€‚${RESET}"
              # Do not return, continue with setup, but pubkey might be missing/incorrect
          else
              update_env "MINING_PUBKEY" "$pubkey_input" || { pause_and_return; return 1; }
              echo -e "${GREEN}[+] MINING_PUBKEY å·²è®¾ç½®ä¸º $pubkey_input${RESET}"
          fi
      else
           echo -e "å½“å‰çš„ MINING_PUBKEY: ${YELLOW}$configured_pubkey${RESET}"
      fi

      # Prompt for MINING_THREADS
      local configured_threads=$(get_env "MINING_THREADS")
      local num_cores=$(get_num_cores)
       if [[ -z "$configured_threads" || ! "$configured_threads" =~ ^[1-9][0-9]*$ || "$force_config" =~ ^[Yy]$ ]]; then
           echo ""
           echo -e "ç³»ç»Ÿæ£€æµ‹åˆ°çš„æ ¸å¿ƒæ•°: ${GREEN}$num_cores${RESET}"
           echo -e "${YELLOW}é€‰æ‹©åˆé€‚çš„çº¿ç¨‹æ•°å¯¹æŒ–çŸ¿æ€§èƒ½è‡³å…³é‡è¦ã€‚é€šå¸¸å»ºè®®ä½¿ç”¨ç­‰äºæˆ–ç•¥å°äºæ ¸å¿ƒæ•°çš„çº¿ç¨‹æ•°ã€‚${RESET}"
           echo -e "${YELLOW}è¿‡å¤šçš„çº¿ç¨‹å¯èƒ½å› ä¸ºä¸Šä¸‹æ–‡åˆ‡æ¢é™ä½æ•ˆç‡ã€‚${RESET}"
           read -p "è¯·è¾“å…¥æŒ–çŸ¿çº¿ç¨‹æ•° (å»ºè®® $num_cores, ç•™ç©ºä½¿ç”¨é»˜è®¤ $num_cores)${configured_threads:+ (å½“å‰: $configured_threads)}: " threads_input

           local final_threads=""
           if [[ -z "$threads_input" ]]; then
               # If input is empty, use default (num_cores) if originally missing/invalid, or keep current if re-configuring
               if [[ -z "$configured_threads" || ! "$configured_threads" =~ ^[1-9][0-9]*$ ]]; then
                   final_threads="$num_cores"
               else
                   final_threads="$configured_threads" # Keep current value if re-configuring and input is empty
               fi
           else
               final_threads="$threads_input" # Use the input value
           fi


            if [[ "$final_threads" =~ ^[1-9][0-9]*$ ]]; then
                 if [[ "$final_threads" != "$(get_env MINING_THREADS)" ]]; then # Only update if different from current env value
                    update_env "MINING_THREADS" "$final_threads" || { pause_and_return; return 1; }
                    echo -e "${GREEN}[+] MINING_THREADS å·²è®¾ç½®ä¸º $final_threads${RESET}"
                 else
                    echo -e "${YELLOW}[*] æŒ–çŸ¿çº¿ç¨‹æ•°æœªæ”¹å˜ï¼Œä¿æŒä¸º $final_threads${RESET}"
                 fi
            else
                echo -e "${RED}[-] è¾“å…¥æ— æ•ˆ '$final_threads'ï¼Œçº¿ç¨‹æ•°å¿…é¡»æ˜¯æ­£æ•´æ•°ã€‚æ‚¨å¯ä»¥åœ¨å®‰è£…å®Œæˆåä½¿ç”¨é€‰é¡¹ 6 æ‰‹åŠ¨è®¾ç½®ã€‚${RESET}"
                 # Do not return, continue setup
            fi
      else
          echo -e "å½“å‰çš„ MINING_THREADS: ${YELLOW}$configured_threads${RESET}"
      fi
      echo -e "${YELLOW}-----------------------------------------------${RESET}"
  fi

  echo -e "${CYAN}[*] å®‰è£… hoonc...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  # Clean before installing hoonc just in case
  make clean-hoonc || true # Don't fail if clean fails

  # Execute make install-hoonc and capture status
  make install-hoonc
  local status=$? # Capture the exit status
  if [[ $status -ne 0 ]]; then
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}         âŒ ç¼–è¯‘å¤±è´¥: hoonc âŒ         ${RESET}"
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}[-] é”™è¯¯: 'make install-hoonc' å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºçŠ¶æ€ç : $status${RESET}"
      echo ""
      echo -e "${YELLOW}è¯·å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹è¯¦ç»†çš„ç¼–è¯‘é”™è¯¯ä¿¡æ¯ã€‚${RESET}"
      echo -e "${YELLOW}æ‚¨ä¹Ÿå¯ä»¥å°è¯•æ‰‹åŠ¨è¿›å…¥ç›®å½• '${CYAN}$NCK_DIR${YELLOW}' å¹¶è¿è¡Œ '${CYAN}make install-hoonc${YELLOW}' æ¥ç›´æ¥æŸ¥çœ‹é”™è¯¯ã€‚${RESET}"
      pause_and_return
      return 1
  fi
  # If make install-hoonc succeeded, continue...
  echo -e "${GREEN}[+] hoonc å®‰è£…å®Œæˆ${RESET}"


  # --- START OF MODIFIED SECTION ---
  echo -e "${CYAN}[*] ç¼–è¯‘ Nockchain èŠ‚ç‚¹ (ä½¿ç”¨ $(get_num_cores) æ ¸å¿ƒ: make install -j $(get_num_cores))...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }

  # Execute make install and capture status
  make install -j $(get_num_cores)
  local status=$? # Capture the exit status
  if [[ $status -ne 0 ]]; then
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}         âŒ ç¼–è¯‘å¤±è´¥: Nockchain èŠ‚ç‚¹ âŒ         ${RESET}"
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}[-] é”™è¯¯: 'make install' å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºçŠ¶æ€ç : $status${RESET}"
      echo ""
      echo -e "${YELLOW}è¯·å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹è¯¦ç»†çš„ç¼–è¯‘é”™è¯¯ä¿¡æ¯ (é€šå¸¸æ˜¯çº¢è‰²çš„æ–‡æœ¬)ã€‚${RESET}"
      echo -e "${YELLOW}å¸¸è§çš„é”™è¯¯åŸå› åŒ…æ‹¬ç¼ºå°‘ç³»ç»Ÿä¾èµ– (å¦‚ clang, libssl-dev ç­‰)ã€Rust ç‰ˆæœ¬é—®é¢˜æˆ–ä»£ç æœ¬èº«çš„é—®é¢˜ã€‚${RESET}"
      echo -e "${YELLOW}æ‚¨ä¹Ÿå¯ä»¥å°è¯•æ‰‹åŠ¨è¿›å…¥ç›®å½• '${CYAN}$NCK_DIR${YELLOW}' å¹¶è¿è¡Œ '${CYAN}cargo build --release${YELLOW}' æ¥ç›´æ¥æŸ¥çœ‹é”™è¯¯ã€‚${RESET}"
      pause_and_return
      return 1
  fi
  # If make install succeeded, continue...
  echo -e "${GREEN}[+] Nockchain (release) ç¼–è¯‘å®Œæˆ${RESET}"
  # The node executable is now built at target/release/nockchain
  echo -e "${YELLOW}èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶ä½äº $NCK_DIR/target/release/nockchain${RESET}"
  # --- END OF MODIFIED SECTION ---


  echo -e "${CYAN}[*] å®‰è£…é’±åŒ…...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }

  # Execute make install-nockchain-wallet-release and capture status
  make install-nockchain-wallet-release
  local status=$? # Capture the exit status
  if [[ $status -ne 0 ]]; then
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}         âŒ ç¼–è¯‘å¤±è´¥: é’±åŒ… âŒ         ${RESET}"
      echo -e "${RED}===============================================${RESET}"
      echo -e "${RED}[-] é”™è¯¯: 'make install-nockchain-wallet-release' å‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼Œé€€å‡ºçŠ¶æ€ç : $status${RESET}"
      echo ""
      echo -e "${YELLOW}è¯·å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹è¯¦ç»†çš„ç¼–è¯‘é”™è¯¯ä¿¡æ¯ã€‚${RESET}"
      echo -e "${YELLOW}æ‚¨ä¹Ÿå¯ä»¥å°è¯•æ‰‹åŠ¨è¿›å…¥ç›®å½• '${CYAN}$NCK_DIR${YELLOW}' å¹¶è¿è¡Œ '${CYAN}cargo build --release --bin nockchain-wallet${YELLOW}' æ¥ç›´æ¥æŸ¥çœ‹é”™è¯¯ã€‚${RESET}"
      pause_and_return
      return 1
  fi
  # If make install-nockchain-wallet-release succeeded, continue...
  echo -e "${GREEN}[+] é’±åŒ…å®‰è£…å®Œæˆ${RESET}"
  echo -e "${YELLOW}é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä½äº $NCK_DIR/target/release/nockchain-wallet${RESET}"


  # Create log directory if it doesn't exist - still useful for potential symlinks or future features
  mkdir -p "$LOG_DIR" || { echo -e "${RED}[-] é”™è¯¯: åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥ $LOG_DIR${RESET}"; pause_and_return; return 1; }
  echo -e "${GREEN}[+] æ—¥å¿—ç›®å½•å‡†å¤‡å°±ç»ª: $LOG_DIR${RESET}"


  echo -e "${GREEN}===============================================${RESET}"
  echo -e "${GREEN}         ğŸ‰ Nockchain å®‰è£…æ„å»ºæˆåŠŸ! ğŸ‰         ${RESET}"
  echo -e "${GREEN}===============================================${RESET}"

  echo ""
  echo -e "${YELLOW}å®‰è£…æ„å»ºå·²å®Œæˆã€‚èŠ‚ç‚¹å’Œé’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶ä½äº $NCK_DIR/target/release/.${RESET}"
  echo -e "${YELLOW}æ¥ä¸‹æ¥æ‚¨å¯ä»¥ï¼š${RESET}"
  echo -e "1. å¦‚æœå®‰è£…æ—¶æœªè®¾ç½®å…¬é’¥æˆ–ä¸ç¡®å®šï¼Œè¿è¡Œ '${BLUE}2) ç”Ÿæˆé’±åŒ…${RESET}' å¹¶è®°ä¸‹å…¬é’¥ï¼Œç„¶åè¿è¡Œ '${BLUE}3) è®¾ç½® MINING_PUBKEY${RESET}'ã€‚"
  echo -e "2. å¦‚æœéœ€è¦ï¼Œä½¿ç”¨ '${YELLOW}6) é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°${RESET}' è°ƒæ•´çº¿ç¨‹ã€‚"
  echo -e "3. è¿è¡Œ '${CYAN}7) å¯åŠ¨èŠ‚ç‚¹${RESET}' å¼€å§‹æŒ–çŸ¿ã€‚"

  pause_and_return
  return 0
}

# ========= é’±åŒ…å‡½æ•° =========

function check_wallet_executable() {
    if [[ ! -x "$NCK_DIR/target/release/nockchain-wallet" ]]; then
        echo -e "${RED}[-] é’±åŒ…å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
        return 1
    fi
    return 0
}

function generate_wallet() {
  echo -e "${CYAN}[*] ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  check_wallet_executable || { pause_and_return; return 1; }

  echo -e "${YELLOW}[!] æ­£åœ¨ç”Ÿæˆé’±åŒ…å¯†é’¥å¯¹ã€‚è¿™ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„å¯†é’¥å¯¹ã€‚å¦‚æœæ‚¨å·²ç»æœ‰å¯†é’¥å¯¹ï¼Œè¯·å‹¿è¦†ç›–ç°æœ‰æ–‡ä»¶ï¼${RESET}"
  echo -e "${YELLOW}[!] åŠ¡å¿…è®°ä¸‹å…¬é’¥ (pubkey) å¹¶å¦¥å–„ä¿ç®¡ç§é’¥ï¼${RESET}"
  echo "-----------------------------------------------"
  # Execute from the target directory for simplicity and avoid path issues
  (cd "$NCK_DIR/target/release/" && ./nockchain-wallet keygen)
  local status=$?
  echo "-----------------------------------------------"

  if [[ $status -eq 0 ]]; then
    echo -e "${GREEN}[+] é’±åŒ…å¯†é’¥å¯¹ç”Ÿæˆå®Œæˆã€‚${RESET}"
    echo -e "${YELLOW}è¯·å°†ä¸Šé¢è¾“å‡ºçš„å…¬é’¥æ‰‹åŠ¨å¤åˆ¶ï¼Œå¹¶è¿è¡Œ '3) è®¾ç½® MINING_PUBKEY' æ¥é…ç½®æŒ–çŸ¿åœ°å€ã€‚${RESET}"
    echo -e "${RED}è¯·å‹¿ä¸¢å¤±ç§é’¥æ–‡ä»¶ï¼å®ƒé€šå¸¸ä¿å­˜åœ¨è¿è¡Œå‘½ä»¤æ—¶çš„å½“å‰ç›®å½•æˆ–ç”¨æˆ·ä¸»ç›®å½•ä¸‹çš„éšè—æ–‡ä»¶å¤¹ä¸­ï¼ˆå–å†³äº Nockchain é’±åŒ…çš„å®ç°ï¼‰ã€‚${RESET}"
    echo -e "${YELLOW}è¿è¡Œ '4) å¯¼å‡ºé’±åŒ…å¯†é’¥' å¯ä»¥å°†å¯†é’¥å¯¼å‡ºåˆ°å·²çŸ¥æ–‡ä»¶ä½ç½®æ–¹ä¾¿å¤‡ä»½ã€‚${RESET}"
  else
    echo -e "${RED}[-] é’±åŒ…å¯†é’¥ç”Ÿæˆå¤±è´¥${RESET}"
  fi

  pause_and_return
}

function set_pubkey_env() {
  echo -e "${CYAN}[*] è®¾ç½® MINING_PUBKEY åˆ° .env...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }

  if [[ ! -f "$ENV_FILE" ]]; then
      echo -e "${RED}[-] é”™è¯¯: .env æ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
      pause_and_return
      return 1
  fi

  local current_pubkey=$(get_env "MINING_PUBKEY")
  if [[ -n "$current_pubkey" ]]; then
      echo -e "å½“å‰çš„ MINING_PUBKEY: ${YELLOW}$current_pubkey${RESET}"
      read -p "è¯·è¾“å…¥æ–°çš„ Nockchain å…¬é’¥ (pubkey) æˆ–ç•™ç©ºä½¿ç”¨å½“å‰å€¼: " pubkey
  else
      read -p "è¯·è¾“å…¥ä½ çš„ Nockchain å…¬é’¥ (pubkey): " pubkey
  fi

  if [[ -z "$pubkey" && -n "$current_pubkey" ]]; then
      echo -e "${YELLOW}[*] æœªè¾“å…¥æ–°å…¬é’¥ï¼Œä¿æŒå½“å‰é…ç½® ${current_pubkey}${RESET}"
  elif [[ -z "$pubkey" && -z "$current_pubkey" ]]; then
      echo -e "${RED}[-] é”™è¯¯: å…¬é’¥ä¸èƒ½ä¸ºç©º${RESET}"
      pause_and_return
      return 1
  else
      update_env "MINING_PUBKEY" "$pubkey" || { pause_and_return; return 1; }
      echo -e "${GREEN}[+] MINING_PUBKEY å·²æ›´æ–°ä¸º $pubkey${RESET}"
      echo -e "${YELLOW}è¯·ç¡®ä¿æ­¤å…¬é’¥å¯¹åº”çš„ç§é’¥å·²æ­£ç¡®å­˜å‚¨åœ¨æ‚¨çš„çŸ¿æœºä¸Šã€‚${RESET}"
  fi

  pause_and_return
}

function export_keys() {
  echo -e "${CYAN}[*] å¯¼å‡ºé’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  check_wallet_executable || { pause_and_return; return 1; }

  local export_file="$NCK_DIR/keys.export"
  echo -e "${YELLOW}[!] å¯†é’¥å°†å¯¼å‡ºåˆ° $export_file æ–‡ä»¶ã€‚è¯·å¦¥å–„ä¿ç®¡ï¼${RESET}"
  # Add check if file exists and confirm overwrite
  if [[ -f "$export_file" ]]; then
      read -p "${YELLOW}æ–‡ä»¶ $export_file å·²å­˜åœ¨ã€‚æ˜¯å¦è¦†ç›–? (y/N): ${RESET}" overwrite
      if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
          echo -e "${YELLOW}[*] å¯¼å‡ºå·²å–æ¶ˆ.${RESET}"
          pause_and_return
          return 0
      fi
  fi

  # Execute from target directory
  (cd "$NCK_DIR/target/release/" && ./nockchain-wallet export-keys > "$export_file")
  local status=$?
  if [[ $status -eq 0 ]]; then
      echo -e "${GREEN}[+] å¯†é’¥å·²æˆåŠŸå¯¼å‡ºåˆ° $export_file${RESET}"
      echo -e "${YELLOW}è¯·åŠ¡å¿…å¤‡ä»½æ­¤æ–‡ä»¶åˆ°å®‰å…¨ä½ç½®ï¼${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å‡ºå¤±è´¥${RESET}"
  end_of_export_keys: # Label for potential jump (not used here, but good practice to remember)
  fi

  pause_and_return
}

function import_keys() {
  echo -e "${CYAN}[*] å¯¼å…¥é’±åŒ…å¯†é’¥...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  check_wallet_executable || { pause_and_return; return 1; }

  local default_keyfile="$NCK_DIR/keys.export"
  read -p "[?] è¯·è¾“å…¥è¦å¯¼å…¥çš„å¯†é’¥æ–‡ä»¶è·¯å¾„ (é»˜è®¤: $default_keyfile): " keyfile
  local keyfile_path=${keyfile:-"$default_keyfile"}

  if [[ ! -f "$keyfile_path" ]]; then
      echo -e "${RED}[-] é”™è¯¯: å¯†é’¥æ–‡ä»¶ '$keyfile_path' ä¸å­˜åœ¨${RESET}"
      pause_and_return
      return 1
  fi

  echo -e "${YELLOW}[!] æ­£åœ¨å¯¼å…¥å¯†é’¥...è¿™å°†å°è¯•å°†å¯†é’¥å¯¼å…¥åˆ°æ‚¨çš„ Nockchain é’±åŒ…å­˜å‚¨ä¸­ã€‚${RESET}"
  # Use < to pipe file content to stdin of the command
  # Execute from target directory
  (cd "$NCK_DIR/target/release/" && cat "$keyfile_path" | ./nockchain-wallet import-keys --input -)
  local status=$?
  if [[ $status -eq 0 ]]; then
      echo -e "${GREEN}[+] å¯†é’¥å·²æˆåŠŸå¯¼å…¥${RESET}"
      echo -e "${YELLOW}å¯¼å…¥æˆåŠŸåï¼Œæ‚¨å¯ä»¥è€ƒè™‘åˆ é™¤åŸå§‹å¯¼å‡ºæ–‡ä»¶ä»¥å¢å¼ºå®‰å…¨${RESET}"
  else
      echo -e "${RED}[-] å¯†é’¥å¯¼å…¥å¤±è´¥${RESET}"
      echo -e "${YELLOW}è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Œæˆ–å°è¯•æ‰‹åŠ¨è¿è¡Œå‘½ä»¤è°ƒè¯•:${RESET}"
      echo -e "${YELLOW}cat '$keyfile_path' | '$NCK_DIR/target/release/nockchain-wallet' import-keys --input -${RESET}"
  fi

  pause_and_return
}

# ========= èŠ‚ç‚¹ç®¡ç†å‡½æ•° =========

# é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°
function configure_mining_threads() {
    echo -e "${CYAN}[*] é…ç½®æŒ–çŸ¿çº¿ç¨‹æ•°...${RESET}"
    cd_nck_dir || { pause_and_return; return 1; } # Ensure .env is accessible

    if [[ ! -f "$ENV_FILE" ]]; then
        echo -e "${RED}[-] é”™è¯¯: .env æ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
        pause_and_return
        return 1
    fi

    local current_threads=$(get_env "MINING_THREADS")
    local num_cores=$(get_num_cores)

    if [[ -z "$current_threads" || ! "$current_threads" =~ ^[1-9][0-9]*$ ]]; then
         echo -e "å½“å‰é…ç½®çš„æŒ–çŸ¿çº¿ç¨‹æ•°: ${YELLOW}æœªè®¾ç½®æˆ–æ— æ•ˆ${RESET}"
         echo -e "ç³»ç»Ÿæ£€æµ‹åˆ°çš„æ ¸å¿ƒæ•°: ${GREEN}$num_cores${RESET}"
         read -p "è¯·è¾“å…¥æ–°çš„æŒ–çŸ¿çº¿ç¨‹æ•° (å»ºè®® ${num_cores}, ç•™ç©ºä½¿ç”¨é»˜è®¤ ${num_cores}): " new_threads
         local final_threads=${new_threads:-"$num_cores"}
    else
        echo -e "å½“å‰é…ç½®çš„æŒ–çŸ¿çº¿ç¨‹æ•°: ${YELLOW}$current_threads${RESET}"
        echo -e "ç³»ç»Ÿæ£€æµ‹åˆ°çš„æ ¸å¿ƒæ•°: ${GREEN}$num_cores${RESET}"
        read -p "è¯·è¾“å…¥æ–°çš„æŒ–çŸ¿çº¿ç¨‹æ•° (ç•™ç©ºä½¿ç”¨å½“å‰å€¼ $current_threads): " new_threads
        local final_threads=${new_threads:-"$current_threads"}
    fi


    # æ ¡éªŒè¾“å…¥æ˜¯å¦ä¸ºæ­£æ•´æ•°
    if [[ "$final_threads" =~ ^[1-9][0-9]*$ ]]; then
        if [[ "$final_threads" != "$current_threads" ]]; then
            update_env "MINING_THREADS" "$final_threads" || { pause_and_return; return 1; }
            echo -e "${GREEN}[+] æŒ–çŸ¿çº¿ç¨‹æ•°å·²æ›´æ–°ä¸º $final_threads${RESET}"
             echo -e "${YELLOW}æ³¨æ„: æ–°çº¿ç¨‹æ•°å°†åœ¨ä¸‹æ¬¡å¯åŠ¨èŠ‚ç‚¹æ—¶ç”Ÿæ•ˆã€‚${RESET}"
        else
            echo -e "${YELLOW}[*] çº¿ç¨‹æ•°æœªæ”¹å˜ï¼Œä¿æŒä¸º $current_threads${RESET}"
        fi
    else
        echo -e "${RED}[-] è¾“å…¥æ— æ•ˆ '$final_threads'ï¼Œçº¿ç¨‹æ•°å¿…é¡»æ˜¯æ­£æ•´æ•°ã€‚${RESET}"
    fi
    pause_and_return
}


function check_node_executable() {
    if [[ ! -x "$NCK_DIR/target/release/nockchain" ]]; then
        echo -e "${RED}[-] èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–æ— æ‰§è¡Œæƒé™ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
        return 1
    fi
    return 0
}

function start_node() {
  echo -e "${CYAN}[*] å¯åŠ¨èŠ‚ç‚¹ (åœ¨ screen åå°è¿è¡Œï¼Œå¸¦è‡ªåŠ¨é‡å¯)...${RESET}"
  cd_nck_dir || { pause_and_return; return 1; }
  check_node_executable || { pause_and_return; return 1; }

  # Ensure .env exists and parameters are set
   if [[ ! -f "$ENV_FILE" ]]; then
        echo -e "${RED}[-] é”™è¯¯: .env æ–‡ä»¶ä¸å­˜åœ¨ã€‚è¯·å…ˆè¿è¡Œ '1) ä¸€é”®å®‰è£…å¹¶æ„å»º'${RESET}"
        pause_and_return; return 1;
   fi

  local mining_pubkey=$(get_env "MINING_PUBKEY")
  local mining_threads=$(get_env "MINING_THREADS")
  local num_cores=$(get_num_cores)

  if [[ -z "$mining_pubkey" ]]; then
    echo -e "${RED}[-] é”™è¯¯: MINING_PUBKEY æœªåœ¨ .env æ–‡ä»¶ä¸­è®¾ç½®ã€‚è¯·è¿è¡Œ '3) è®¾ç½® MINING_PUBKEY' è¿›è¡Œé…ç½®ã€‚${RESET}"
    pause_and_return; return 1;
  fi

  # Validate and default threads if needed
  if [[ -z "$mining_threads" || ! "$mining_threads" =~ ^[1-9][0-9]*$ ]]; then
        echo -e "${YELLOW}[*] MINING_THREADS æœªåœ¨ .env ä¸­è®¾ç½®æˆ–æ— æ•ˆï¼Œä½¿ç”¨ç³»ç»Ÿæ ¸å¿ƒæ•° ($num_cores) ä½œä¸ºé»˜è®¤å€¼${RESET}"
        mining_threads="$num_cores"
        # We don't auto-update .env here to avoid unexpected changes if user didn't explicitly set it.
        # They can use option 6 to make it permanent.
  fi

  echo -e "${CYAN}[*] ä½¿ç”¨ä»¥ä¸‹å‚æ•°å¯åŠ¨èŠ‚ç‚¹:${RESET}"
  echo -e "  MINING_PUBKEY: ${YELLOW}$mining_pubkey${RESET}"
  echo -e "  THREADS:       ${YELLOW}$mining_threads${RESET}"
  echo -e "  Log File:      ${CYAN}$LOG_FILE_FRIENDLY${RESET}"


  # Check and terminate old screen session
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[*] æ£€æµ‹åˆ°æ—§çš„ screen ä¼šè¯ 'nockchain'ï¼Œæ­£åœ¨å…³é—­...${RESET}"
    # Send Ctrl+C to the session for graceful shutdown first
    screen -S nockchain -X stuff "^C" || true # Use true in case session is already exiting/problematic
    echo -e "${YELLOW}[*] ç­‰å¾… 5 ç§’è®©èŠ‚ç‚¹ä¼˜é›…é€€å‡º...${RESET}"
    sleep 5 # Give it time to shut down
    if screen -list | grep -qw "nockchain"; then
        echo -e "${YELLOW}[*] èŠ‚ç‚¹æœªä¼˜é›…é€€å‡ºï¼Œå°è¯•å¼ºåˆ¶ç»ˆæ­¢ screen ä¼šè¯...${RESET}"
        screen -S nockchain -X quit || true # Use || true so script doesn't exit if screen quit fails initially
        # Give it a moment to terminate
        sleep 2
        if screen -list | grep -qw "nockchain"; then
            echo -e "${RED}[-] æ— æ³•ç»ˆæ­¢æ—§çš„ screen ä¼šè¯ï¼Œè¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit' æˆ– 'killall screen'${RESET}"
            pause_and_return; return 1;
        fi
    fi
    echo -e "${GREEN}[+] æ—§çš„ screen ä¼šè¯å·²å…³é—­${RESET}"
  fi

  # Create log directory if it doesn't exist - still useful for potential symlinks or future features
  mkdir -p "$LOG_DIR" || { echo -e "${RED}[-] é”™è¯¯: åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥ $LOG_DIR${RESET}"; pause_and_return; return 1; }

  # Clear the log file ONCE before the screen session starts.
  if [[ -f "$LOG_FILE_FRIENDLY" ]]; then
      echo -e "${YELLOW}[*] æ¸…é™¤æ—§æ—¥å¿—æ–‡ä»¶ $LOG_FILE_FRIENDLY ...${RESET}"
      # Use echo -n > to clear without adding a newline
      echo -n > "$LOG_FILE_FRIENDLY"
  fi

  # Ensure the directory exists before tee tries to write (redundant check but harmless)
  mkdir -p "$(dirname "$LOG_FILE_FRIENDLY")" || { echo -e "${RED}[-] é”™è¯¯: åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥ $LOG_DIR${RESET}"; pause_and_return; return 1; }


  # Construct the command to run inside screen
  # Source .env, export MINING vars, then run node in a while loop with a delay, piping output to tee for logging.
  # Changed path to nockchain executable to be relative to $NCK_DIR
  local screen_cmd_with_log="cd \"$NCK_DIR\" && \
source \"$ENV_FILE\" 2>/dev/null; \
export MINING_PUBKEY=\"$mining_pubkey\"; \
export MINING_THREADS=\"$mining_threads\"; \
echo -e \"${GREEN}>>> Nockchain Miner starting (PID \$\$), logging to $LOG_FILE_FRIENDLY...${RESET}\"; \
while true; do \
  echo -e \"\n${YELLOW}>>> $(date '+%Y-%m-%d %H:%M:%S') - Starting miner instance...${RESET}\" | tee -a \"$LOG_FILE_FRIENDLY\"; \
  # The loop structure requires the shell process to remain to handle the sleep and next iteration.
  \"$NCK_DIR/target/release/nockchain\" --threads \"\$MINING_THREADS\" 2>&1 | tee -a \"$LOG_FILE_FRIENDLY\"; \
  echo -e \"\n${RED}>>> $(date '+%Y-%m-%d %H:%M:%S') - Miner exited with status \$?. Restarting in 10 seconds...${RESET}\" | tee -a \"$LOG_FILE_FRIENDLY\"; \
  sleep 10; \
done"

  # Start new screen session
  # Use -L to automatically log screen output to screenlog.0, which is in NCK_DIR
  # This is redundant with tee, but can be a fallback. Let's rely on tee for our LOG_FILE_FRIENDLY.
  # screen -dmSL nockchain bash -c "$screen_cmd_with_log"
  # Just use -dmS
  screen -dmS nockchain bash -c "$screen_cmd_with_log"


  # Give screen a moment to start and run the command
  sleep 3

  # Check if the screen session is running
  if screen -list | grep -qw "nockchain"; then
    echo -e "${GREEN}===============================================${RESET}"
    echo -e "${GREEN}         âœ… èŠ‚ç‚¹å·²åœ¨ screen åå°å¯åŠ¨ âœ…         ${RESET}"
    echo -e "${GREEN}===============================================${RESET}"
    echo -e "èŠ‚ç‚¹å·²åœ¨ screen ä¼šè¯ 'nockchain' ä¸­å¯åŠ¨ï¼Œå¹¶é…ç½®äº†è‡ªåŠ¨é‡å¯ã€‚"
    echo -e "æŒ–çŸ¿å¥–åŠ±å°†å‘é€åˆ°å…¬é’¥: ${YELLOW}$mining_pubkey${RESET}"
    echo -e "å½“å‰ä½¿ç”¨çš„çº¿ç¨‹æ•°: ${YELLOW}$mining_threads${RESET}"
    echo ""
    echo -e "${YELLOW}é‡è¦æç¤º:${RESET}"
    echo -e "  - ä½¿ç”¨ '${CYAN}screen -r nockchain${RESET}' è¿›å…¥ä¼šè¯æŸ¥çœ‹å®æ—¶è¾“å‡ºã€‚"
    echo -e "    ä¼šè¯å†…æŒ‰ '${YELLOW}Ctrl+A ç„¶åæŒ‰ D${RESET}${YELLOW}' å¯é€€å‡º screen ä¼šè¯å¹¶ä¿æŒèŠ‚ç‚¹è¿è¡Œã€‚"
    echo -e "  - æ—¥å¿—æ–‡ä»¶è·¯å¾„: ${CYAN}$LOG_FILE_FRIENDLY${RESET}"
    echo -e "  - ä½¿ç”¨é€‰é¡¹ ${YELLOW}9) å®æ—¶è·Ÿè¸ªèŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶${RESET} æ¥å®æ—¶è·Ÿè¸ªæ—¥å¿— (æ¨èï¼Œæ›´æ–¹ä¾¿)ã€‚"
    echo -e "  - ä½¿ç”¨é€‰é¡¹ ${YELLOW}11) è¿‡æ»¤æ—¥å¿—æŸ¥çœ‹åŒºå—ä¿¡æ¯${RESET} å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æŒ–åˆ°åŒºå—ã€‚"
  else
    echo -e "${RED}===============================================${RESET}"
    echo -e "${RED}         âŒ èŠ‚ç‚¹å¯åŠ¨å¤±è´¥ âŒ         ${RESET}"
    echo -e "${RED}===============================================${RESET}"
    echo -e "è¯·å°è¯•æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶ ${CYAN}$LOG_FILE_FRIENDLY${RESET} æˆ–æ‰‹åŠ¨è¿è¡Œå‘½ä»¤è¿›è¡Œè°ƒè¯•:"
    echo -e "${YELLOW}  cd $NCK_DIR && source \"$ENV_FILE\" && export MINING_PUBKEY=\"$mining_pubkey\" && export MINING_THREADS=\"$mining_threads\" && \"$NCK_DIR/target/release/nockchain\" --threads \"\$MINING_THREADS\"${RESET}"
    # Attempt to show any output from the screen session if it exited quickly
    if [[ -f "$LOG_FILE_FRIENDLY" ]]; then
        echo -e "${YELLOW}--- æœ€è¿‘çš„æ—¥å¿—æ–‡ä»¶å†…å®¹ ($LOG_FILE_FRIENDLY) ---${RESET}"
        # Show more lines for debugging
        tail -n 30 "$LOG_FILE_FRIENDLY" || true
        echo -e "${YELLOW}-------------------------${RESET}"
    fi
    pause_and_return; return 1;
  fi

  pause_and_return
  return 0
}

function view_screen_logs() {
  echo -e "${CYAN}[*] æŸ¥çœ‹ screen ä¼šè¯ 'nockchain' çš„å®æ—¶è¾“å‡º (è¿›å…¥ä¼šè¯)...${RESET}"
  if screen -list | grep -qw "nockchain"; then
    echo -e "${YELLOW}[!] æ­£åœ¨è¿›å…¥ screen ä¼šè¯ã€‚åœ¨ä¼šè¯ä¸­æŒ‰ '${BOLD}Ctrl+A ç„¶åæŒ‰ D${RESET}${YELLOW}' å¯é€€å‡º screen ä¼šè¯å¹¶ä¿æŒèŠ‚ç‚¹è¿è¡Œã€‚${RESET}"
    echo -e "${YELLOW}[!] æŒ‰ '${BOLD}Ctrl+C${RESET}${YELLOW}' å°†å°è¯•åœæ­¢å½“å‰èŠ‚ç‚¹è¿›ç¨‹ (ä½†ç”±äºè‡ªåŠ¨é‡å¯å¯èƒ½ä¼šç«‹å³é‡å¯)ã€‚${RESET}"
    # Attempt to attach to screen session
    # Check if screen is already attached to avoid "Cannot attach to a detached screen session"
    # screen -list output is like "ID.sessionname (status)" e.g., "1234.nockchain (Detached)" or "5678.nockchain (Attached)"
    # We want to attach if it's Detached or just exists.
    # The `screen -r` command itself handles both cases (attaching if detached, or showing message if attached).
    # Let's simplify the check to just if the session name exists, and rely on `screen -r` to do the right thing.
    # If it's attached elsewhere, `screen -r` will tell the user.
    screen -r nockchain || echo -e "${RED}[-] æ— æ³•é™„åŠ åˆ° screen ä¼šè¯ 'nockchain'ã€‚å¯èƒ½æ˜¯æƒé™é—®é¢˜ã€ä¼šè¯çŠ¶æ€å¼‚å¸¸æˆ–ä¼šè¯å·²é€€å‡ºã€‚${RESET}"

  else
    echo -e "${RED}[-] èŠ‚ç‚¹æœªåœ¨ screen ä¼šè¯ 'nockchain' ä¸­è¿è¡Œã€‚è¯·å…ˆå¯åŠ¨èŠ‚ç‚¹ (é€‰é¡¹ 7)ã€‚${RESET}"
  fi
  pause_and_return
}

function view_log_file() {
    echo -e "${CYAN}[*] å®æ—¶æŸ¥çœ‹èŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶ $LOG_FILE_FRIENDLY ...${RESET}"
    echo -e "${YELLOW}[!] æ­£åœ¨ tail -f æ—¥å¿—æ–‡ä»¶ (Ctrl+C é€€å‡º)...${RESET}"
    # Ensure log directory exists before tailing
    mkdir -p "$LOG_DIR" || { echo -e "${RED}[-] é”™è¯¯: åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥ $LOG_DIR${RESET}"; pause_and_return; return 1; }

    # Start tailing, handle potential errors like file not found initially
    # Use || true so that if tail fails (e.g. file doesn't exist yet), the script doesn't exit due to set -e
    # Add a brief sleep before tailing in case the file creation is slightly delayed after mkdir
    sleep 1
    tail -f "$LOG_FILE_FRIENDLY" || {
        echo -e "${RED}[-] tail -f å‘½ä»¤å¤±è´¥ã€‚è¯·ç¡®ä¿èŠ‚ç‚¹å·²ç»è¿è¡Œè¿‡ (é€‰é¡¹ 7) ä¸”æ—¥å¿—æ–‡ä»¶ '$LOG_FILE_FRIENDLY' å­˜åœ¨ã€‚${RESET}"
        echo -e "${YELLOW}å°è¯•æ‰‹åŠ¨æŸ¥çœ‹: less '$LOG_FILE_FRIENDLY'${RESET}"
    }
    pause_and_return
}

function filter_log_file() {
    echo -e "${CYAN}[*] è¿‡æ»¤èŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶ $LOG_FILE_FRIENDLY æŸ¥æ‰¾å…³é”®ä¿¡æ¯...${RESET}"
    if [[ ! -f "$LOG_FILE_FRIENDLY" ]]; then
         echo -e "${RED}[-] æ—¥å¿—æ–‡ä»¶ '$LOG_FILE_FRIENDLY' ä¸å­˜åœ¨ã€‚è¯·ç¡®ä¿èŠ‚ç‚¹å·²ç»è¿è¡Œè¿‡ (é€‰é¡¹ 7)ã€‚${RESET}"
         pause_and_return
         return 1
    fi

    echo -e "${YELLOW}æ­£åœ¨æœç´¢åŒ…å« 'Found block' æˆ– 'Mined block' æˆ– 'Successfully mined block' çš„æ—¥å¿—è¡Œ...${RESET}"
    echo "-----------------------------------------------"
    # Use egrep for extended regex (allowing | for OR) and --color=auto for highlighting
    egrep --color=auto "Found block|Mined block|Successfully mined block" "$LOG_FILE_FRIENDLY" || echo -e "${YELLOW}æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚${RESET}"
    echo "-----------------------------------------------"
    echo -e "${YELLOW}æ³¨æ„: Nockchain çš„æ—¥å¿—è¾“å‡ºå¯èƒ½ä¼šå› ç‰ˆæœ¬è€Œå¼‚ï¼Œè¯·æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´æœç´¢å…³é”®è¯ã€‚${RESET}"

    read -p "[?] æ˜¯å¦è¦æœç´¢å…¶ä»–å…³é”®è¯? (y/N): " search_other
    if [[ "$search_other" =~ ^[Yy]$ ]]; then
        read -p "è¯·è¾“å…¥è¦æœç´¢çš„å…³é”®è¯: " keyword
        if [[ -n "$keyword" ]]; then
            echo "-----------------------------------------------"
            # Use grep -i for case-insensitive search
            grep -i --color=auto "$keyword" "$LOG_FILE_FRIENDLY" || echo -e "${YELLOW}æœªæ‰¾åˆ°åŒ…å« '$keyword' çš„ä¿¡æ¯ã€‚${RESET}"
             echo "-----------------------------------------------"
        else
             echo -e "${YELLOW}[*] æœªè¾“å…¥å…³é”®è¯ï¼Œå–æ¶ˆæœç´¢ã€‚${RESET}"
        fi
    fi

    pause_and_return
}


function stop_node() {
    echo -e "${CYAN}[*] åœæ­¢èŠ‚ç‚¹ screen ä¼šè¯...${RESET}"
    if screen -list | grep -qw "nockchain"; then
        echo -e "${YELLOW}[*] æ£€æµ‹åˆ° screen ä¼šè¯ 'nockchain'ï¼Œæ­£åœ¨å°è¯•å‘é€ Ctrl+C è¿›è¡Œä¼˜é›…å…³é—­...${RESET}"
        # Send Ctrl+C to the screen session
        screen -S nockchain -X stuff "^C" || true # Don't exit script if sending stuff fails
        # Give it a moment to terminate gracefully
        echo -e "${YELLOW}[*] ç­‰å¾… 10 ç§’è®©èŠ‚ç‚¹ä¼˜é›…é€€å‡º (èŠ‚ç‚¹å†…çš„è‡ªåŠ¨é‡å¯ä¼šå°è¯•æ¥ç®¡ï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡ Ctrl+C)...${RESET}"
        sleep 10
        # After sending Ctrl+C, the miner *might* be in its restart loop if it crashed.
        # A single Ctrl+C stops the current miner instance. The loop then sleeps and restarts.
        # We need to kill the screen session itself to stop the loop.
        if screen -list | grep -qw "nockchain"; then
             echo -e "${YELLOW}[*] screen ä¼šè¯ 'nockchain' ä»åœ¨è¿è¡Œï¼Œå°è¯•å¼ºåˆ¶ç»ˆæ­¢ screen ä¼šè¯...${RESET}"
            screen -S nockchain -X quit || true # Don't exit script if quit fails
             sleep 2 # Give it another moment
             if screen -list | grep -qw "nockchain"; then
                 echo -e "${RED}[-] é”™è¯¯: æ— æ³•ç»ˆæ­¢ screen ä¼šè¯ 'nockchain'ã€‚è¯·æ‰‹åŠ¨æ‰§è¡Œ 'screen -S nockchain -X quit' æˆ– 'killall screen'${RESET}"
                  pause_and_return; return 1;
             else
                 echo -e "${GREEN}[+] screen ä¼šè¯ 'nockchain' å·²å¼ºåˆ¶åœæ­¢${RESET}"
             fi
        else
            echo -e "${GREEN}[+] screen ä¼šè¯ 'nockchain' å·²åœæ­¢${RESET}"
        fi
    else
        echo -e "${YELLOW}[*] screen ä¼šè¯ 'nockchain' æœªè¿è¡Œ${RESET}"
    fi
    pause_and_return
    return 0
}


# ========= ä¸»èœå• =========
function main_menu() {
  while true; do
    show_banner
    echo -e "${BOLD}è¯·é€‰æ‹©æ“ä½œ:${RESET}"
    echo -e "  ${GREEN}1) ä¸€é”®å®‰è£…å¹¶æ„å»º (é¦–æ¬¡è¿è¡Œå»ºè®®)${RESET}"
    echo -e "  -----------------------------------------------"
    echo -e "  ${BLUE}é’±åŒ…ç®¡ç†:${RESET}"
    echo -e "  ${BLUE}2) ç”Ÿæˆæ–°çš„é’±åŒ…å¯†é’¥å¯¹å¹¶æ˜¾ç¤º (è¯·è®°å½•å…¬é’¥)${RESET}"
    echo -e "  ${BLUE}3) è®¾ç½®/æ›´æ–° MINING_PUBKEY åˆ° .env${RESET}"
    echo -e "  ${BLUE}4) å¯¼å‡ºé’±åŒ…å¯†é’¥åˆ°æ–‡ä»¶ ($NCK_DIR/keys.export)${RESET}"
    echo -e "  ${BLUE}5) ä»æ–‡ä»¶å¯¼å…¥é’±åŒ…å¯†é’¥${RESET}"
    echo -e "  -----------------------------------------------"
    echo -e "  ${YELLOW}é…ç½®ä¼˜åŒ–:${RESET}"
    echo -e "  ${YELLOW}6) é…ç½®/æ›´æ–°æŒ–çŸ¿çº¿ç¨‹æ•° (MINING_THREADS)${RESET}"
    echo -e "  -----------------------------------------------"
    echo -e "  ${CYAN}èŠ‚ç‚¹è¿è¡Œ:${RESET}"
    echo -e "  ${CYAN}7) å¯åŠ¨èŠ‚ç‚¹ (åœ¨ screen åå°è¿è¡Œï¼Œå¸¦è‡ªåŠ¨é‡å¯)${RESET}"
    echo -e "  ${CYAN}8) æŸ¥çœ‹èŠ‚ç‚¹ screen å®æ—¶è¾“å‡º (è¿›å…¥ä¼šè¯)${RESET}"
    echo -e "  ${CYAN}9) å®æ—¶è·Ÿè¸ªèŠ‚ç‚¹æ—¥å¿—æ–‡ä»¶ (tail -f ${LOG_FILE_FRIENDLY})${RESET}"
    echo -e "  ${CYAN}11) è¿‡æ»¤æ—¥å¿—æŸ¥çœ‹åŒºå—å‘ç°ä¿¡æ¯${RESET}"
    echo -e "  ${RED}10) åœæ­¢èŠ‚ç‚¹ screen ä¼šè¯${RESET}"
    echo -e "  -----------------------------------------------"
    echo -e "  ${RED}0) é€€å‡ºè„šæœ¬${RESET}"
    echo ""
    read -p "${BOLD}è¯·è¾“å…¥ç¼–å·: ${RESET}" choice

    echo "" # Add a newline after input
    case "$choice" in
      1) setup_all ;;
      2) generate_wallet ;;
      3) set_pubkey_env ;;
      4) export_keys ;;
      5) import_keys ;;
      6) configure_mining_threads ;;
      7) start_node ;;
      8) view_screen_logs ;;
      9) view_log_file ;;
      11) filter_log_file ;; # New option
      10) stop_node ;;
      0) echo -e "${YELLOW}é€€å‡ºè„šæœ¬.${RESET}"; exit 0 ;;
      *) echo -e "${RED}[-] æ— æ•ˆé€‰é¡¹ '$choice'ï¼Œè¯·é‡æ–°è¾“å…¥${RESET}" ;;
    esac
  done
}

# ========= è„šæœ¬å…¥å£ =========

# ç¡®ä¿ä¾èµ–å‘½ä»¤å¯ç”¨
echo -e "${CYAN}[*] æ£€æŸ¥ç³»ç»Ÿä¾èµ–å‘½ä»¤...${RESET}"
if ! command_exists screen; then
    echo -e "${RED}é”™è¯¯: screen å‘½ä»¤æœªæ‰¾åˆ°ã€‚è¯·å…ˆå®‰è£…: sudo apt update && sudo apt install screen${RESET}"
    exit 1
fi

# Check for at least one download utility
if ! command_exists wget && ! command_exists curl; then
    echo -e "${RED}é”™è¯¯: wget æˆ– curl å‘½ä»¤æœªæ‰¾åˆ°ã€‚Rust å®‰è£…éœ€è¦å…¶ä¸­ä¸€ä¸ªã€‚è¯·å…ˆå®‰è£…ã€‚${RESET}"
    exit 1
fi

# Warn if nproc is missing, but don't exit. get_num_cores handles fallback.
command_exists nproc || echo -e "${YELLOW}è­¦å‘Š: nproc å‘½ä»¤æœªæ‰¾åˆ°ï¼Œæ— æ³•è‡ªåŠ¨æ£€æµ‹æ ¸å¿ƒæ•°ã€‚é»˜è®¤æŒ–çŸ¿çº¿ç¨‹æ•°å¯èƒ½å—åˆ°å½±å“ã€‚${RESET}"

echo -e "${GREEN}[+] ä¾èµ–å‘½ä»¤æ£€æŸ¥å®Œæˆ${RESET}"
echo ""

# Always show the main menu in this version
main_menu

exit 0 # Script exits cleanly from the menu loop
