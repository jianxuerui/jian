#!/bin/bash
# -*- coding: UTF-8 -*-
# Nockchain智能安装脚本 v6.0 - 彻底解决Miniconda冲突

# 颜色定义
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RESET='\033[0m'

# 路径配置
INSTALL_PREFIX="$HOME/.local"
NOCKCHAIN_DIR="$HOME/nockchain"
LOG_FILE="$HOME/nockchain_install.log"
BACKUP_DIR="$HOME/nockchain_backup"
MINICONDA_DIR="$HOME/.miniconda3"

# 优化环境变量
export PATH="$INSTALL_PREFIX/bin:$HOME/.cargo/bin:$PATH"
export RUST_MIN_STACK=16777216
export RUST_LOG=error
export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1"
export CARGO_BUILD_JOBS=1
export MALLOC_ARENA_MAX=2

# 消息输出函数
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${RESET}"
}

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

check_command() {
    command -v "$1" >/dev/null 2>&1
}

# 显示主菜单
show_menu() {
    clear
    echo -e "${BLUE}
=======================================
 Nockchain 智能安装脚本 v6.0
=======================================
${RESET}"
    echo -e "${YELLOW}1. 智能完整安装（自动解决所有冲突）"
    echo "2. 配置挖矿公钥"
    echo "3. 启动优化挖矿"
    echo "4. 查看实时日志"
    echo "5. 检查钱包余额"
    echo "6. 系统状态监控"
    echo "7. 备份钱包密钥"
    echo "8. 修复环境问题"
    echo "9. 退出脚本"
    echo -e "${BLUE}=======================================${RESET}"
}

# 智能检测并处理Miniconda冲突
handle_miniconda_conflict() {
    print_message "$CYAN" "正在检测Miniconda安装状态..."
    
    if [ -d "$MINICONDA_DIR" ]; then
        print_message "$YELLOW" "检测到现有Miniconda安装目录: $MINICONDA_DIR"
        
        # 检查是否为有效安装
        if [ -f "$MINICONDA_DIR/bin/conda" ] && "$MINICONDA_DIR/bin/conda" --version >/dev/null 2>&1; then
            print_message "$GREEN" "现有Miniconda安装有效"
            
            # 检查版本
            local conda_version=$("$MINICONDA_DIR/bin/conda" --version 2>/dev/null)
            print_message "$YELLOW" "当前版本: $conda_version"
            
            read -p "是否使用现有安装？(Y/n): " use_existing
            if [[ ! "$use_existing" =~ ^[Nn]$ ]]; then
                export PATH="$MINICONDA_DIR/bin:$PATH"
                source "$MINICONDA_DIR/etc/profile.d/conda.sh" 2>/dev/null || true
                print_message "$GREEN" "使用现有Miniconda安装"
                return 0
            fi
        else
            print_message "$YELLOW" "现有安装无效或损坏"
        fi
        
        # 处理无效或用户选择重新安装的情况
        print_message "$CYAN" "选择处理方式："
        echo "1. 完全清理并重新安装（推荐）"
        echo "2. 尝试更新现有安装"
        echo "3. 备份现有安装并重新安装"
        
        read -p "请选择（1-3）: " choice
        case $choice in
            1)
                print_message "$CYAN" "完全清理现有安装..."
                clean_miniconda_completely
                ;;
            2)
                print_message "$CYAN" "尝试更新现有安装..."
                update_existing_miniconda
                return $?
                ;;
            3)
                print_message "$CYAN" "备份现有安装..."
                backup_existing_miniconda
                clean_miniconda_completely
                ;;
            *)
                print_message "$RED" "无效选择，默认完全清理"
                clean_miniconda_completely
                ;;
        esac
    fi
    
    # 执行全新安装
    install_miniconda_fresh
}

# 完全清理Miniconda
clean_miniconda_completely() {
    print_message "$CYAN" "正在完全清理Miniconda..."
    
    # 停止所有conda相关进程
    pkill -f conda 2>/dev/null || true
    pkill -f python 2>/dev/null || true
    
    # 删除安装目录
    if [ -d "$MINICONDA_DIR" ]; then
        rm -rf "$MINICONDA_DIR"
        print_message "$GREEN" "已删除Miniconda目录"
    fi
    
    # 清理环境变量配置
    local shell_configs=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    for config in "${shell_configs[@]}"; do
        if [ -f "$config" ]; then
            # 备份原配置
            cp "$config" "$config.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
            
            # 删除conda相关行
            sed -i '/miniconda3/d' "$config" 2>/dev/null || true
            sed -i '/conda initialize/,/conda initialize/d' "$config" 2>/dev/null || true
        fi
    done
    
    # 清理其他相关文件
    rm -rf ~/.conda 2>/dev/null || true
    rm -rf ~/.condarc 2>/dev/null || true
    rm -rf ~/.anaconda_backup 2>/dev/null || true
    
    print_message "$GREEN" "Miniconda完全清理完成"
    log_message "Miniconda完全清理完成"
}

# 备份现有安装
backup_existing_miniconda() {
    print_message "$CYAN" "正在备份现有Miniconda安装..."
    
    local backup_path="$BACKUP_DIR/miniconda_backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_path"
    
    # 备份重要配置和环境
    if [ -d "$MINICONDA_DIR/envs" ]; then
        cp -r "$MINICONDA_DIR/envs" "$backup_path/" 2>/dev/null || true
    fi
    
    if [ -f "$HOME/.condarc" ]; then
        cp "$HOME/.condarc" "$backup_path/" 2>/dev/null || true
    fi
    
    # 导出环境列表
    if [ -f "$MINICONDA_DIR/bin/conda" ]; then
        "$MINICONDA_DIR/bin/conda" env list > "$backup_path/env_list.txt" 2>/dev/null || true
    fi
    
    print_message "$GREEN" "备份完成: $backup_path"
    log_message "Miniconda备份完成: $backup_path"
}

# 尝试更新现有安装
update_existing_miniconda() {
    print_message "$CYAN" "正在尝试更新现有Miniconda安装..."
    
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "不支持的架构: $arch"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_updater.sh"
    
    # 下载安装程序
    if ! wget -q --show-progress "$MINICONDA_URL" -O "$installer"; then
        print_message "$RED" "下载Miniconda安装程序失败"
        return 1
    fi
    
    chmod +x "$installer"
    
    # 尝试使用-u选项更新
    if bash "$installer" -b -u -p "$MINICONDA_DIR"; then
        print_message "$GREEN" "Miniconda更新成功"
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        export PATH="$MINICONDA_DIR/bin:$PATH"
        rm -f "$installer"
        return 0
    else
        print_message "$YELLOW" "更新失败，将执行完全重新安装"
        rm -f "$installer"
        return 1
    fi
}

# 全新安装Miniconda
install_miniconda_fresh() {
    print_message "$CYAN" "正在执行Miniconda全新安装..."
    
    local arch=$(uname -m)
    case $arch in
        x86_64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh" ;;
        aarch64) MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh" ;;
        *) print_message "$RED" "不支持的架构: $arch"; return 1 ;;
    esac
    
    local installer="/tmp/miniconda_installer.sh"
    
    # 下载安装程序
    print_message "$CYAN" "下载Miniconda安装程序..."
    if ! wget -q --show-progress "$MINICONDA_URL" -O "$installer"; then
        print_message "$RED" "下载失败，请检查网络连接"
        return 1
    fi
    
    chmod +x "$installer"
    
    # 静默安装
    print_message "$CYAN" "正在安装Miniconda..."
    if bash "$installer" -b -p "$MINICONDA_DIR"; then
        print_message "$GREEN" "Miniconda安装成功"
        
        # 初始化conda
        source "$MINICONDA_DIR/etc/profile.d/conda.sh"
        export PATH="$MINICONDA_DIR/bin:$PATH"
        
        # 配置conda
        conda config --set auto_activate_base false
        conda config --set channel_priority strict
        
        # 清理安装文件
        rm -f "$installer"
        
        print_message "$GREEN" "Miniconda配置完成"
        log_message "Miniconda全新安装完成"
        return 0
    else
        print_message "$RED" "Miniconda安装失败"
        rm -f "$installer"
        return 1
    fi
}

# 安装编译环境
setup_build_environment() {
    print_message "$CYAN" "正在设置编译环境..."
    
    # 确保conda可用
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    export PATH="$MINICONDA_DIR/bin:$PATH"
    
    # 创建专用编译环境
    print_message "$CYAN" "创建Nockchain编译环境..."
    conda create -n nockchain-build -y python=3.9 --no-default-packages || {
        print_message "$YELLOW" "环境已存在，正在更新..."
    }
    
    # 激活环境
    conda activate nockchain-build
    
    # 逐步安装编译工具（避免内存峰值）
    local tools=("gcc_linux-64" "make" "cmake" "clang" "pkg-config" "openssl" "git")
    
    for tool in "${tools[@]}"; do
        print_message "$YELLOW" "安装 $tool..."
        conda install -y "$tool" -c conda-forge --quiet || {
            print_message "$YELLOW" "跳过 $tool（可能不可用）"
        }
        sleep 1  # 给系统一些喘息时间
    done
    
    print_message "$GREEN" "编译环境设置完成"
}

# 安装Rust工具链
install_rust_optimized() {
    print_message "$CYAN" "正在安装Rust工具链..."
    
    if check_command "rustc" && check_command "cargo"; then
        print_message "$YELLOW" "Rust已安装: $(rustc --version)"
        return 0
    fi
    
    # 下载并安装rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
        --default-toolchain stable \
        --profile minimal \
        --no-modify-path
    
    source "$HOME/.cargo/env"
    export PATH="$HOME/.cargo/bin:$PATH"
    
    # 配置Cargo进行内存优化编译
    mkdir -p "$HOME/.cargo"
    cat > "$HOME/.cargo/config.toml" << 'EOF'
[build]
jobs = 1

[profile.dev]
debug = false
opt-level = 1

[profile.release]
debug = false
lto = false
codegen-units = 1

[target.x86_64-unknown-linux-gnu]
linker = "clang"
EOF
    
    print_message "$GREEN" "Rust工具链安装完成"
}

# 编译Nockchain项目
compile_nockchain_optimized() {
    print_message "$CYAN" "开始编译Nockchain项目..."
    
    cd "$NOCKCHAIN_DIR" || return 1
    
    # 设置最优编译环境
    export RUST_MIN_STACK=16777216
    export RUSTFLAGS="-C debuginfo=0 -C opt-level=1 -C codegen-units=1"
    export CARGO_BUILD_JOBS=1
    export CARGO_INCREMENTAL=0
    export RUST_LOG=error
    export RUST_BACKTRACE=0
    
    # 激活conda环境
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    # 清理之前的编译结果
    print_message "$CYAN" "清理编译缓存..."
    rm -rf target/ || true
    cargo clean || true
    
    # 分步骤编译以减少内存压力
    print_message "$CYAN" "编译hoonc编译器..."
    if ! timeout 3600 make install-hoonc; then
        print_message "$YELLOW" "标准编译失败，尝试手动编译..."
        
        cd crates/hoonc
        cargo build --release --bin hoonc --jobs 1 || {
            print_message "$RED" "hoonc编译失败"
            return 1
        }
        
        # 手动安装
        cp target/release/hoonc "$HOME/.cargo/bin/"
        cd ../..
    fi
    
    # 等待内存释放
    sleep 5
    
    print_message "$CYAN" "编译主项目..."
    if ! timeout 3600 make build; then
        print_message "$RED" "主项目编译失败"
        return 1
    fi
    
    print_message "$CYAN" "安装组件..."
    make install-nockchain-wallet || print_message "$YELLOW" "钱包安装失败"
    make install-nockchain || print_message "$YELLOW" "主程序安装失败"
    
    print_message "$GREEN" "Nockchain编译完成！"
}

# 主安装函数
install_nockchain_intelligent() {
    print_message "$GREEN" ">>> 开始Nockchain智能安装..."
    log_message "开始智能安装流程"
    
    # 检查系统资源
    local total_ram=$(free -m 2>/dev/null | awk '/^Mem:/{print $2}' || echo "0")
    local available_space=$(df -m ~ 2>/dev/null | awk 'NR==2{print $4}' || echo "0")
    
    print_message "$YELLOW" "系统检查："
    print_message "$YELLOW" "- 内存: ${total_ram}MB"
    print_message "$YELLOW" "- 可用空间: ${available_space}MB"
    
    if [ "$total_ram" -lt 2048 ] && [ "$total_ram" -gt 0 ]; then
        print_message "$YELLOW" "警告：内存较低，将使用超级优化模式"
    fi
    
    # 创建必要目录
    mkdir -p "$BACKUP_DIR" "$INSTALL_PREFIX"/{bin,lib,include}
    
    # 步骤1：智能处理Miniconda
    print_message "$MAGENTA" "步骤 1/5: 智能处理Miniconda..."
    if ! handle_miniconda_conflict; then
        print_message "$RED" "Miniconda处理失败"
        return 1
    fi
    
    # 步骤2：设置编译环境
    print_message "$MAGENTA" "步骤 2/5: 设置编译环境..."
    if ! setup_build_environment; then
        print_message "$RED" "编译环境设置失败"
        return 1
    fi
    
    # 步骤3：安装Rust
    print_message "$MAGENTA" "步骤 3/5: 安装Rust工具链..."
    if ! install_rust_optimized; then
        print_message "$RED" "Rust安装失败"
        return 1
    fi
    
    # 步骤4：克隆项目
    print_message "$MAGENTA" "步骤 4/5: 获取Nockchain源码..."
    if [ -d "$NOCKCHAIN_DIR" ]; then
        print_message "$YELLOW" "更新现有项目..."
        cd "$NOCKCHAIN_DIR"
        git pull origin main || {
            cd "$HOME"
            rm -rf "$NOCKCHAIN_DIR"
            git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR"
        }
    else
        git clone https://github.com/zorp-corp/nockchain.git "$NOCKCHAIN_DIR" || {
            print_message "$RED" "项目克隆失败"
            return 1
        }
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 配置环境文件
    if [ -f ".env_example" ]; then
        cp .env_example .env
    else
        cat > .env << 'EOF'
MINING_PUBKEY=0000000000000000000000000000000000000000000000000000000000000000
NETWORK=mainnet
MAX_PEERS=2000
LOG_LEVEL=error
RUST_LOG=error
RUST_MIN_STACK=16777216
EOF
    fi
    
    # 步骤5：编译项目
    print_message "$MAGENTA" "步骤 5/5: 编译Nockchain..."
    if ! compile_nockchain_optimized; then
        print_message "$RED" "项目编译失败"
        return 1
    fi
    
    # 生成钱包
    if check_command "nockchain-wallet"; then
        print_message "$CYAN" "生成钱包..."
        local wallet_output
        wallet_output=$(nockchain-wallet keygen 2>&1)
        
        if [ $? -eq 0 ]; then
            print_message "$GREEN" "钱包生成成功！"
            echo "$wallet_output"
            
            local pubkey=$(echo "$wallet_output" | grep -E "Public key:|公钥:" | awk '{print $NF}')
            if [ -n "$pubkey" ]; then
                sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$pubkey/" .env
                print_message "$GREEN" "公钥自动配置完成"
            fi
            
            echo "$wallet_output" > "$BACKUP_DIR/wallet_$(date +%Y%m%d_%H%M%S).txt"
        fi
    fi
    
    # 创建便捷启动脚本
    cat > "$HOME/nockchain_env.sh" << 'EOF'
#!/bin/bash
# Nockchain环境激活脚本
source "$HOME/.miniconda3/etc/profile.d/conda.sh"
conda activate nockchain-build
export RUST_MIN_STACK=16777216
export RUST_LOG=error
export PATH="$HOME/.cargo/bin:$PATH"
cd "$HOME/nockchain"
echo "Nockchain环境已激活"
echo "使用 'make run-nockchain' 启动挖矿"
EOF
    chmod +x "$HOME/nockchain_env.sh"
    
    print_message "$GREEN" "🎉 Nockchain智能安装完成！"
    print_message "$YELLOW" "安装路径: $NOCKCHAIN_DIR"
    print_message "$YELLOW" "环境激活: source ~/nockchain_env.sh"
    print_message "$CYAN" "所有冲突问题已彻底解决！"
    
    log_message "智能安装流程完成"
}

# 验证公钥格式
validate_pubkey() {
    local pubkey=$1
    if [[ $pubkey =~ ^[0-9a-fA-F]{128}$ ]] || [[ $pubkey =~ ^[1-9A-HJ-NP-Za-km-z]{40,50}$ ]]; then
        return 0
    else
        print_message "$RED" "错误：公钥格式无效"
        return 1
    fi
}

# 配置挖矿公钥
configure_mining_key() {
    print_message "$CYAN" ">>> 配置挖矿公钥"
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到配置文件"
        return 1
    fi
    
    local current_key=$(grep "MINING_PUBKEY" "$NOCKCHAIN_DIR/.env" | cut -d'=' -f2)
    print_message "$YELLOW" "当前公钥: $current_key"
    
    read -p "请输入新的挖矿公钥: " new_pubkey
    
    if [ -n "$new_pubkey" ] && validate_pubkey "$new_pubkey"; then
        cd "$NOCKCHAIN_DIR"
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        sed -i "s/MINING_PUBKEY=.*/MINING_PUBKEY=$new_pubkey/" .env
        print_message "$GREEN" "公钥更新成功！"
    fi
}

# 启动挖矿
start_mining() {
    print_message "$GREEN" ">>> 启动优化挖矿节点..."
    
    if [ ! -f "$NOCKCHAIN_DIR/.env" ]; then
        print_message "$RED" "错误：未找到安装"
        return 1
    fi
    
    # 检查现有进程
    if screen -list | grep -q "nockchain"; then
        read -p "检测到挖矿进程正在运行，是否重启？(y/N): " restart
        if [[ "$restart" =~ ^[Yy]$ ]]; then
            screen -S nockchain -X quit
            sleep 3
        else
            return 0
        fi
    fi
    
    cd "$NOCKCHAIN_DIR"
    
    # 激活环境
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    # 设置环境变量
    export RUST_MIN_STACK=16777216
    export RUST_LOG=error
    export MALLOC_ARENA_MAX=2
    
    print_message "$CYAN" "正在启动挖矿节点..."
    
    # 在screen中启动
    screen -dmS nockchain bash -c "
        source '$MINICONDA_DIR/etc/profile.d/conda.sh'
        conda activate nockchain-build
        cd '$NOCKCHAIN_DIR'
        export RUST_MIN_STACK=16777216
        export RUST_LOG=error
        export MALLOC_ARENA_MAX=2
        source .env
        mkdir -p logs
        echo '=== Nockchain 智能优化挖矿 ===' > logs/mining.log
        echo '启动时间: \$(date)' >> logs/mining.log
        echo '版本: 智能冲突解决版' >> logs/mining.log
        echo '=============================' >> logs/mining.log
        make run-nockchain 2>&1 | tee -a logs/mining.log
    "
    
    sleep 5
    
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "🚀 挖矿节点启动成功！"
        print_message "$CYAN" "- 查看状态: screen -r nockchain"
        print_message "$CYAN" "- 停止挖矿: screen -S nockchain -X quit"
    else
        print_message "$RED" "启动失败，请查看日志"
    fi
}

# 查看日志
view_logs() {
    print_message "$GREEN" ">>> 显示挖矿日志"
    
    if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
        tail -f "$NOCKCHAIN_DIR/logs/mining.log"
    else
        if screen -list | grep -q "nockchain"; then
            screen -r nockchain
        else
            print_message "$RED" "未找到日志或进程"
        fi
    fi
}

# 检查余额
check_balance() {
    print_message "$GREEN" ">>> 检查钱包余额"
    
    source "$MINICONDA_DIR/etc/profile.d/conda.sh"
    conda activate nockchain-build
    
    cd "$NOCKCHAIN_DIR"
    local pubkey=$(grep "MINING_PUBKEY" .env | cut -d'=' -f2)
    
    if [ -z "$pubkey" ] || [ "$pubkey" = "0000000000000000000000000000000000000000000000000000000000000000" ]; then
        print_message "$RED" "未配置有效公钥"
        return 1
    fi
    
    print_message "$CYAN" "查询余额: $pubkey"
    
    if check_command "nockchain-wallet"; then
        for socket in ./nockchain*.sock; do
            if [ -S "$socket" ]; then
                nockchain-wallet --nockchain-socket "$socket" list-notes-by-pubkey -p "$pubkey" 2>/dev/null && break
            fi
        done
    fi
}

# 系统监控
system_monitor() {
    print_message "$BLUE" "====== 系统状态监控 ======"
    
    # 基本系统信息
    local mem_info=$(free -h | awk '/^Mem:/{print "使用: "$3" / 总计: "$2}')
    print_message "$YELLOW" "内存状态: $mem_info"
    
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    print_message "$YELLOW" "系统负载: $load_avg"
    
    # 挖矿状态
    if screen -list | grep -q "nockchain"; then
        print_message "$GREEN" "挖矿状态: ✅ 正在运行"
        
        if [ -f "$NOCKCHAIN_DIR/logs/mining.log" ]; then
            print_message "$CYAN" "最近日志："
            tail -n 3 "$NOCKCHAIN_DIR/logs/mining.log" 2>/dev/null
        fi
    else
        print_message "$RED" "挖矿状态: ❌ 未运行"
    fi
    
    # 环境状态
    print_message "$CYAN" "环境状态："
    print_message "$YELLOW" "- Conda: $(which conda 2>/dev/null || echo '未安装')"
    print_message "$YELLOW" "- Rust: $(which rustc 2>/dev/null || echo '未安装')"
}

# 备份钱包
backup_wallet() {
    print_message "$GREEN" ">>> 备份钱包密钥"
    
    local backup_file="$BACKUP_DIR/complete_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    mkdir -p "$BACKUP_DIR"
    
    cd "$NOCKCHAIN_DIR" 2>/dev/null || return 1
    
    # 创建备份
    tar -czf "$backup_file" .env logs/ *.txt 2>/dev/null || true
    
    if [ -f ".env" ]; then
        cp .env "$BACKUP_DIR/env_$(date +%Y%m%d_%H%M%S).backup"
    fi
    
    print_message "$GREEN" "备份完成: $backup_file"
}

# 修复环境问题
fix_environment() {
    print_message "$GREEN" ">>> 修复环境问题"
    
    print_message "$CYAN" "正在诊断环境..."
    
    local issues=()
    
    # 检查Miniconda
    if [ ! -d "$MINICONDA_DIR" ] || ! check_command "conda"; then
        issues+=("Miniconda未正确安装")
    fi
    
    # 检查Rust
    if ! check_command "rustc"; then
        issues+=("Rust未安装")
    fi
    
    # 检查Nockchain
    if [ ! -d "$NOCKCHAIN_DIR" ]; then
        issues+=("Nockchain项目未找到")
    fi
    
    if [ ${#issues[@]} -eq 0 ]; then
        print_message "$GREEN" "环境检查通过"
        return 0
    fi
    
    print_message "$YELLOW" "发现问题："
    for issue in "${issues[@]}"; do
        print_message "$RED" "- $issue"
    done
    
    read -p "是否自动修复？(Y/n): " fix_choice
    if [[ ! "$fix_choice" =~ ^[Nn]$ ]]; then
        print_message "$CYAN" "正在修复环境..."
        
        # 重新配置PATH
        cat >> "$HOME/.bashrc" << 'EOF'

# Nockchain环境配置
export PATH="$HOME/.miniconda3/bin:$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
export RUST_MIN_STACK=16777216
export RUST_LOG=error

# 激活Nockchain环境函数
activate_nockchain() {
    source "$HOME/.miniconda3/etc/profile.d/conda.sh" 2>/dev/null
    conda activate nockchain-build 2>/dev/null || true
    cd "$HOME/nockchain" 2>/dev/null || true
}
EOF
        
        source "$HOME/.bashrc"
        print_message "$GREEN" "环境修复完成"
    fi
}

# 主循环
main() {
    if [ "$EUID" -eq 0 ]; then
        print_message "$RED" "请不要以root用户运行"
        exit 1
    fi
    
    mkdir -p "$BACKUP_DIR"
    touch "$LOG_FILE"
    log_message "智能脚本启动 v6.0"
    
    while true; do
        show_menu
        read -p "请输入选项编号（1-9）: " choice
        
        case $choice in
            1) install_nockchain_intelligent ;;
            2) configure_mining_key ;;
            3) start_mining ;;
            4) view_logs ;;
            5) check_balance ;;
            6) system_monitor ;;
            7) backup_wallet ;;
            8) fix_environment ;;
            9)
                print_message "$GREEN" "感谢使用Nockchain智能解决方案！"
                log_message "脚本正常退出"
                exit 0
                ;;
            *)
                print_message "$RED" "无效选项"
                ;;
        esac
        
        echo
        read -p "按回车键继续..." -r
    done
}

# 启动程序
main
